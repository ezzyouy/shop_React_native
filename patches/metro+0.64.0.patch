diff --git a/node_modules/metro/README.md b/node_modules/metro/README.md
index d0bdfc3..34b920c 100644
--- a/node_modules/metro/README.md
+++ b/node_modules/metro/README.md
@@ -6,4 +6,4 @@
 - **⚖️ Scalable**: Works with thousands of modules in a single application.
 - **⚛️ Integrated**: Supports every React Native project out of the box.
 
-This project was previously part of the [react-native](https://github.com/facebook/react-native) repository. In this smaller repository it is easier for the team working on Metro Bundler to respond to both issues and pull requests. See [react-native#13976](https://github.com/facebook/react-native/issues/13976) for the initial announcement.
+This project was previously part of the [react-native](https://github.com/facebook/react-native) repository. In this smaller repository it is easier for the team working on Metro to respond to both issues and pull requests. See [react-native#13976](https://github.com/facebook/react-native/issues/13976) for the initial announcement.
diff --git a/node_modules/metro/src/Assets.js b/node_modules/metro/src/Assets.js
index d052449..900dcc3 100644
--- a/node_modules/metro/src/Assets.js
+++ b/node_modules/metro/src/Assets.js
@@ -11,35 +11,58 @@
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
 }
 
 function _toArray(arr) {
-  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableRest()
+  );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
@@ -55,6 +78,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -68,12 +92,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -211,9 +238,12 @@ function _getAbsoluteAssetInfo() {
     const name = nameData.name,
       type = nameData.type;
 
-    const _ref = yield getAbsoluteAssetRecord(assetPath, platform),
-      scales = _ref.scales,
-      files = _ref.files;
+    const _yield$getAbsoluteAss = yield getAbsoluteAssetRecord(
+        assetPath,
+        platform
+      ),
+      scales = _yield$getAbsoluteAss.scales,
+      files = _yield$getAbsoluteAss.files;
 
     const hasher = crypto.createHash("md5");
 
@@ -244,10 +274,10 @@ function _getAssetData() {
   ) {
     let platform =
       arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
-    let publicPath = arguments.length > 4 ? arguments[4] : undefined;
-    // If the path of the asset is outside of the projectRoot, we don't want to
+    let publicPath = arguments.length > 4 ? arguments[4] : undefined; // If the path of the asset is outside of the projectRoot, we don't want to
     // use `path.join` since this will generate an incorrect URL path. In that
     // case we just concatenate the publicPath with the relative path.
+
     let assetUrlPath = localPath.startsWith("..")
       ? publicPath.replace(/\/$/, "") + "/" + path.dirname(localPath)
       : path.join(publicPath, path.dirname(localPath)); // On Windows, change backslashes to slashes to get proper URL path from file path.
diff --git a/node_modules/metro/src/Assets.js.flow b/node_modules/metro/src/Assets.js.flow
index f1bd54f..8e6b8ff 100644
--- a/node_modules/metro/src/Assets.js.flow
+++ b/node_modules/metro/src/Assets.js.flow
@@ -43,6 +43,7 @@ export type AssetDataWithoutFiles = {
   +scales: Array<number>,
   +type: string,
   +width: ?number,
+  ...
 };
 export type AssetDataFiltered = {
   +__packager_asset: boolean,
@@ -53,11 +54,10 @@ export type AssetDataFiltered = {
   +scales: Array<number>,
   +type: string,
   +width: ?number,
+  ...
 };
 
-export type AssetData = AssetDataWithoutFiles & {
-  +files: Array<string>,
-};
+export type AssetData = AssetDataWithoutFiles & {+files: Array<string>, ...};
 
 export type AssetDataPlugin = (
   assetData: AssetData,
diff --git a/node_modules/metro/src/Bundler.js b/node_modules/metro/src/Bundler.js
index 194825f..b9cfd75 100644
--- a/node_modules/metro/src/Bundler.js
+++ b/node_modules/metro/src/Bundler.js
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -46,8 +50,8 @@ const DependencyGraph = require("./node-haste/DependencyGraph");
 const Transformer = require("./DeltaBundler/Transformer");
 
 class Bundler {
-  constructor(config) {
-    this._depGraphPromise = DependencyGraph.load(config);
+  constructor(config, options) {
+    this._depGraphPromise = DependencyGraph.load(config, options);
 
     this._depGraphPromise
       .then(dependencyGraph => {
@@ -74,17 +78,21 @@ class Bundler {
   }
 
   getDependencyGraph() {
-    return this._depGraphPromise;
+    var _this2 = this;
+
+    return _asyncToGenerator(function*() {
+      return yield _this2._depGraphPromise;
+    })();
   }
 
   transformFile(filePath, transformOptions) {
-    var _this2 = this;
+    var _this3 = this;
 
     return _asyncToGenerator(function*() {
       // We need to be sure that the DependencyGraph has been initialized.
       // TODO: Remove this ugly hack!
-      yield _this2._depGraphPromise;
-      return _this2._transformer.transformFile(filePath, transformOptions);
+      yield _this3._depGraphPromise;
+      return _this3._transformer.transformFile(filePath, transformOptions);
     })();
   }
 }
diff --git a/node_modules/metro/src/Bundler.js.flow b/node_modules/metro/src/Bundler.js.flow
index b647627..3f96528 100644
--- a/node_modules/metro/src/Bundler.js.flow
+++ b/node_modules/metro/src/Bundler.js.flow
@@ -17,12 +17,17 @@ import type {TransformOptions} from './DeltaBundler/Worker';
 import type {TransformResultWithSource} from './DeltaBundler';
 import type {ConfigT} from 'metro-config/src/configTypes.flow';
 
+export type BundlerOptions = $ReadOnly<{|
+  hasReducedPerformance?: boolean,
+  watch?: boolean,
+|}>;
+
 class Bundler {
   _depGraphPromise: Promise<DependencyGraph>;
   _transformer: Transformer;
 
-  constructor(config: ConfigT) {
-    this._depGraphPromise = DependencyGraph.load(config);
+  constructor(config: ConfigT, options?: BundlerOptions) {
+    this._depGraphPromise = DependencyGraph.load(config, options);
 
     this._depGraphPromise
       .then((dependencyGraph: DependencyGraph) => {
@@ -43,8 +48,8 @@ class Bundler {
     dependencyGraph.getWatcher().end();
   }
 
-  getDependencyGraph(): Promise<DependencyGraph> {
-    return this._depGraphPromise;
+  async getDependencyGraph(): Promise<DependencyGraph> {
+    return await this._depGraphPromise;
   }
 
   async transformFile(
diff --git a/node_modules/metro/src/Bundler/util.js b/node_modules/metro/src/Bundler/util.js
index a50de51..ae8ee8f 100644
--- a/node_modules/metro/src/Bundler/util.js
+++ b/node_modules/metro/src/Bundler/util.js
@@ -8,25 +8,48 @@
  * @format
  */
 "use strict";
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -34,6 +57,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -46,6 +70,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
@@ -53,18 +78,20 @@ function _arrayWithHoles(arr) {
   if (Array.isArray(arr)) return arr;
 }
 
-const template = require("@babel/template").default;
-
 const babelTypes = require("@babel/types");
 
 const babylon = require("@babel/parser");
 
-const assetPropertyBlacklist = new Set(["files", "fileSystemLocation", "path"]);
+const nullthrows = require("nullthrows");
+
+const template = require("@babel/template").default;
+
+const assetPropertyBlockList = new Set(["files", "fileSystemLocation", "path"]);
 
 function generateAssetCodeFileAst(assetRegistryPath, assetDescriptor) {
   const properDescriptor = filterObject(
     assetDescriptor,
-    assetPropertyBlacklist
+    assetPropertyBlockList
   ); // {...}
 
   const descriptorAst = babylon.parseExpression(
@@ -72,7 +99,7 @@ function generateAssetCodeFileAst(assetRegistryPath, assetDescriptor) {
   );
   const t = babelTypes; // require('AssetRegistry').registerAsset({...})
 
-  const buildRequire = template(`
+  const buildRequire = template.statement(`
     module.exports = require(ASSET_REGISTRY_PATH).registerAsset(DESCRIPTOR_AST)
   `);
   return t.file(
@@ -113,9 +140,9 @@ function generateRemoteAssetCodeFileAst(
 
   const URI = t.stringLiteral(remoteServer); // Size numbers.
 
-  const WIDTH = t.numericLiteral(assetDescriptor.width);
-  const HEIGHT = t.numericLiteral(assetDescriptor.height);
-  const buildRequire = template(`
+  const WIDTH = t.numericLiteral(nullthrows(assetDescriptor.width));
+  const HEIGHT = t.numericLiteral(nullthrows(assetDescriptor.height));
+  const buildRequire = template.statement(`
     module.exports = {
       "width": WIDTH,
       "height": HEIGHT,
@@ -150,10 +177,10 @@ function isAssetTypeAnImage(type) {
   );
 }
 
-function filterObject(object, blacklist) {
+function filterObject(object, blockList) {
   const copied = Object.assign({}, object);
 
-  for (const key of blacklist) {
+  for (const key of blockList) {
     delete copied[key];
   }
 
@@ -162,6 +189,7 @@ function filterObject(object, blacklist) {
 
 function createRamBundleGroups(ramGroups, groupableModules, subtree) {
   // build two maps that allow to lookup module data
+  // by path or (numeric) module id;
   const byPath = new Map();
   const byId = new Map();
   groupableModules.forEach(m => {
diff --git a/node_modules/metro/src/Bundler/util.js.flow b/node_modules/metro/src/Bundler/util.js.flow
index 800c4a2..8ce627b 100644
--- a/node_modules/metro/src/Bundler/util.js.flow
+++ b/node_modules/metro/src/Bundler/util.js.flow
@@ -10,16 +10,14 @@
 
 'use strict';
 
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
-const template = require('@babel/template').default;
 const babelTypes = require('@babel/types');
 const babylon = require('@babel/parser');
+const nullthrows = require('nullthrows');
+const template = require('@babel/template').default;
 
 import type {AssetDataFiltered, AssetDataWithoutFiles} from '../Assets';
 import type {ModuleTransportLike} from '../shared/types.flow';
-import type {Ast} from '@babel/core';
+import type {File} from '@babel/types';
 
 // Structure of the object: dir.name.scale = asset
 export type RemoteFileMap = {
@@ -28,16 +26,21 @@ export type RemoteFileMap = {
       [number]: {
         handle: string,
         hash: string,
+        ...
       },
+      ...,
     },
+    ...,
   },
   __proto__: null,
+  ...
 };
 
 // Structure of the object: platform.dir.name.scale = asset
 export type PlatformRemoteFileMap = {
   [string]: RemoteFileMap,
   __proto__: null,
+  ...
 };
 
 type SubTree<T: ModuleTransportLike> = (
@@ -45,15 +48,15 @@ type SubTree<T: ModuleTransportLike> = (
   moduleTransportsByPath: Map<string, T>,
 ) => Iterable<number>;
 
-const assetPropertyBlacklist = new Set(['files', 'fileSystemLocation', 'path']);
+const assetPropertyBlockList = new Set(['files', 'fileSystemLocation', 'path']);
 
 function generateAssetCodeFileAst(
   assetRegistryPath: string,
   assetDescriptor: AssetDataWithoutFiles,
-): Ast {
+): File {
   const properDescriptor = filterObject(
     assetDescriptor,
-    assetPropertyBlacklist,
+    assetPropertyBlockList,
   );
 
   // {...}
@@ -63,7 +66,7 @@ function generateAssetCodeFileAst(
   const t = babelTypes;
 
   // require('AssetRegistry').registerAsset({...})
-  const buildRequire = template(`
+  const buildRequire = template.statement(`
     module.exports = require(ASSET_REGISTRY_PATH).registerAsset(DESCRIPTOR_AST)
   `);
 
@@ -87,7 +90,7 @@ function generateRemoteAssetCodeFileAst(
   assetDescriptor: AssetDataWithoutFiles,
   remoteServer: string,
   remoteFileMap: RemoteFileMap,
-): ?Ast {
+): ?File {
   const t = babelTypes;
 
   const file = remoteFileMap[assetDescriptor.fileSystemLocation];
@@ -109,10 +112,10 @@ function generateRemoteAssetCodeFileAst(
   const URI = t.stringLiteral(remoteServer);
 
   // Size numbers.
-  const WIDTH = t.numericLiteral(assetDescriptor.width);
-  const HEIGHT = t.numericLiteral(assetDescriptor.height);
+  const WIDTH = t.numericLiteral(nullthrows(assetDescriptor.width));
+  const HEIGHT = t.numericLiteral(nullthrows(assetDescriptor.height));
 
-  const buildRequire = template(`
+  const buildRequire = template.statement(`
     module.exports = {
       "width": WIDTH,
       "height": HEIGHT,
@@ -151,10 +154,10 @@ function isAssetTypeAnImage(type: string): boolean {
 
 function filterObject(
   object: AssetDataWithoutFiles,
-  blacklist: Set<string>,
+  blockList: Set<string>,
 ): AssetDataFiltered {
   const copied = Object.assign({}, object);
-  for (const key of blacklist) {
+  for (const key of blockList) {
     delete copied[key];
   }
   return copied;
diff --git a/node_modules/metro/src/DeltaBundler.js b/node_modules/metro/src/DeltaBundler.js
index 05a3808..caf90bb 100644
--- a/node_modules/metro/src/DeltaBundler.js
+++ b/node_modules/metro/src/DeltaBundler.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -52,17 +56,18 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
 const DeltaCalculator = require("./DeltaBundler/DeltaCalculator");
-
 /**
  * `DeltaBundler` uses the `DeltaTransformer` to build bundle deltas. This
  * module handles all the transformer instances so it can support multiple
  * concurrent clients requesting their own deltas. This is done through the
  * `clientId` param (which maps a client to a specific delta transformer).
  */
+
 class DeltaBundler {
   constructor(bundler) {
     _defineProperty(this, "_deltaCalculators", new Map());
@@ -76,7 +81,7 @@ class DeltaBundler {
     this._deltaCalculators = new Map();
   }
 
-  buildGraph(entryPoints, options) {
+  getDependencies(entryPoints, options) {
     var _this = this;
 
     return _asyncToGenerator(function*() {
@@ -91,20 +96,42 @@ class DeltaBundler {
         shallow: options.shallow
       });
       const graph = deltaCalculator.getGraph();
+      deltaCalculator.end();
+      return graph.dependencies;
+    })();
+  } // Note: the graph returned by this function needs to be ended when finished
+  // so that we don't leak graphs that are not reachable.
+  // To get just the dependencies, use getDependencies which will not leak graphs.
+
+  buildGraph(entryPoints, options) {
+    var _this2 = this;
+
+    return _asyncToGenerator(function*() {
+      const depGraph = yield _this2._bundler.getDependencyGraph();
+      const deltaCalculator = new DeltaCalculator(
+        entryPoints,
+        depGraph,
+        options
+      );
+      yield deltaCalculator.getDelta({
+        reset: true,
+        shallow: options.shallow
+      });
+      const graph = deltaCalculator.getGraph();
 
-      _this._deltaCalculators.set(graph, deltaCalculator);
+      _this2._deltaCalculators.set(graph, deltaCalculator);
 
       return graph;
     })();
   }
 
   getDelta(graph, _ref) {
-    var _this2 = this;
+    var _this3 = this;
 
     let reset = _ref.reset,
       shallow = _ref.shallow;
     return _asyncToGenerator(function*() {
-      const deltaCalculator = _this2._deltaCalculators.get(graph);
+      const deltaCalculator = _this3._deltaCalculators.get(graph);
 
       if (!deltaCalculator) {
         throw new Error("Graph not found");
diff --git a/node_modules/metro/src/DeltaBundler.js.flow b/node_modules/metro/src/DeltaBundler.js.flow
index 3cbdcd3..5b520e2 100644
--- a/node_modules/metro/src/DeltaBundler.js.flow
+++ b/node_modules/metro/src/DeltaBundler.js.flow
@@ -16,6 +16,7 @@ import type Bundler from './Bundler';
 import type {
   DeltaResult,
   Graph,
+  Dependencies,
   // eslint-disable-next-line no-unused-vars
   MixedOutput,
   Options,
@@ -24,6 +25,7 @@ import type {
 export type {
   DeltaResult,
   Graph,
+  Dependencies,
   MixedOutput,
   Module,
   TransformFn,
@@ -53,6 +55,24 @@ class DeltaBundler<T = MixedOutput> {
     this._deltaCalculators = new Map();
   }
 
+  async getDependencies(
+    entryPoints: $ReadOnlyArray<string>,
+    options: Options<T>,
+  ): Promise<Dependencies<T>> {
+    const depGraph = await this._bundler.getDependencyGraph();
+
+    const deltaCalculator = new DeltaCalculator(entryPoints, depGraph, options);
+
+    await deltaCalculator.getDelta({reset: true, shallow: options.shallow});
+    const graph = deltaCalculator.getGraph();
+
+    deltaCalculator.end();
+    return graph.dependencies;
+  }
+
+  // Note: the graph returned by this function needs to be ended when finished
+  // so that we don't leak graphs that are not reachable.
+  // To get just the dependencies, use getDependencies which will not leak graphs.
   async buildGraph(
     entryPoints: $ReadOnlyArray<string>,
     options: Options<T>,
@@ -65,13 +85,19 @@ class DeltaBundler<T = MixedOutput> {
     const graph = deltaCalculator.getGraph();
 
     this._deltaCalculators.set(graph, deltaCalculator);
-
     return graph;
   }
 
   async getDelta(
     graph: Graph<T>,
-    {reset, shallow}: {reset: boolean, shallow: boolean},
+    {
+      reset,
+      shallow,
+    }: {
+      reset: boolean,
+      shallow: boolean,
+      ...
+    },
   ): Promise<DeltaResult<T>> {
     const deltaCalculator = this._deltaCalculators.get(graph);
 
diff --git a/node_modules/metro/src/DeltaBundler/DeltaCalculator.js b/node_modules/metro/src/DeltaBundler/DeltaCalculator.js
index 541996e..9daaf96 100644
--- a/node_modules/metro/src/DeltaBundler/DeltaCalculator.js
+++ b/node_modules/metro/src/DeltaBundler/DeltaCalculator.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -52,6 +56,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -62,13 +67,13 @@ const _require = require("./traverseDependencies"),
 
 const _require2 = require("events"),
   EventEmitter = _require2.EventEmitter;
-
 /**
  * This class is in charge of calculating the delta of changed modules that
  * happen between calls. To do so, it subscribes to file changes, so it can
  * traverse the files that have been changed between calls and avoid having to
  * traverse the whole dependency tree for trivial small changes.
  */
+
 class DeltaCalculator extends EventEmitter {
   constructor(entryPoints, dependencyGraph, options) {
     super();
@@ -215,11 +220,11 @@ class DeltaCalculator extends EventEmitter {
 
     return _asyncToGenerator(function*() {
       if (!_this2._graph.dependencies.size) {
-        const _ref4 = yield initialTraverseDependencies(
+        const _yield$initialTravers = yield initialTraverseDependencies(
             _this2._graph,
             _this2._options
           ),
-          added = _ref4.added;
+          added = _yield$initialTravers.added;
 
         return {
           added,
@@ -257,14 +262,14 @@ class DeltaCalculator extends EventEmitter {
         };
       }
 
-      const _ref5 = yield traverseDependencies(
+      const _yield$traverseDepend = yield traverseDependencies(
           modifiedDependencies,
           _this2._graph,
           _this2._options
         ),
-        added = _ref5.added,
-        modified = _ref5.modified,
-        deleted = _ref5.deleted;
+        added = _yield$traverseDepend.added,
+        modified = _yield$traverseDepend.modified,
+        deleted = _yield$traverseDepend.deleted;
 
       return {
         added,
diff --git a/node_modules/metro/src/DeltaBundler/DeltaCalculator.js.flow b/node_modules/metro/src/DeltaBundler/DeltaCalculator.js.flow
index f9de341..9668719 100644
--- a/node_modules/metro/src/DeltaBundler/DeltaCalculator.js.flow
+++ b/node_modules/metro/src/DeltaBundler/DeltaCalculator.js.flow
@@ -87,6 +87,7 @@ class DeltaCalculator<T> extends EventEmitter {
   }: {
     reset: boolean,
     shallow: boolean,
+    ...
   }): Promise<DeltaResult<T>> {
     // If there is already a build in progress, wait until it finish to start
     // processing a new one (delta server doesn't support concurrent builds).
@@ -175,6 +176,7 @@ class DeltaCalculator<T> extends EventEmitter {
   }: {
     type: string,
     filePath: string,
+    ...
   }): mixed => {
     if (type === 'delete') {
       this._deletedFiles.add(filePath);
@@ -224,9 +226,9 @@ class DeltaCalculator<T> extends EventEmitter {
     });
 
     // We only want to process files that are in the bundle.
-    const modifiedDependencies = Array.from(modifiedFiles).filter(
-      (filePath: string) => this._graph.dependencies.has(filePath),
-    );
+    const modifiedDependencies = Array.from(
+      modifiedFiles,
+    ).filter((filePath: string) => this._graph.dependencies.has(filePath));
 
     // No changes happened. Return empty delta.
     if (modifiedDependencies.length === 0) {
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/baseBytecodeBundle.js b/node_modules/metro/src/DeltaBundler/Serializers/baseBytecodeBundle.js
new file mode 100644
index 0000000..2de6ea0
--- /dev/null
+++ b/node_modules/metro/src/DeltaBundler/Serializers/baseBytecodeBundle.js
@@ -0,0 +1,256 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *
+ * @format
+ */
+"use strict";
+
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _e = undefined;
+
+  try {
+    for (
+      var _i = arr[Symbol.iterator](), _s;
+      !(_n = (_s = _i.next()).done);
+      _n = true
+    ) {
+      _arr.push(_s.value);
+
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+
+  return _arr;
+}
+
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
+
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
+function _objectSpread(target) {
+  for (var i = 1; i < arguments.length; i++) {
+    var source = arguments[i] != null ? arguments[i] : {};
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
+    }
+  }
+
+  return target;
+}
+
+function _defineProperty(obj, key, value) {
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+
+  return obj;
+}
+
+function _toConsumableArray(arr) {
+  return (
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
+  );
+}
+
+function _nonIterableSpread() {
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _iterableToArray(iter) {
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
+    return Array.from(iter);
+}
+
+function _arrayWithoutHoles(arr) {
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+const getAppendScripts = require("../../lib/getAppendScripts");
+
+const processBytecodeModules = require("./helpers/processBytecodeModules");
+
+const _require = require("./helpers/js"),
+  getJsOutput = _require.getJsOutput;
+
+const _require2 = require("metro-hermes-compiler"),
+  compile = _require2.compile;
+
+function baseBytecodeBundle(entryPoint, preModules, graph, options) {
+  for (const module of graph.dependencies.values()) {
+    options.createModuleId(module.path);
+  }
+
+  const processModulesOptions = {
+    filter: options.processModuleFilter,
+    createModuleId: options.createModuleId,
+    dev: options.dev,
+    projectRoot: options.projectRoot
+  }; // Do not prepend polyfills or the require runtime when only modules are requested
+
+  if (options.modulesOnly) {
+    preModules = [];
+  }
+
+  const modules = _toConsumableArray(graph.dependencies.values()).sort(
+    (a, b) => options.createModuleId(a.path) - options.createModuleId(b.path)
+  );
+
+  const post = processBytecodeModules(
+    getAppendScripts(
+      entryPoint,
+      [].concat(_toConsumableArray(preModules), _toConsumableArray(modules)),
+      graph.importBundleNames,
+      {
+        asyncRequireModulePath: options.asyncRequireModulePath,
+        createModuleId: options.createModuleId,
+        getRunModuleStatement: options.getRunModuleStatement,
+        inlineSourceMap: options.inlineSourceMap,
+        projectRoot: options.projectRoot,
+        runBeforeMainModule: options.runBeforeMainModule,
+        runModule: options.runModule,
+        sourceMapUrl: options.sourceMapUrl,
+        sourceUrl: options.sourceUrl
+      }
+    ).map(module => {
+      return _objectSpread(
+        _objectSpread({}, module),
+        {},
+        {
+          output: [].concat(_toConsumableArray(module.output), [
+            {
+              type: "bytecode/script/virtual",
+              data: {
+                bytecode: compile(getJsOutput(module).data.code, {
+                  sourceURL: module.path
+                }).bytecode
+              }
+            }
+          ])
+        }
+      );
+    }),
+    processModulesOptions
+  ).flatMap(_ref => {
+    let _ref2 = _slicedToArray(_ref, 2),
+      module = _ref2[0],
+      bytecodeBundle = _ref2[1];
+
+    return bytecodeBundle;
+  });
+  const processedModules = processBytecodeModules(
+    _toConsumableArray(graph.dependencies.values()),
+    processModulesOptions
+  ).map(_ref3 => {
+    let _ref4 = _slicedToArray(_ref3, 2),
+      module = _ref4[0],
+      bytecodeBundle = _ref4[1];
+
+    return [options.createModuleId(module.path), bytecodeBundle];
+  });
+  return {
+    pre: processBytecodeModules(preModules, processModulesOptions).flatMap(
+      _ref5 => {
+        let _ref6 = _slicedToArray(_ref5, 2),
+          _ = _ref6[0],
+          bytecodeBundle = _ref6[1];
+
+        return bytecodeBundle;
+      }
+    ),
+    post,
+    modules: processedModules
+  };
+}
+
+module.exports = baseBytecodeBundle;
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/baseBytecodeBundle.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/baseBytecodeBundle.js.flow
new file mode 100644
index 0000000..6a93d49
--- /dev/null
+++ b/node_modules/metro/src/DeltaBundler/Serializers/baseBytecodeBundle.js.flow
@@ -0,0 +1,106 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ * @format
+ */
+
+'use strict';
+
+const getAppendScripts = require('../../lib/getAppendScripts');
+const processBytecodeModules = require('./helpers/processBytecodeModules');
+
+const {getJsOutput} = require('./helpers/js');
+const {compile} = require('metro-hermes-compiler');
+
+import type {
+  Graph,
+  MixedOutput,
+  Module,
+  SerializerOptions,
+} from '../types.flow';
+import type {BytecodeBundle} from 'metro-runtime/src/modules/types.flow';
+
+function baseBytecodeBundle(
+  entryPoint: string,
+  preModules: $ReadOnlyArray<Module<>>,
+  graph: Graph<>,
+  options: SerializerOptions,
+): BytecodeBundle {
+  for (const module of graph.dependencies.values()) {
+    options.createModuleId(module.path);
+  }
+
+  const processModulesOptions = {
+    filter: options.processModuleFilter,
+    createModuleId: options.createModuleId,
+    dev: options.dev,
+    projectRoot: options.projectRoot,
+  };
+
+  // Do not prepend polyfills or the require runtime when only modules are requested
+  if (options.modulesOnly) {
+    preModules = [];
+  }
+
+  const modules = [...graph.dependencies.values()].sort(
+    (a: Module<MixedOutput>, b: Module<MixedOutput>) =>
+      options.createModuleId(a.path) - options.createModuleId(b.path),
+  );
+
+  const post = processBytecodeModules(
+    getAppendScripts(
+      entryPoint,
+      [...preModules, ...modules],
+      graph.importBundleNames,
+      {
+        asyncRequireModulePath: options.asyncRequireModulePath,
+        createModuleId: options.createModuleId,
+        getRunModuleStatement: options.getRunModuleStatement,
+        inlineSourceMap: options.inlineSourceMap,
+        projectRoot: options.projectRoot,
+        runBeforeMainModule: options.runBeforeMainModule,
+        runModule: options.runModule,
+        sourceMapUrl: options.sourceMapUrl,
+        sourceUrl: options.sourceUrl,
+      },
+    ).map(module => {
+      return {
+        ...module,
+        output: [
+          ...module.output,
+          {
+            type: 'bytecode/script/virtual',
+            data: {
+              bytecode: compile(getJsOutput(module).data.code, {
+                sourceURL: module.path,
+              }).bytecode,
+            },
+          },
+        ],
+      };
+    }),
+    processModulesOptions,
+  ).flatMap(([module, bytecodeBundle]) => bytecodeBundle);
+
+  const processedModules = processBytecodeModules(
+    [...graph.dependencies.values()],
+    processModulesOptions,
+  ).map(([module, bytecodeBundle]) => [
+    options.createModuleId(module.path),
+    bytecodeBundle,
+  ]);
+
+  return {
+    pre: processBytecodeModules(preModules, processModulesOptions).flatMap(
+      ([_, bytecodeBundle]) => bytecodeBundle,
+    ),
+    post,
+    modules: processedModules,
+  };
+}
+
+module.exports = baseBytecodeBundle;
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/baseJSBundle.js b/node_modules/metro/src/DeltaBundler/Serializers/baseJSBundle.js
index e27be6f..9b6f17f 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/baseJSBundle.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/baseJSBundle.js
@@ -11,45 +11,69 @@
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
 }
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -57,6 +81,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -69,6 +94,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
@@ -113,7 +139,7 @@ function baseJSBundle(entryPoint, preModules, graph, options) {
   const postCode = processModules(
     getAppendScripts(
       entryPoint,
-      _toConsumableArray(preModules).concat(_toConsumableArray(modules)),
+      [].concat(_toConsumableArray(preModules), _toConsumableArray(modules)),
       graph.importBundleNames,
       {
         asyncRequireModulePath: options.asyncRequireModulePath,
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/baseJSBundle.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/baseJSBundle.js.flow
index c6793fb..7568cd7 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/baseJSBundle.js.flow
+++ b/node_modules/metro/src/DeltaBundler/Serializers/baseJSBundle.js.flow
@@ -13,13 +13,13 @@
 const getAppendScripts = require('../../lib/getAppendScripts');
 const processModules = require('./helpers/processModules');
 
-import type {Bundle} from '../../lib/bundle-modules/types.flow';
 import type {
   Graph,
   MixedOutput,
   Module,
   SerializerOptions,
 } from '../types.flow';
+import type {Bundle} from 'metro-runtime/src/modules/types.flow';
 
 function baseJSBundle(
   entryPoint: string,
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/deltaJSBundle.js b/node_modules/metro/src/DeltaBundler/Serializers/deltaJSBundle.js
deleted file mode 100644
index 4347714..0000000
--- a/node_modules/metro/src/DeltaBundler/Serializers/deltaJSBundle.js
+++ /dev/null
@@ -1,158 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-function _slicedToArray(arr, i) {
-  return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
-  );
-}
-
-function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
-}
-
-function _iterableToArrayLimit(arr, i) {
-  var _arr = [];
-  var _n = true;
-  var _d = false;
-  var _e = undefined;
-  try {
-    for (
-      var _i = arr[Symbol.iterator](), _s;
-      !(_n = (_s = _i.next()).done);
-      _n = true
-    ) {
-      _arr.push(_s.value);
-      if (i && _arr.length === i) break;
-    }
-  } catch (err) {
-    _d = true;
-    _e = err;
-  } finally {
-    try {
-      if (!_n && _i["return"] != null) _i["return"]();
-    } finally {
-      if (_d) throw _e;
-    }
-  }
-  return _arr;
-}
-
-function _arrayWithHoles(arr) {
-  if (Array.isArray(arr)) return arr;
-}
-
-function _toConsumableArray(arr) {
-  return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
-  );
-}
-
-function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
-}
-
-function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
-    return Array.from(iter);
-}
-
-function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
-}
-
-const getAppendScripts = require("../../lib/getAppendScripts");
-
-const processModules = require("./helpers/processModules");
-
-const _require = require("./helpers/js"),
-  getJsOutput = _require.getJsOutput,
-  isJsModule = _require.isJsModule;
-
-function deltaJSBundle(entryPoint, pre, delta, revisionId, graph, options) {
-  const processModuleFilter = options.processModuleFilter;
-  const processOpts = {
-    filter: processModuleFilter,
-    dev: options.dev,
-    createModuleId: options.createModuleId,
-    projectRoot: options.projectRoot
-  };
-  const added = processModules(
-    _toConsumableArray(delta.added.values()),
-    processOpts
-  ).map(_ref => {
-    let _ref2 = _slicedToArray(_ref, 2),
-      module = _ref2[0],
-      code = _ref2[1];
-
-    return [options.createModuleId(module.path), code];
-  });
-
-  if (delta.reset) {
-    const modules = _toConsumableArray(graph.dependencies.values()).sort(
-      (a, b) => options.createModuleId(a.path) - options.createModuleId(b.path)
-    );
-
-    const appendScripts = getAppendScripts(
-      entryPoint,
-      _toConsumableArray(pre).concat(_toConsumableArray(modules)),
-      graph.importBundleNames,
-      options
-    );
-    return {
-      base: true,
-      revisionId,
-      pre: pre
-        .filter(isJsModule)
-        .filter(processModuleFilter)
-        .map(module => getJsOutput(module).data.code)
-        .join("\n"),
-      post: appendScripts
-        .filter(isJsModule)
-        .filter(processModuleFilter)
-        .map(module => getJsOutput(module).data.code)
-        .join("\n"),
-      modules: _toConsumableArray(added)
-    };
-  }
-
-  const modified = processModules(
-    _toConsumableArray(delta.modified.values()),
-    processOpts
-  ).map(_ref3 => {
-    let _ref4 = _slicedToArray(_ref3, 2),
-      module = _ref4[0],
-      code = _ref4[1];
-
-    return [options.createModuleId(module.path), code];
-  });
-
-  const deleted = _toConsumableArray(delta.deleted).map(path =>
-    options.createModuleId(path)
-  );
-
-  return {
-    base: false,
-    revisionId,
-    added,
-    modified,
-    deleted
-  };
-}
-
-module.exports = deltaJSBundle;
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/deltaJSBundle.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/deltaJSBundle.js.flow
deleted file mode 100644
index 14fcbcb..0000000
--- a/node_modules/metro/src/DeltaBundler/Serializers/deltaJSBundle.js.flow
+++ /dev/null
@@ -1,96 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-const getAppendScripts = require('../../lib/getAppendScripts');
-const processModules = require('./helpers/processModules');
-
-const {getJsOutput, isJsModule} = require('./helpers/js');
-
-import type {RevisionId} from '../../IncrementalBundler';
-import type {BundleVariant} from '../../lib/bundle-modules/types.flow';
-import type {
-  DeltaResult,
-  Graph,
-  Module,
-  SerializerOptions,
-} from '../types.flow';
-import type {MixedOutput} from '../types.flow';
-
-function deltaJSBundle(
-  entryPoint: string,
-  pre: $ReadOnlyArray<Module<>>,
-  delta: DeltaResult<>,
-  revisionId: RevisionId,
-  graph: Graph<>,
-  options: SerializerOptions,
-): BundleVariant {
-  const {processModuleFilter} = options;
-
-  const processOpts = {
-    filter: processModuleFilter,
-    dev: options.dev,
-    createModuleId: options.createModuleId,
-    projectRoot: options.projectRoot,
-  };
-
-  const added = processModules([...delta.added.values()], processOpts).map(
-    ([module, code]) => [options.createModuleId(module.path), code],
-  );
-
-  if (delta.reset) {
-    const modules = [...graph.dependencies.values()].sort(
-      (a: Module<MixedOutput>, b: Module<MixedOutput>) =>
-        options.createModuleId(a.path) - options.createModuleId(b.path),
-    );
-    const appendScripts = getAppendScripts(
-      entryPoint,
-      [...pre, ...modules],
-      graph.importBundleNames,
-      options,
-    );
-
-    return {
-      base: true,
-      revisionId,
-      pre: pre
-        .filter(isJsModule)
-        .filter(processModuleFilter)
-        .map((module: Module<>) => getJsOutput(module).data.code)
-        .join('\n'),
-      post: appendScripts
-        .filter(isJsModule)
-        .filter(processModuleFilter)
-        .map((module: Module<>) => getJsOutput(module).data.code)
-        .join('\n'),
-      modules: [...added],
-    };
-  }
-
-  const modified = processModules(
-    [...delta.modified.values()],
-    processOpts,
-  ).map(([module, code]) => [options.createModuleId(module.path), code]);
-
-  const deleted = [...delta.deleted].map((path: string) =>
-    options.createModuleId(path),
-  );
-
-  return {
-    base: false,
-    revisionId,
-    added,
-    modified,
-    deleted,
-  };
-}
-
-module.exports = deltaJSBundle;
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/getAllFiles.js b/node_modules/metro/src/DeltaBundler/Serializers/getAllFiles.js
index f0db9e2..70ffab0 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/getAllFiles.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/getAllFiles.js
@@ -4,35 +4,51 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
@@ -43,6 +59,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -56,12 +73,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/getAssets.js b/node_modules/metro/src/DeltaBundler/Serializers/getAssets.js
index 1024bba..7fe126e 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/getAssets.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/getAssets.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -55,11 +59,11 @@ function getAssets(_x, _x2) {
 }
 
 function _getAssets() {
-  _getAssets = _asyncToGenerator(function*(graph, options) {
+  _getAssets = _asyncToGenerator(function*(dependencies, options) {
     const promises = [];
     const processModuleFilter = options.processModuleFilter;
 
-    for (const module of graph.dependencies.values()) {
+    for (const module of dependencies.values()) {
       if (
         isJsModule(module) &&
         processModuleFilter(module) &&
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/getAssets.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/getAssets.js.flow
index 362b5bf..11c69dc 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/getAssets.js.flow
+++ b/node_modules/metro/src/DeltaBundler/Serializers/getAssets.js.flow
@@ -16,7 +16,7 @@ const {getAssetData} = require('../../Assets');
 const {getJsOutput, isJsModule} = require('./helpers/js');
 
 import type {AssetData} from '../../Assets';
-import type {Graph, Module} from '../types.flow';
+import type {Dependencies, Module} from '../types.flow';
 
 type Options = {|
   +processModuleFilter: (module: Module<>) => boolean,
@@ -27,13 +27,13 @@ type Options = {|
 |};
 
 async function getAssets(
-  graph: Graph<>,
+  dependencies: Dependencies<>,
   options: Options,
 ): Promise<$ReadOnlyArray<AssetData>> {
   const promises = [];
   const {processModuleFilter} = options;
 
-  for (const module of graph.dependencies.values()) {
+  for (const module of dependencies.values()) {
     if (
       isJsModule(module) &&
       processModuleFilter(module) &&
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/getExplodedSourceMap.js b/node_modules/metro/src/DeltaBundler/Serializers/getExplodedSourceMap.js
index 8219eaf..98c3492 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/getExplodedSourceMap.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/getExplodedSourceMap.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/getRamBundleInfo.js b/node_modules/metro/src/DeltaBundler/Serializers/getRamBundleInfo.js
index a7b6d90..4dfc736 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/getRamBundleInfo.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/getRamBundleInfo.js
@@ -11,28 +11,44 @@
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
@@ -43,6 +59,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -56,12 +73,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -99,10 +119,10 @@ function _getRamBundleInfo() {
     graph,
     options
   ) {
-    let modules = _toConsumableArray(pre).concat(
+    let modules = [].concat(
+      _toConsumableArray(pre),
       _toConsumableArray(graph.dependencies.values())
     );
-
     modules = modules.concat(
       getAppendScripts(entryPoint, modules, graph.importBundleNames, options)
     );
@@ -128,7 +148,7 @@ function _getRamBundleInfo() {
         ).type
       }));
 
-    const _ref2 = yield _getRamOptions(
+    const _yield$_getRamOptions = yield _getRamOptions(
         entryPoint,
         {
           dev: options.dev,
@@ -137,8 +157,8 @@ function _getRamBundleInfo() {
         filePath => getTransitiveDependencies(filePath, graph),
         options.getTransformOptions
       ),
-      preloadedModules = _ref2.preloadedModules,
-      ramGroups = _ref2.ramGroups;
+      preloadedModules = _yield$_getRamOptions.preloadedModules,
+      ramGroups = _yield$_getRamOptions.ramGroups;
 
     const startupModules = [];
     const lazyModules = [];
@@ -203,7 +223,7 @@ function _getRamOptions2() {
       };
     }
 
-    const _ref3 = yield getTransformOptions(
+    const _yield$getTransformOp = yield getTransformOptions(
         [entryFile],
         {
           dev: options.dev,
@@ -216,17 +236,17 @@ function _getRamOptions2() {
          * error found when Flow v0.99 was deployed. To see the error, delete this
          * comment and run Flow. */
         (function() {
-          var _ref4 = _asyncToGenerator(function*(x) {
+          var _ref2 = _asyncToGenerator(function*(x) {
             return Array.from(getDependencies);
           });
 
           return function(_x9) {
-            return _ref4.apply(this, arguments);
+            return _ref2.apply(this, arguments);
           };
         })()
       ),
-      preloadedModules = _ref3.preloadedModules,
-      ramGroups = _ref3.ramGroups;
+      preloadedModules = _yield$getTransformOp.preloadedModules,
+      ramGroups = _yield$getTransformOp.ramGroups;
 
     return {
       preloadedModules: preloadedModules || {},
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/getRamBundleInfo.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/getRamBundleInfo.js.flow
index 93845c0..7f4feac 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/getRamBundleInfo.js.flow
+++ b/node_modules/metro/src/DeltaBundler/Serializers/getRamBundleInfo.js.flow
@@ -59,21 +59,19 @@ async function getRamBundleInfo(
   const ramModules: Array<RamModuleTransport> = modules
     .filter(isJsModule)
     .filter(options.processModuleFilter)
-    .map(
-      (module: Module<>): RamModuleTransport => ({
-        id: options.createModuleId(module.path),
-        code: wrapModule(module, options),
-        map: sourceMapObject([module], {
-          excludeSource: options.excludeSource,
-          processModuleFilter: options.processModuleFilter,
-        }),
-        name: path.basename(module.path),
-        sourcePath: module.path,
-        source: module.getSource().toString(),
-        type: nullthrows(module.output.find(({type}) => type.startsWith('js')))
-          .type,
+    .map((module: Module<>): RamModuleTransport => ({
+      id: options.createModuleId(module.path),
+      code: wrapModule(module, options),
+      map: sourceMapObject([module], {
+        excludeSource: options.excludeSource,
+        processModuleFilter: options.processModuleFilter,
       }),
-    );
+      name: path.basename(module.path),
+      sourcePath: module.path,
+      source: module.getSource().toString(),
+      type: nullthrows(module.output.find(({type}) => type.startsWith('js')))
+        .type,
+    }));
 
   const {preloadedModules, ramGroups} = await _getRamOptions(
     entryPoint,
@@ -140,10 +138,17 @@ async function getRamBundleInfo(
  */
 async function _getRamOptions(
   entryFile: string,
-  options: {dev: boolean, platform: ?string},
+  options: {
+    dev: boolean,
+    platform: ?string,
+    ...
+  },
   getDependencies: string => Iterable<string>,
   getTransformOptions: ?GetTransformOptions,
-): Promise<{|+preloadedModules: {[string]: true}, +ramGroups: Array<string>|}> {
+): Promise<{|
+  +preloadedModules: {[string]: true, ...},
+  +ramGroups: Array<string>,
+|}> {
   if (getTransformOptions == null) {
     return {
       preloadedModules: {},
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/bytecode.js b/node_modules/metro/src/DeltaBundler/Serializers/helpers/bytecode.js
new file mode 100644
index 0000000..10bb52f
--- /dev/null
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/bytecode.js
@@ -0,0 +1,149 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *
+ * @format
+ */
+"use strict";
+
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
+function _objectSpread(target) {
+  for (var i = 1; i < arguments.length; i++) {
+    var source = arguments[i] != null ? arguments[i] : {};
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
+    }
+  }
+
+  return target;
+}
+
+function _defineProperty(obj, key, value) {
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+
+  return obj;
+}
+
+const invariant = require("invariant");
+
+const path = require("path");
+
+const _require = require("metro-hermes-compiler"),
+  compile = _require.compile;
+
+function wrapModule(module, options) {
+  const output = getBytecodeOutput(module);
+
+  if (output.type.startsWith("bytecode/script")) {
+    return [output.data.bytecode];
+  }
+
+  const params = [
+    options.createModuleId(module.path),
+    "[" +
+      Array.from(module.dependencies.values())
+        .map(dependency => options.createModuleId(dependency.absolutePath))
+        .join(",") +
+      "]"
+  ];
+
+  if (options.dev) {
+    // Add the relative path of the module to make debugging easier.
+    // This is mapped to `module.verboseName` in `require.js`.
+    params.push(
+      JSON.stringify(path.relative(options.projectRoot, module.path))
+    );
+  }
+
+  const headerCode = `globalThis.$$METRO_D=[${params.join(",")}];`;
+  return [
+    compile(headerCode, {
+      sourceURL: module.path + "-virtual.js"
+    }).bytecode,
+    output.data.bytecode
+  ];
+}
+
+function getBytecodeOutput(module) {
+  const output = module.output
+    .filter(_ref => {
+      let type = _ref.type;
+      return type.startsWith("bytecode/");
+    })
+    .map(output =>
+      output.data.bytecode instanceof Buffer
+        ? output // Re-create buffers after losing the Buffer instance when sending data over workers.
+        : _objectSpread(
+            _objectSpread({}, output),
+            {},
+            {
+              data: _objectSpread(
+                _objectSpread({}, output.data),
+                {},
+                {
+                  bytecode: Buffer.from(output.data.bytecode.data)
+                }
+              )
+            }
+          )
+    );
+  invariant(
+    output.length === 1,
+    `Modules must have exactly one bytecode output, but ${module.path} has ${output.length} bytecode outputs.`
+  );
+  return output[0];
+}
+
+function isBytecodeModule(module) {
+  return (
+    module.output.filter(_ref2 => {
+      let type = _ref2.type;
+      return type.startsWith("bytecode/");
+    }).length > 0
+  );
+}
+
+module.exports = {
+  getBytecodeOutput,
+  isBytecodeModule,
+  wrapModule
+};
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/bytecode.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/helpers/bytecode.js.flow
new file mode 100644
index 0000000..9f85b40
--- /dev/null
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/bytecode.js.flow
@@ -0,0 +1,95 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ * @format
+ */
+
+'use strict';
+
+const invariant = require('invariant');
+const path = require('path');
+
+const {compile} = require('metro-hermes-compiler');
+
+import type {Module} from '../../types.flow';
+import type {BytecodeOutput} from 'metro-transform-worker';
+
+export type Options = {
+  +createModuleId: string => number | string,
+  +dev: boolean,
+  +projectRoot: string,
+  ...
+};
+
+function wrapModule(module: Module<>, options: Options): Array<Buffer> {
+  const output = getBytecodeOutput(module);
+
+  if (output.type.startsWith('bytecode/script')) {
+    return [output.data.bytecode];
+  }
+
+  const params = [
+    options.createModuleId(module.path),
+    '[' +
+      Array.from(module.dependencies.values())
+        .map(dependency => options.createModuleId(dependency.absolutePath))
+        .join(',') +
+      ']',
+  ];
+
+  if (options.dev) {
+    // Add the relative path of the module to make debugging easier.
+    // This is mapped to `module.verboseName` in `require.js`.
+    params.push(
+      JSON.stringify(path.relative(options.projectRoot, module.path)),
+    );
+  }
+
+  const headerCode = `globalThis.$$METRO_D=[${params.join(',')}];`;
+  return [
+    compile(headerCode, {
+      sourceURL: module.path + '-virtual.js',
+    }).bytecode,
+    output.data.bytecode,
+  ];
+}
+
+function getBytecodeOutput(module: Module<>): BytecodeOutput {
+  const output = module.output
+    .filter(({type}) => type.startsWith('bytecode/'))
+    .map((output: any) =>
+      output.data.bytecode instanceof Buffer
+        ? output
+        : // Re-create buffers after losing the Buffer instance when sending data over workers.
+          {
+            ...output,
+            data: {
+              ...output.data,
+              bytecode: Buffer.from(output.data.bytecode.data),
+            },
+          },
+    );
+
+  invariant(
+    output.length === 1,
+    `Modules must have exactly one bytecode output, but ${module.path} has ${output.length} bytecode outputs.`,
+  );
+
+  return (output[0]: any);
+}
+
+function isBytecodeModule(module: Module<>): boolean {
+  return (
+    module.output.filter(({type}) => type.startsWith('bytecode/')).length > 0
+  );
+}
+
+module.exports = {
+  getBytecodeOutput,
+  isBytecodeModule,
+  wrapModule,
+};
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/getInlineSourceMappingURL.js b/node_modules/metro/src/DeltaBundler/Serializers/helpers/getInlineSourceMappingURL.js
index ea12f6a..e6e91ec 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/helpers/getInlineSourceMappingURL.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/getInlineSourceMappingURL.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/getSourceMapInfo.js b/node_modules/metro/src/DeltaBundler/Serializers/helpers/getSourceMapInfo.js
index 7ab0ad0..605b21d 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/helpers/getSourceMapInfo.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/getSourceMapInfo.js
@@ -4,26 +4,47 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,6 +59,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -45,10 +67,14 @@ const _require = require("./js"),
   getJsOutput = _require.getJsOutput;
 
 function getSourceMapInfo(module, options) {
-  return _objectSpread({}, getJsOutput(module).data, {
-    path: module.path,
-    source: options.excludeSource ? "" : getModuleSource(module)
-  });
+  return _objectSpread(
+    _objectSpread({}, getJsOutput(module).data),
+    {},
+    {
+      path: module.path,
+      source: options.excludeSource ? "" : getModuleSource(module)
+    }
+  );
 }
 
 function getModuleSource(module) {
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/getTransitiveDependencies.js b/node_modules/metro/src/DeltaBundler/Serializers/helpers/getTransitiveDependencies.js
index cb9e9d8..e308c0b 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/helpers/getTransitiveDependencies.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/getTransitiveDependencies.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/js.js b/node_modules/metro/src/DeltaBundler/Serializers/helpers/js.js
index 6308c02..d64896b 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/helpers/js.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/js.js
@@ -9,12 +9,13 @@
  */
 "use strict";
 
-const addParamsToDefineCall = require("../../../lib/addParamsToDefineCall");
-
 const invariant = require("invariant");
 
 const path = require("path");
 
+const _require = require("metro-transform-plugins"),
+  addParamsToDefineCall = _require.addParamsToDefineCall;
+
 function wrapModule(module, options) {
   const output = getJsOutput(module);
 
@@ -25,13 +26,14 @@ function wrapModule(module, options) {
   const moduleId = options.createModuleId(module.path);
   const params = [
     moduleId,
-    Array.from(module.dependencies.values()).map(dependency => {
-      return options.createModuleId(dependency.absolutePath);
-    })
-  ]; // Add the module relative path as the last parameter (to make it easier to do
-  // requires by name when debugging).
+    Array.from(module.dependencies.values()).map(dependency =>
+      options.createModuleId(dependency.absolutePath)
+    )
+  ];
 
   if (options.dev) {
+    // Add the relative path of the module to make debugging easier.
+    // This is mapped to `module.verboseName` in `require.js`.
     params.push(path.relative(options.projectRoot, module.path));
   }
 
@@ -45,16 +47,12 @@ function getJsOutput(module) {
   });
   invariant(
     jsModules.length === 1,
-    `Modules must have exactly one JS output, but ${module.path} has ${
-      jsModules.length
-    } JS outputs.`
+    `Modules must have exactly one JS output, but ${module.path} has ${jsModules.length} JS outputs.`
   );
   const jsOutput = jsModules[0];
   invariant(
     Number.isFinite(jsOutput.data.lineCount),
-    `JS output must populate lineCount, but ${module.path} has ${
-      jsOutput.type
-    } output with lineCount '${jsOutput.data.lineCount}'`
+    `JS output must populate lineCount, but ${module.path} has ${jsOutput.type} output with lineCount '${jsOutput.data.lineCount}'`
   );
   return jsOutput;
 }
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/js.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/helpers/js.js.flow
index 411cbaa..645ff50 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/helpers/js.js.flow
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/js.js.flow
@@ -10,17 +10,19 @@
 
 'use strict';
 
-const addParamsToDefineCall = require('../../../lib/addParamsToDefineCall');
 const invariant = require('invariant');
 const path = require('path');
 
-import type {JsOutput} from '../../../JSTransformer/worker';
-import type {MixedOutput, Module, Dependency} from '../../types.flow';
+const {addParamsToDefineCall} = require('metro-transform-plugins');
+
+import type {MixedOutput, Module} from '../../types.flow';
+import type {JsOutput} from 'metro-transform-worker';
 
 export type Options = {
   +createModuleId: string => number | string,
   +dev: boolean,
   +projectRoot: string,
+  ...
 };
 
 function wrapModule(module: Module<>, options: Options): string {
@@ -33,14 +35,14 @@ function wrapModule(module: Module<>, options: Options): string {
   const moduleId = options.createModuleId(module.path);
   const params = [
     moduleId,
-    Array.from(module.dependencies.values()).map((dependency: Dependency) => {
-      return options.createModuleId(dependency.absolutePath);
-    }),
+    Array.from(module.dependencies.values()).map(dependency =>
+      options.createModuleId(dependency.absolutePath),
+    ),
   ];
 
-  // Add the module relative path as the last parameter (to make it easier to do
-  // requires by name when debugging).
   if (options.dev) {
+    // Add the relative path of the module to make debugging easier.
+    // This is mapped to `module.verboseName` in `require.js`.
     params.push(path.relative(options.projectRoot, module.path));
   }
 
@@ -52,18 +54,14 @@ function getJsOutput(module: Module<>): JsOutput {
 
   invariant(
     jsModules.length === 1,
-    `Modules must have exactly one JS output, but ${module.path} has ${
-      jsModules.length
-    } JS outputs.`,
+    `Modules must have exactly one JS output, but ${module.path} has ${jsModules.length} JS outputs.`,
   );
 
   const jsOutput = (jsModules[0]: any);
 
   invariant(
     Number.isFinite(jsOutput.data.lineCount),
-    `JS output must populate lineCount, but ${module.path} has ${
-      jsOutput.type
-    } output with lineCount '${jsOutput.data.lineCount}'`,
+    `JS output must populate lineCount, but ${module.path} has ${jsOutput.type} output with lineCount '${jsOutput.data.lineCount}'`,
   );
 
   return jsOutput;
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/processBytecodeModules.js b/node_modules/metro/src/DeltaBundler/Serializers/helpers/processBytecodeModules.js
new file mode 100644
index 0000000..22800e2
--- /dev/null
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/processBytecodeModules.js
@@ -0,0 +1,77 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *
+ * @format
+ */
+"use strict";
+
+function _toConsumableArray(arr) {
+  return (
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
+  );
+}
+
+function _nonIterableSpread() {
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _iterableToArray(iter) {
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
+    return Array.from(iter);
+}
+
+function _arrayWithoutHoles(arr) {
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+const _require = require("./bytecode"),
+  isBytecodeModule = _require.isBytecodeModule,
+  wrapModule = _require.wrapModule;
+
+function processBytecodeModules(modules, _ref) {
+  let _ref$filter = _ref.filter,
+    filter = _ref$filter === void 0 ? () => true : _ref$filter,
+    createModuleId = _ref.createModuleId,
+    dev = _ref.dev,
+    projectRoot = _ref.projectRoot;
+  return _toConsumableArray(modules)
+    .filter(isBytecodeModule)
+    .filter(filter)
+    .map(module => [
+      module,
+      wrapModule(module, {
+        createModuleId,
+        dev,
+        projectRoot
+      })
+    ]);
+}
+
+module.exports = processBytecodeModules;
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/processBytecodeModules.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/helpers/processBytecodeModules.js.flow
new file mode 100644
index 0000000..ab5e891
--- /dev/null
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/processBytecodeModules.js.flow
@@ -0,0 +1,44 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ * @format
+ */
+
+'use strict';
+
+const {isBytecodeModule, wrapModule} = require('./bytecode');
+
+import type {Module} from '../../types.flow';
+
+function processBytecodeModules(
+  modules: $ReadOnlyArray<Module<>>,
+  {
+    filter = () => true,
+    createModuleId,
+    dev,
+    projectRoot,
+  }: {|
+    +filter?: (module: Module<>) => boolean,
+    +createModuleId: string => number,
+    +dev: boolean,
+    +projectRoot: string,
+  |},
+): $ReadOnlyArray<[Module<>, Array<Buffer>]> {
+  return [...modules]
+    .filter(isBytecodeModule)
+    .filter(filter)
+    .map((module: Module<>) => [
+      module,
+      wrapModule(module, {
+        createModuleId,
+        dev,
+        projectRoot,
+      }),
+    ]);
+}
+
+module.exports = processBytecodeModules;
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/processModules.js b/node_modules/metro/src/DeltaBundler/Serializers/helpers/processModules.js
index 390bbff..8b8d651 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/helpers/processModules.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/helpers/processModules.js
@@ -11,28 +11,44 @@
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 const _require = require("./js"),
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/serializeDeltaJSBundle.js b/node_modules/metro/src/DeltaBundler/Serializers/helpers/serializeDeltaJSBundle.js
deleted file mode 100644
index 440286b..0000000
--- a/node_modules/metro/src/DeltaBundler/Serializers/helpers/serializeDeltaJSBundle.js
+++ /dev/null
@@ -1,145 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-var _Buffer2;
-
-const crc32 = require("buffer-crc32");
-
-const _require = require("stream"),
-  Readable = _require.Readable;
-
-exports.toJSON = JSON.stringify; // binary streaming format for delta bundles:
-// FB DE 17 A5     magic number
-// uint24 format version (1)
-// bool base
-// uint32 revisionIdLength: length of revisionId
-// char[revisionIdLength] revisionId
-// if (base)
-//   uint32 preLength: length of "pre" section
-//   char[preLength] pre section
-//   char[4] pre section crc32
-//   uint32 postLength: length of "post" section
-//   char[postLength] post section
-//   char[4] post section crc32
-// module[], where module = {
-//   uint32 id
-//   uint32 length
-//   char[length] code
-//   char[4] code crc32
-// }
-
-exports.toBinaryStream = bundle => {
-  const gen = streamBundle(bundle);
-  return new Readable({
-    read() {
-      const _gen$next = gen.next(),
-        _gen$next$value = _gen$next.value,
-        value = _gen$next$value === void 0 ? null : _gen$next$value;
-
-      this.push(value);
-    }
-  });
-};
-
-const MAGIC_NUMBER = Buffer.of(0xfb, 0xde, 0x17, 0xa5);
-const FORMAT_VERSION = [0x01, 0x00, 0x00];
-
-function* streamBundle(bundle) {
-  var _Buffer;
-
-  yield MAGIC_NUMBER;
-  yield (_Buffer = Buffer).of.apply(
-    _Buffer,
-    FORMAT_VERSION.concat([bundle.base ? 1 : 0])
-  );
-  yield str(bundle.revisionId);
-
-  if (bundle.base) {
-    yield preOrPostSection(bundle.pre);
-    yield preOrPostSection(bundle.post);
-
-    for (const m of bundle.modules) {
-      yield _module(m);
-    }
-  } else {
-    for (const m of bundle.added) {
-      yield _module(m);
-    }
-
-    for (const m of bundle.modified) {
-      yield _module(m);
-    }
-
-    for (const id of bundle.deleted) {
-      yield _module([id, null]);
-    }
-  }
-}
-
-const SIZEOF_UINT32 = 4;
-
-function str(value) {
-  const size = Buffer.byteLength(value);
-  const buffer = Buffer.allocUnsafe(size + SIZEOF_UINT32);
-  buffer.writeUInt32LE(size, 0);
-  buffer.write(value, SIZEOF_UINT32, size, "utf8");
-  return buffer;
-}
-
-const ABSENT_VALUE = 0xffffffff;
-const ABSENT_BUFFER = [0xff, 0xff, 0xff, 0xff];
-const EMPTY_CRC32 = [0x00, 0x00, 0x00, 0x00];
-
-const EMPTY_PRE_OR_POST_SECTION = (_Buffer2 = Buffer).of.apply(
-  _Buffer2,
-  ABSENT_BUFFER.concat(EMPTY_CRC32)
-);
-
-function preOrPostSection(section) {
-  if (section.length === 0) {
-    return EMPTY_PRE_OR_POST_SECTION;
-  }
-
-  const size = Buffer.byteLength(section, "utf8");
-  const buffer = Buffer.allocUnsafe(size + SIZEOF_UINT32 * 2); // space for size and checksum
-
-  buffer.writeUInt32LE(size, 0);
-  buffer.write(section, SIZEOF_UINT32, size, "utf8");
-  appendCRC32(buffer);
-  return buffer;
-}
-
-function _module(idAndCode) {
-  const code = idAndCode[1];
-  let buffer, length;
-
-  if (code == null) {
-    length = ABSENT_VALUE;
-    buffer = Buffer.allocUnsafe(SIZEOF_UINT32 * 3); // id, length, crc32
-  } else {
-    length = Buffer.byteLength(code, "utf8");
-    buffer = Buffer.allocUnsafe(length + SIZEOF_UINT32 * 3);
-    buffer.write(code, SIZEOF_UINT32 * 2, length, "utf8");
-  }
-
-  buffer.writeUInt32LE(idAndCode[0], 0);
-  buffer.writeUInt32LE(length, SIZEOF_UINT32);
-  appendCRC32(buffer);
-  return buffer;
-}
-
-function appendCRC32(buffer) {
-  const CRC32_OFFSET = buffer.length - SIZEOF_UINT32;
-  buffer.writeUInt32LE(
-    crc32.unsigned(buffer.slice(0, CRC32_OFFSET)),
-    CRC32_OFFSET
-  );
-}
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/helpers/serializeDeltaJSBundle.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/helpers/serializeDeltaJSBundle.js.flow
deleted file mode 100644
index 234b6c6..0000000
--- a/node_modules/metro/src/DeltaBundler/Serializers/helpers/serializeDeltaJSBundle.js.flow
+++ /dev/null
@@ -1,136 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-const crc32 = (require('buffer-crc32'): {unsigned(Buffer): number});
-const {Readable} = require('stream');
-
-import type {BundleVariant} from '../../../lib/bundle-modules/types.flow';
-
-exports.toJSON = (JSON.stringify: BundleVariant => string);
-
-// binary streaming format for delta bundles:
-// FB DE 17 A5     magic number
-// uint24 format version (1)
-// bool base
-// uint32 revisionIdLength: length of revisionId
-// char[revisionIdLength] revisionId
-// if (base)
-//   uint32 preLength: length of "pre" section
-//   char[preLength] pre section
-//   char[4] pre section crc32
-//   uint32 postLength: length of "post" section
-//   char[postLength] post section
-//   char[4] post section crc32
-// module[], where module = {
-//   uint32 id
-//   uint32 length
-//   char[length] code
-//   char[4] code crc32
-// }
-
-exports.toBinaryStream = (bundle: BundleVariant): Readable => {
-  const gen = streamBundle(bundle);
-
-  return new Readable({
-    read() {
-      const {value = null} = gen.next();
-      this.push(value);
-    },
-  });
-};
-
-const MAGIC_NUMBER = Buffer.of(0xfb, 0xde, 0x17, 0xa5);
-const FORMAT_VERSION = [0x01, 0x00, 0x00];
-
-function* streamBundle(bundle: BundleVariant): Generator<Buffer, void, void> {
-  yield MAGIC_NUMBER;
-  yield Buffer.of(...FORMAT_VERSION, bundle.base ? 1 : 0);
-
-  yield str(bundle.revisionId);
-
-  if (bundle.base) {
-    yield preOrPostSection(bundle.pre);
-    yield preOrPostSection(bundle.post);
-
-    for (const m of bundle.modules) {
-      yield module(m);
-    }
-  } else {
-    for (const m of bundle.added) {
-      yield module(m);
-    }
-
-    for (const m of bundle.modified) {
-      yield module(m);
-    }
-
-    for (const id of bundle.deleted) {
-      yield module([id, null]);
-    }
-  }
-}
-
-const SIZEOF_UINT32 = 4;
-
-function str(value: string): Buffer {
-  const size = Buffer.byteLength(value);
-  const buffer = Buffer.allocUnsafe(size + SIZEOF_UINT32);
-  buffer.writeUInt32LE(size, 0);
-  buffer.write(value, SIZEOF_UINT32, size, 'utf8');
-  return buffer;
-}
-
-const ABSENT_VALUE = 0xffffffff;
-const ABSENT_BUFFER = [0xff, 0xff, 0xff, 0xff];
-const EMPTY_CRC32 = [0x00, 0x00, 0x00, 0x00];
-const EMPTY_PRE_OR_POST_SECTION = Buffer.of(...ABSENT_BUFFER, ...EMPTY_CRC32);
-
-function preOrPostSection(section: string): Buffer {
-  if (section.length === 0) {
-    return EMPTY_PRE_OR_POST_SECTION;
-  }
-
-  const size = Buffer.byteLength(section, 'utf8');
-
-  const buffer = Buffer.allocUnsafe(size + SIZEOF_UINT32 * 2); // space for size and checksum
-  buffer.writeUInt32LE(size, 0);
-  buffer.write(section, SIZEOF_UINT32, size, 'utf8');
-
-  appendCRC32(buffer);
-
-  return buffer;
-}
-
-function module(idAndCode: [number, string] | [number, null]): Buffer {
-  const code = idAndCode[1];
-  let buffer, length;
-  if (code == null) {
-    length = ABSENT_VALUE;
-    buffer = Buffer.allocUnsafe(SIZEOF_UINT32 * 3); // id, length, crc32
-  } else {
-    length = Buffer.byteLength(code, 'utf8');
-    buffer = Buffer.allocUnsafe(length + SIZEOF_UINT32 * 3);
-    buffer.write(code, SIZEOF_UINT32 * 2, length, 'utf8');
-  }
-  buffer.writeUInt32LE(idAndCode[0], 0);
-  buffer.writeUInt32LE(length, SIZEOF_UINT32);
-  appendCRC32(buffer);
-  return buffer;
-}
-
-function appendCRC32(buffer: Buffer): void {
-  const CRC32_OFFSET = buffer.length - SIZEOF_UINT32;
-  buffer.writeUInt32LE(
-    crc32.unsigned(buffer.slice(0, CRC32_OFFSET)),
-    CRC32_OFFSET,
-  );
-}
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/hmrJSBundle.js b/node_modules/metro/src/DeltaBundler/Serializers/hmrJSBundle.js
index f42d69e..b8955ca 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/hmrJSBundle.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/hmrJSBundle.js
@@ -4,52 +4,89 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
   }
+
+  return keys;
 }
 
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -64,11 +101,10 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
-const addParamsToDefineCall = require("../../lib/addParamsToDefineCall");
-
 const path = require("path");
 
 const url = require("url");
@@ -77,6 +113,9 @@ const _require = require("./helpers/js"),
   isJsModule = _require.isJsModule,
   wrapModule = _require.wrapModule;
 
+const _require2 = require("metro-transform-plugins"),
+  addParamsToDefineCall = _require2.addParamsToDefineCall;
+
 function generateModules(sourceModules, graph, options) {
   const modules = [];
 
@@ -116,9 +155,13 @@ function generateModules(sourceModules, graph, options) {
 function prepareModule(module, graph, options) {
   const code = wrapModule(
     module,
-    _objectSpread({}, options, {
-      dev: true
-    })
+    _objectSpread(
+      _objectSpread({}, options),
+      {},
+      {
+        dev: true
+      }
+    )
   );
   const inverseDependencies = getInverseDependencies(module.path, graph); // Transform the inverse dependency paths to ids.
 
@@ -139,9 +182,8 @@ function prepareModule(module, graph, options) {
 
 function getInverseDependencies(path, graph) {
   let inverseDependencies =
-    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
+    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Dependency alredy traversed.
 
-  // Dependency alredy traversed.
   if (path in inverseDependencies) {
     return inverseDependencies;
   }
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/hmrJSBundle.js.flow b/node_modules/metro/src/DeltaBundler/Serializers/hmrJSBundle.js.flow
index ccff809..bce6b6f 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/hmrJSBundle.js.flow
+++ b/node_modules/metro/src/DeltaBundler/Serializers/hmrJSBundle.js.flow
@@ -10,20 +10,21 @@
 
 'use strict';
 
-const addParamsToDefineCall = require('../../lib/addParamsToDefineCall');
 const path = require('path');
 const url = require('url');
 
 const {isJsModule, wrapModule} = require('./helpers/js');
+const {addParamsToDefineCall} = require('metro-transform-plugins');
 
 import type {EntryPointURL} from '../../HmrServer';
-import type {HmrModule} from '../../lib/bundle-modules/types.flow';
 import type {DeltaResult, Graph, Module} from '../types.flow';
+import type {HmrModule} from 'metro-runtime/src/modules/types.flow';
 
 type Options = {
   +clientUrl: EntryPointURL,
   +createModuleId: string => number,
   +projectRoot: string,
+  ...
 };
 
 function generateModules(
@@ -97,8 +98,8 @@ function prepareModule(
 function getInverseDependencies(
   path: string,
   graph: Graph<>,
-  inverseDependencies: {[key: string]: Array<string>} = {},
-): {[key: string]: Array<string>} {
+  inverseDependencies: {[key: string]: Array<string>, ...} = {},
+): {[key: string]: Array<string>, ...} {
   // Dependency alredy traversed.
   if (path in inverseDependencies) {
     return inverseDependencies;
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/sourceMapGenerator.js b/node_modules/metro/src/DeltaBundler/Serializers/sourceMapGenerator.js
index 7f796e7..9a5890b 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/sourceMapGenerator.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/sourceMapGenerator.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/sourceMapObject.js b/node_modules/metro/src/DeltaBundler/Serializers/sourceMapObject.js
index 6341bf5..9ed5c36 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/sourceMapObject.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/sourceMapObject.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
diff --git a/node_modules/metro/src/DeltaBundler/Serializers/sourceMapString.js b/node_modules/metro/src/DeltaBundler/Serializers/sourceMapString.js
index 1b24580..7711e40 100644
--- a/node_modules/metro/src/DeltaBundler/Serializers/sourceMapString.js
+++ b/node_modules/metro/src/DeltaBundler/Serializers/sourceMapString.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/DeltaBundler/Transformer.js b/node_modules/metro/src/DeltaBundler/Transformer.js
index f7f761b..0d7cec7 100644
--- a/node_modules/metro/src/DeltaBundler/Transformer.js
+++ b/node_modules/metro/src/DeltaBundler/Transformer.js
@@ -9,21 +9,42 @@
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,6 +59,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -49,6 +71,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -62,12 +85,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -75,10 +101,14 @@ function _asyncToGenerator(fn) {
 
 function _objectWithoutProperties(source, excluded) {
   if (source == null) return {};
+
   var target = _objectWithoutPropertiesLoose(source, excluded);
+
   var key, i;
+
   if (Object.getOwnPropertySymbols) {
     var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
+
     for (i = 0; i < sourceSymbolKeys.length; i++) {
       key = sourceSymbolKeys[i];
       if (excluded.indexOf(key) >= 0) continue;
@@ -86,6 +116,7 @@ function _objectWithoutProperties(source, excluded) {
       target[key] = source[key];
     }
   }
+
   return target;
 }
 
@@ -94,11 +125,13 @@ function _objectWithoutPropertiesLoose(source, excluded) {
   var target = {};
   var sourceKeys = Object.keys(source);
   var key, i;
+
   for (i = 0; i < sourceKeys.length; i++) {
     key = sourceKeys[i];
     if (excluded.indexOf(key) >= 0) continue;
     target[key] = source[key];
   }
+
   return target;
 }
 
@@ -108,7 +141,7 @@ const assert = require("assert");
 
 const fs = require("fs");
 
-const getTransformCacheKey = require("./Transformer/getTransformCacheKey");
+const getTransformCacheKey = require("./getTransformCacheKey");
 
 const path = require("path");
 
@@ -166,10 +199,14 @@ class Transformer {
         inlinePlatform = transformerOptions.inlinePlatform,
         inlineRequires = transformerOptions.inlineRequires,
         minify = transformerOptions.minify,
-        unstable_disableES6Transforms =
-          transformerOptions.unstable_disableES6Transforms,
+        nonInlinedRequires = transformerOptions.nonInlinedRequires,
         platform = transformerOptions.platform,
+        runtimeBytecodeVersion = transformerOptions.runtimeBytecodeVersion,
         type = transformerOptions.type,
+        unstable_disableES6Transforms =
+          transformerOptions.unstable_disableES6Transforms,
+        unstable_transformProfile =
+          transformerOptions.unstable_transformProfile,
         extra = _objectWithoutProperties(transformerOptions, [
           "customTransformOptions",
           "dev",
@@ -178,9 +215,12 @@ class Transformer {
           "inlinePlatform",
           "inlineRequires",
           "minify",
-          "unstable_disableES6Transforms",
+          "nonInlinedRequires",
           "platform",
-          "type"
+          "runtimeBytecodeVersion",
+          "type",
+          "unstable_disableES6Transforms",
+          "unstable_transformProfile"
         ]);
 
       for (const key in extra) {
@@ -203,9 +243,12 @@ class Transformer {
         inlinePlatform,
         inlineRequires,
         minify,
-        unstable_disableES6Transforms,
+        nonInlinedRequires,
         platform,
-        type
+        runtimeBytecodeVersion,
+        type,
+        unstable_disableES6Transforms,
+        unstable_transformProfile
       ]);
 
       const sha1 = _this._getSha1(filePath);
@@ -228,11 +271,15 @@ class Transformer {
       }
 
       cache.set(fullKey, data.result);
-      return _objectSpread({}, data.result, {
-        getSource() {
-          return fs.readFileSync(filePath);
+      return _objectSpread(
+        _objectSpread({}, data.result),
+        {},
+        {
+          getSource() {
+            return fs.readFileSync(filePath);
+          }
         }
-      });
+      );
     })();
   }
 
diff --git a/node_modules/metro/src/DeltaBundler/Transformer.js.flow b/node_modules/metro/src/DeltaBundler/Transformer.js.flow
index 1778f30..b8d21b0 100644
--- a/node_modules/metro/src/DeltaBundler/Transformer.js.flow
+++ b/node_modules/metro/src/DeltaBundler/Transformer.js.flow
@@ -14,7 +14,7 @@ const WorkerFarm = require('./WorkerFarm');
 
 const assert = require('assert');
 const fs = require('fs');
-const getTransformCacheKey = require('./Transformer/getTransformCacheKey');
+const getTransformCacheKey = require('./getTransformCacheKey');
 const path = require('path');
 
 const {Cache, stableHash} = require('metro-cache');
@@ -78,9 +78,12 @@ class Transformer {
       inlinePlatform,
       inlineRequires,
       minify,
-      unstable_disableES6Transforms,
+      nonInlinedRequires,
       platform,
+      runtimeBytecodeVersion,
       type,
+      unstable_disableES6Transforms,
+      unstable_transformProfile,
       ...extra
     } = transformerOptions;
 
@@ -108,9 +111,12 @@ class Transformer {
       inlinePlatform,
       inlineRequires,
       minify,
-      unstable_disableES6Transforms,
+      nonInlinedRequires,
       platform,
+      runtimeBytecodeVersion,
       type,
+      unstable_disableES6Transforms,
+      unstable_transformProfile,
     ]);
 
     const sha1 = this._getSha1(filePath);
diff --git a/node_modules/metro/src/DeltaBundler/Transformer/getTransformCacheKey.js b/node_modules/metro/src/DeltaBundler/Transformer/getTransformCacheKey.js
deleted file mode 100644
index 87769ca..0000000
--- a/node_modules/metro/src/DeltaBundler/Transformer/getTransformCacheKey.js
+++ /dev/null
@@ -1,55 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-const crypto = require("crypto");
-
-const getKeyFromFiles = require("../../lib/getKeyFromFiles");
-
-const path = require("path");
-
-const VERSION = require("../../../package.json").version;
-
-/**
- * Returns a function that will return the transform cache key based on some
- * passed transform options.
- */
-function getTransformCacheKey(opts) {
-  const _opts$transformerConf = opts.transformerConfig,
-    transformerPath = _opts$transformerConf.transformerPath,
-    transformerConfig = _opts$transformerConf.transformerConfig; // eslint-disable-next-line lint/flow-no-fixme
-
-  /* $FlowFixMe: dynamic requires prevent static typing :'(  */
-
-  const Transformer = require(transformerPath);
-
-  const transformerInstance = new Transformer(
-    opts.projectRoot,
-    transformerConfig
-  );
-  const transformerKey =
-    typeof transformerInstance.getCacheKey !== "undefined"
-      ? transformerInstance.getCacheKey()
-      : "";
-  const cacheKeyParts = [
-    "metro-cache",
-    VERSION,
-    opts.cacheVersion,
-    path.relative(path.join(__dirname, "../../../.."), opts.projectRoot),
-    getKeyFromFiles([require.resolve(transformerPath)]),
-    transformerKey
-  ];
-  return crypto
-    .createHash("sha1")
-    .update(cacheKeyParts.join("$"))
-    .digest("hex");
-}
-
-module.exports = getTransformCacheKey;
diff --git a/node_modules/metro/src/DeltaBundler/Transformer/getTransformCacheKey.js.flow b/node_modules/metro/src/DeltaBundler/Transformer/getTransformCacheKey.js.flow
deleted file mode 100644
index 17599ac..0000000
--- a/node_modules/metro/src/DeltaBundler/Transformer/getTransformCacheKey.js.flow
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-const crypto = require('crypto');
-const getKeyFromFiles = require('../../lib/getKeyFromFiles');
-const path = require('path');
-
-const VERSION = require('../../../package.json').version;
-
-import type {TransformerConfig} from '../Worker';
-
-/**
- * Returns a function that will return the transform cache key based on some
- * passed transform options.
- */
-function getTransformCacheKey(opts: {|
-  +cacheVersion: string,
-  +projectRoot: string,
-  +transformerConfig: TransformerConfig,
-|}): string {
-  const {transformerPath, transformerConfig} = opts.transformerConfig;
-
-  // eslint-disable-next-line lint/flow-no-fixme
-  /* $FlowFixMe: dynamic requires prevent static typing :'(  */
-  const Transformer = require(transformerPath);
-  const transformerInstance = new Transformer(
-    opts.projectRoot,
-    transformerConfig,
-  );
-
-  const transformerKey =
-    typeof transformerInstance.getCacheKey !== 'undefined'
-      ? transformerInstance.getCacheKey()
-      : '';
-
-  const cacheKeyParts = [
-    'metro-cache',
-    VERSION,
-    opts.cacheVersion,
-    path.relative(path.join(__dirname, '../../../..'), opts.projectRoot),
-    getKeyFromFiles([require.resolve(transformerPath)]),
-    transformerKey,
-  ];
-
-  return crypto
-    .createHash('sha1')
-    .update(cacheKeyParts.join('$'))
-    .digest('hex');
-}
-
-module.exports = getTransformCacheKey;
diff --git a/node_modules/metro/src/DeltaBundler/Worker.js b/node_modules/metro/src/DeltaBundler/Worker.js
index 4fbef0d..94cdaf4 100644
--- a/node_modules/metro/src/DeltaBundler/Worker.js
+++ b/node_modules/metro/src/DeltaBundler/Worker.js
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -47,34 +51,6 @@ const fs = require("fs");
 
 const path = require("path");
 
-const _require = require("metro-cache"),
-  stableHash = _require.stableHash;
-
-const transformers = {};
-
-function getTransformer(projectRoot, _ref) {
-  let transformerPath = _ref.transformerPath,
-    transformerConfig = _ref.transformerConfig;
-  const transformerKey = stableHash([
-    projectRoot,
-    transformerPath,
-    transformerConfig
-  ]).toString("hex");
-
-  if (transformers[transformerKey]) {
-    return transformers[transformerKey];
-  } // eslint-disable-next-line lint/flow-no-fixme
-  // $FlowFixMe Transforming fixed types to generic types during refactor.
-
-  const Transformer = require(transformerPath);
-
-  transformers[transformerKey] = new Transformer(
-    projectRoot,
-    transformerConfig
-  );
-  return transformers[transformerKey];
-}
-
 function transform(_x, _x2, _x3, _x4) {
   return _transform.apply(this, arguments);
 }
@@ -86,7 +62,9 @@ function _transform() {
     projectRoot,
     transformerConfig
   ) {
-    const transformer = getTransformer(projectRoot, transformerConfig);
+    // eslint-disable-next-line no-useless-call
+    const Transformer = require.call(null, transformerConfig.transformerPath);
+
     const transformFileStartLogEntry = {
       action_name: "Transforming file",
       action_phase: "start",
@@ -99,7 +77,9 @@ function _transform() {
       .createHash("sha1")
       .update(data)
       .digest("hex");
-    const result = yield transformer.transform(
+    const result = yield Transformer.transform(
+      transformerConfig.transformerConfig,
+      projectRoot,
       filename,
       data,
       transformOptions
diff --git a/node_modules/metro/src/DeltaBundler/Worker.js.flow b/node_modules/metro/src/DeltaBundler/Worker.js.flow
index 77505f0..624a38e 100644
--- a/node_modules/metro/src/DeltaBundler/Worker.js.flow
+++ b/node_modules/metro/src/DeltaBundler/Worker.js.flow
@@ -14,32 +14,33 @@ const crypto = require('crypto');
 const fs = require('fs');
 const path = require('path');
 
-const {stableHash} = require('metro-cache');
-
-import type Transformer, {
-  JsTransformOptions,
-  JsTransformerConfig,
-} from '../JSTransformer/worker';
 import type {TransformResult} from './types.flow';
 import type {LogEntry} from 'metro-core/src/Logger';
+import type {
+  JsTransformOptions,
+  JsTransformerConfig,
+} from 'metro-transform-worker';
 
-export type {
-  JsTransformOptions as TransformOptions,
-} from '../JSTransformer/worker';
+export type {JsTransformOptions as TransformOptions} from 'metro-transform-worker';
 
 export type Worker = {|
   +transform: typeof transform,
 |};
 
-export type TransformerFn = (
-  string,
-  Buffer,
-  JsTransformOptions,
-) => Promise<TransformResult<>>;
+type TransformerInterface = {
+  transform(
+    JsTransformerConfig,
+    string,
+    string,
+    Buffer,
+    JsTransformOptions,
+  ): Promise<TransformResult<>>,
+};
 
 export type TransformerConfig = {
   transformerPath: string,
   transformerConfig: JsTransformerConfig,
+  ...
 };
 
 type Data = $ReadOnly<{|
@@ -49,40 +50,17 @@ type Data = $ReadOnly<{|
   transformFileEndLogEntry: LogEntry,
 |}>;
 
-const transformers: {[string]: Transformer} = {};
-
-function getTransformer(
-  projectRoot: string,
-  {transformerPath, transformerConfig}: TransformerConfig,
-): Transformer {
-  const transformerKey = stableHash([
-    projectRoot,
-    transformerPath,
-    transformerConfig,
-  ]).toString('hex');
-
-  if (transformers[transformerKey]) {
-    return transformers[transformerKey];
-  }
-
-  // eslint-disable-next-line lint/flow-no-fixme
-  // $FlowFixMe Transforming fixed types to generic types during refactor.
-  const Transformer = require(transformerPath);
-  transformers[transformerKey] = new Transformer(
-    projectRoot,
-    transformerConfig,
-  );
-
-  return transformers[transformerKey];
-}
-
 async function transform(
   filename: string,
   transformOptions: JsTransformOptions,
   projectRoot: string,
   transformerConfig: TransformerConfig,
 ): Promise<Data> {
-  const transformer = getTransformer(projectRoot, transformerConfig);
+  // eslint-disable-next-line no-useless-call
+  const Transformer = (require.call(
+    null,
+    transformerConfig.transformerPath,
+  ): TransformerInterface);
 
   const transformFileStartLogEntry = {
     action_name: 'Transforming file',
@@ -98,7 +76,13 @@ async function transform(
     .update(data)
     .digest('hex');
 
-  const result = await transformer.transform(filename, data, transformOptions);
+  const result = await Transformer.transform(
+    transformerConfig.transformerConfig,
+    projectRoot,
+    filename,
+    data,
+    transformOptions,
+  );
 
   const transformFileEndLogEntry = getEndLogEntry(
     transformFileStartLogEntry,
@@ -126,6 +110,6 @@ function getEndLogEntry(startLogEntry: LogEntry, filename: string): LogEntry {
   };
 }
 
-((module.exports = {
+module.exports = ({
   transform,
-}): Worker);
+}: Worker);
diff --git a/node_modules/metro/src/DeltaBundler/WorkerFarm.js b/node_modules/metro/src/DeltaBundler/WorkerFarm.js
index 70efb1a..0c9eed8 100644
--- a/node_modules/metro/src/DeltaBundler/WorkerFarm.js
+++ b/node_modules/metro/src/DeltaBundler/WorkerFarm.js
@@ -9,21 +9,42 @@
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,6 +59,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -49,6 +71,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -62,19 +85,20 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
 }
 
-const chalk = require("chalk");
-
 const _require = require("metro-core"),
   Logger = _require.Logger;
 
@@ -106,28 +130,31 @@ class WorkerFarm {
       });
       this._worker = worker;
     } else {
-      // eslint-disable-next-line lint/flow-no-fixme
-      // $FlowFixMe: Flow doesn't support dynamic requires
-      this._worker = require(this._config.transformer.workerPath);
+      // eslint-disable-next-line no-useless-call
+      this._worker = require.call(null, this._config.transformer.workerPath);
     }
   }
 
   kill() {
-    if (this._worker && typeof this._worker.end === "function") {
-      this._worker.end();
-    }
+    var _this = this;
+
+    return _asyncToGenerator(function*() {
+      if (_this._worker && typeof _this._worker.end === "function") {
+        yield _this._worker.end();
+      }
+    })();
   }
 
   transform(filename, options) {
-    var _this = this;
+    var _this2 = this;
 
     return _asyncToGenerator(function*() {
       try {
-        const data = yield _this._worker.transform(
+        const data = yield _this2._worker.transform(
           filename,
           options,
-          _this._config.projectRoot,
-          _this._transformerConfig
+          _this2._config.projectRoot,
+          _this2._transformerConfig
         );
         Logger.log(data.transformFileStartLogEntry);
         Logger.log(data.transformFileEndLogEntry);
@@ -137,19 +164,23 @@ class WorkerFarm {
         };
       } catch (err) {
         if (err.loc) {
-          throw _this._formatBabelError(err, filename);
+          throw _this2._formatBabelError(err, filename);
         } else {
-          throw _this._formatGenericError(err, filename);
+          throw _this2._formatGenericError(err, filename);
         }
       }
     })();
   }
 
   _makeFarm(workerPath, exposedMethods, numWorkers) {
-    const env = _objectSpread({}, process.env, {
-      // Force color to print syntax highlighted code frames.
-      FORCE_COLOR: chalk.supportsColor ? 1 : 0
-    });
+    const env = _objectSpread(
+      _objectSpread({}, process.env),
+      {},
+      {
+        // Force color to print syntax highlighted code frames.
+        FORCE_COLOR: 1
+      }
+    );
 
     return new JestWorker(workerPath, {
       computeWorkerKey: this._config.stickyWorkers
@@ -190,7 +221,7 @@ class WorkerFarm {
       `${err.type || "Error"}${
         err.message.includes(filename) ? "" : " in " + filename
       }: ${err.message}`
-    ); // $FlowFixMe: extending an error.
+    ); // $FlowExpectedError: TODO(t67543470): Change this to properly extend the error.
 
     return Object.assign(error, {
       stack: err.stack,
diff --git a/node_modules/metro/src/DeltaBundler/WorkerFarm.js.flow b/node_modules/metro/src/DeltaBundler/WorkerFarm.js.flow
index 45f7023..cdb4bce 100644
--- a/node_modules/metro/src/DeltaBundler/WorkerFarm.js.flow
+++ b/node_modules/metro/src/DeltaBundler/WorkerFarm.js.flow
@@ -10,8 +10,6 @@
 
 'use strict';
 
-const chalk = require('chalk');
-
 const {Logger} = require('metro-core');
 const JestWorker = require('jest-worker').default;
 
@@ -63,15 +61,17 @@ class WorkerFarm {
 
       this._worker = worker;
     } else {
-      // eslint-disable-next-line lint/flow-no-fixme
-      // $FlowFixMe: Flow doesn't support dynamic requires
-      this._worker = require(this._config.transformer.workerPath);
+      // eslint-disable-next-line no-useless-call
+      this._worker = (require.call(
+        null,
+        this._config.transformer.workerPath,
+      ): Worker);
     }
   }
 
-  kill(): void {
+  async kill(): Promise<void> {
     if (this._worker && typeof this._worker.end === 'function') {
-      this._worker.end();
+      await this._worker.end();
     }
   }
 
@@ -111,7 +111,7 @@ class WorkerFarm {
     const env = {
       ...process.env,
       // Force color to print syntax highlighted code frames.
-      FORCE_COLOR: chalk.supportsColor ? 1 : 0,
+      FORCE_COLOR: 1,
     };
 
     return new JestWorker(workerPath, {
@@ -154,7 +154,7 @@ class WorkerFarm {
       }: ${err.message}`,
     );
 
-    // $FlowFixMe: extending an error.
+    // $FlowExpectedError: TODO(t67543470): Change this to properly extend the error.
     return Object.assign(error, {
       stack: err.stack,
       snippet: err.codeFrame,
diff --git a/node_modules/metro/src/DeltaBundler/computeDelta.js b/node_modules/metro/src/DeltaBundler/computeDelta.js
index 9bfb8c4..6f015ea 100644
--- a/node_modules/metro/src/DeltaBundler/computeDelta.js
+++ b/node_modules/metro/src/DeltaBundler/computeDelta.js
@@ -4,52 +4,76 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
 }
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -57,6 +81,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -69,6 +94,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
diff --git a/node_modules/metro/src/DeltaBundler/computeDelta.js.flow b/node_modules/metro/src/DeltaBundler/computeDelta.js.flow
index 6e402d8..fc846b6 100644
--- a/node_modules/metro/src/DeltaBundler/computeDelta.js.flow
+++ b/node_modules/metro/src/DeltaBundler/computeDelta.js.flow
@@ -10,7 +10,10 @@
 
 'use strict';
 
-import type {ModuleMap, DeltaBundle} from '../lib/bundle-modules/types.flow';
+import type {
+  ModuleMap,
+  DeltaBundle,
+} from 'metro-runtime/src/modules/types.flow';
 
 function computeDelta(entries1: ModuleMap, entries2: ModuleMap): DeltaBundle {
   const modules1 = new Map(entries1);
diff --git a/node_modules/metro/src/DeltaBundler/getTransformCacheKey.js b/node_modules/metro/src/DeltaBundler/getTransformCacheKey.js
new file mode 100644
index 0000000..16abc99
--- /dev/null
+++ b/node_modules/metro/src/DeltaBundler/getTransformCacheKey.js
@@ -0,0 +1,50 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *
+ * @format
+ */
+"use strict";
+
+const crypto = require("crypto");
+
+const getCacheKey = require("metro-cache-key");
+
+const path = require("path");
+
+const VERSION = require("../../package.json").version;
+/**
+ * Returns a function that will return the transform cache key based on some
+ * passed transform options.
+ */
+
+function getTransformCacheKey(opts) {
+  const _opts$transformerConf = opts.transformerConfig,
+    transformerPath = _opts$transformerConf.transformerPath,
+    transformerConfig = _opts$transformerConf.transformerConfig; // eslint-disable-next-line no-useless-call
+
+  const Transformer = require.call(null, transformerPath);
+
+  const transformerKey = Transformer.getCacheKey
+    ? Transformer.getCacheKey(transformerConfig)
+    : "";
+  return crypto
+    .createHash("sha1")
+    .update(
+      [
+        "metro-cache",
+        VERSION,
+        opts.cacheVersion,
+        path.relative(path.join(__dirname, "../../.."), opts.projectRoot),
+        getCacheKey([require.resolve(transformerPath)]),
+        transformerKey,
+        transformerConfig.globalPrefix
+      ].join("$")
+    )
+    .digest("hex");
+}
+
+module.exports = getTransformCacheKey;
diff --git a/node_modules/metro/src/DeltaBundler/getTransformCacheKey.js.flow b/node_modules/metro/src/DeltaBundler/getTransformCacheKey.js.flow
new file mode 100644
index 0000000..014261c
--- /dev/null
+++ b/node_modules/metro/src/DeltaBundler/getTransformCacheKey.js.flow
@@ -0,0 +1,58 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ * @format
+ */
+
+'use strict';
+
+const crypto = require('crypto');
+const getCacheKey = require('metro-cache-key');
+const path = require('path');
+
+const VERSION = require('../../package.json').version;
+
+import type {TransformerConfig} from './Worker';
+import type {JsTransformerConfig} from 'metro-transform-worker';
+
+type CacheKeyProvider = {
+  getCacheKey?: JsTransformerConfig => string,
+};
+/**
+ * Returns a function that will return the transform cache key based on some
+ * passed transform options.
+ */
+function getTransformCacheKey(opts: {|
+  +cacheVersion: string,
+  +projectRoot: string,
+  +transformerConfig: TransformerConfig,
+|}): string {
+  const {transformerPath, transformerConfig} = opts.transformerConfig;
+
+  // eslint-disable-next-line no-useless-call
+  const Transformer = (require.call(null, transformerPath): CacheKeyProvider);
+  const transformerKey = Transformer.getCacheKey
+    ? Transformer.getCacheKey(transformerConfig)
+    : '';
+
+  return crypto
+    .createHash('sha1')
+    .update(
+      [
+        'metro-cache',
+        VERSION,
+        opts.cacheVersion,
+        path.relative(path.join(__dirname, '../../..'), opts.projectRoot),
+        getCacheKey([require.resolve(transformerPath)]),
+        transformerKey,
+        transformerConfig.globalPrefix,
+      ].join('$'),
+    )
+    .digest('hex');
+}
+
+module.exports = getTransformCacheKey;
diff --git a/node_modules/metro/src/DeltaBundler/mergeDeltas.js b/node_modules/metro/src/DeltaBundler/mergeDeltas.js
index 4f1c50c..cc8d903 100644
--- a/node_modules/metro/src/DeltaBundler/mergeDeltas.js
+++ b/node_modules/metro/src/DeltaBundler/mergeDeltas.js
@@ -4,52 +4,76 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
 }
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -57,6 +81,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -69,6 +94,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
diff --git a/node_modules/metro/src/DeltaBundler/mergeDeltas.js.flow b/node_modules/metro/src/DeltaBundler/mergeDeltas.js.flow
index 3b6a3fb..a3882ac 100644
--- a/node_modules/metro/src/DeltaBundler/mergeDeltas.js.flow
+++ b/node_modules/metro/src/DeltaBundler/mergeDeltas.js.flow
@@ -10,7 +10,7 @@
 
 'use strict';
 
-import type {DeltaBundle} from '../lib/bundle-modules/types.flow';
+import type {DeltaBundle} from 'metro-runtime/src/modules/types.flow';
 
 function mergeDeltas(delta1: DeltaBundle, delta2: DeltaBundle): DeltaBundle {
   const added1 = new Map(delta1.added);
diff --git a/node_modules/metro/src/DeltaBundler/traverseDependencies.js b/node_modules/metro/src/DeltaBundler/traverseDependencies.js
index 99e4dd2..faee583 100644
--- a/node_modules/metro/src/DeltaBundler/traverseDependencies.js
+++ b/node_modules/metro/src/DeltaBundler/traverseDependencies.js
@@ -4,26 +4,52 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -31,6 +57,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -43,6 +70,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
@@ -50,21 +78,42 @@ function _arrayWithHoles(arr) {
   if (Array.isArray(arr)) return arr;
 }
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -79,6 +128,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -90,6 +140,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -103,12 +154,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -283,11 +337,15 @@ function _processModule() {
     };
     const previousDependencies = previousModule.dependencies || new Map(); // Update the module information.
 
-    const module = _objectSpread({}, previousModule, {
-      dependencies: new Map(),
-      getSource: result.getSource,
-      output: result.output
-    });
+    const module = _objectSpread(
+      _objectSpread({}, previousModule),
+      {},
+      {
+        dependencies: new Map(),
+        getSource: result.getSource,
+        output: result.output
+      }
+    );
 
     graph.dependencies.set(module.path, module);
 
@@ -299,34 +357,53 @@ function _processModule() {
       module.dependencies.set(relativePath, dependency);
     }
 
-    for (const _ref4 of previousDependencies) {
-      var _ref5 = _slicedToArray(_ref4, 2);
-
-      const relativePath = _ref5[0];
-      const dependency = _ref5[1];
+    Array.from(previousDependencies.entries())
+      .filter(_ref4 => {
+        let _ref5 = _slicedToArray(_ref4, 2),
+          relativePath = _ref5[0],
+          dependency = _ref5[1];
 
-      if (!currentDependencies.has(relativePath)) {
-        removeDependency(module, dependency.absolutePath, graph, delta);
-      }
-    } // Check all the module dependencies and start traversing the tree from each
+        return (
+          !currentDependencies.has(relativePath) ||
+          nullthrows(currentDependencies.get(relativePath)).absolutePath !==
+            dependency.absolutePath
+        );
+      })
+      .forEach(_ref6 => {
+        let _ref7 = _slicedToArray(_ref6, 2),
+          relativePath = _ref7[0],
+          dependency = _ref7[1];
+
+        return removeDependency(
+          module,
+          dependency.absolutePath,
+          graph,
+          delta,
+          new Set()
+        );
+      }); // Check all the module dependencies and start traversing the tree from each
     // added and removed dependency, to get all the modules that have to be added
     // and removed from the dependency graph.
 
     const promises = [];
 
-    for (const _ref6 of currentDependencies) {
-      var _ref7 = _slicedToArray(_ref6, 2);
+    for (const _ref8 of currentDependencies) {
+      var _ref9 = _slicedToArray(_ref8, 2);
 
-      const relativePath = _ref7[0];
-      const dependency = _ref7[1];
+      const relativePath = _ref9[0];
+      const dependency = _ref9[1];
 
       if (!options.shallow) {
         if (
           options.experimentalImportBundleSupport &&
-          dependency.data.data.isAsync
+          dependency.data.data.asyncType != null
         ) {
           graph.importBundleNames.add(dependency.absolutePath);
-        } else if (!previousDependencies.has(relativePath)) {
+        } else if (
+          !previousDependencies.has(relativePath) ||
+          nullthrows(previousDependencies.get(relativePath)).absolutePath !==
+            dependency.absolutePath
+        ) {
           promises.push(
             addDependency(
               module,
@@ -357,6 +434,11 @@ function _processModule() {
 function addDependency(_x14, _x15, _x16, _x17, _x18) {
   return _addDependency.apply(this, arguments);
 }
+/**
+ * Recursively look up `inverseDependencies` until it is empty,
+ * returning a set of paths for the last module that does not have
+ * `inverseDependencies`.
+ */
 
 function _addDependency() {
   _addDependency = _asyncToGenerator(function*(
@@ -393,42 +475,182 @@ function _addDependency() {
   return _addDependency.apply(this, arguments);
 }
 
+function getAllTopLevelInverseDependencies(
+  inverseDependencies,
+  graph,
+  currModule,
+  visited
+) {
+  if (visited.has(currModule)) {
+    return new Set();
+  }
+
+  visited.add(currModule);
+
+  if (!inverseDependencies.size) {
+    return new Set([currModule]);
+  }
+
+  return Array.from(inverseDependencies)
+    .filter(inverseDep => graph.dependencies.has(inverseDep))
+    .reduce((acc, inverseDep) => {
+      const mod = graph.dependencies.get(inverseDep);
+
+      if (!mod) {
+        return acc;
+      }
+
+      getAllTopLevelInverseDependencies(
+        mod.inverseDependencies,
+        graph,
+        inverseDep,
+        visited
+      ).forEach(x => {
+        acc.add(x);
+      });
+      return acc;
+    }, new Set());
+}
+/**
+ * Given `inverseDependencies`, tracing back inverse dependencies to
+ * see if it only leads back to `parentModule`.
+ */
+
+function canSafelyRemoveFromParentModule(
+  inverseDependencies,
+  parentModule,
+  graph,
+  canBeRemovedSafely,
+  delta
+) {
+  const visited = new Set();
+  const topInverseDependencies = getAllTopLevelInverseDependencies(
+    inverseDependencies,
+    graph,
+    "", // current module name
+    visited
+  );
+
+  if (!topInverseDependencies.size) {
+    /**
+     * This happens when parentModule and inverseDependencies have a circular dependency.
+     * This will eventually become an empty set due to the `visited` Set being the
+     * base case for the recursive call.
+     */
+    return true;
+  }
+
+  const undeletedInverseDependencies = Array.from(
+    topInverseDependencies
+  ).filter(x => !delta.deleted.has(x));
+  /**
+   * We can only mark the `visited` Set of modules to be safely removable if
+   * 1. We do not have top a level module to compare with parentModule.
+   *   This can happen when trying to see if we can safely remove from
+   *   a module that was deleted. This is why we filtered them out with `delta.deleted`
+   * 2. We have one top module and it is parentModule
+   */
+
+  const canSafelyRemove =
+    !undeletedInverseDependencies.length ||
+    (undeletedInverseDependencies.length === 1 &&
+      undeletedInverseDependencies[0] === parentModule);
+
+  if (canSafelyRemove) {
+    visited.forEach(mod => {
+      canBeRemovedSafely.add(mod);
+    });
+  }
+
+  return canSafelyRemove;
+}
+
 function removeDependency(parentModule, absolutePath, graph, delta) {
+  let canBeRemovedSafely =
+    arguments.length > 4 && arguments[4] !== undefined
+      ? arguments[4]
+      : new Set();
   const module = graph.dependencies.get(absolutePath);
 
   if (!module) {
     return;
   }
 
-  module.inverseDependencies.delete(parentModule.path); // This module is still used by another modules, so we cannot remove it from
-  // the bundle.
-
-  if (module.inverseDependencies.size) {
-    return;
+  module.inverseDependencies.delete(parentModule.path); // Even if there are modules still using parentModule, we want to ensure
+  // there is no circular dependency. Thus, we check if it can be safely removed
+  // by tracing back the inverseDependencies.
+
+  if (!canBeRemovedSafely.has(module.path)) {
+    if (
+      module.inverseDependencies.size &&
+      !canSafelyRemoveFromParentModule(
+        module.inverseDependencies,
+        module.path,
+        graph,
+        canBeRemovedSafely,
+        delta
+      )
+    ) {
+      return;
+    }
   }
 
   delta.deleted.add(module.path); // Now we need to iterate through the module dependencies in order to
   // clean up everything (we cannot read the module because it may have
   // been deleted).
 
-  for (const dependency of module.dependencies.values()) {
-    removeDependency(module, dependency.absolutePath, graph, delta);
-  } // This module is not used anywhere else!! we can clear it from the bundle
+  Array.from(module.dependencies.values())
+    .filter(
+      dependency =>
+        !delta.deleted.has(dependency.absolutePath) &&
+        dependency.absolutePath !== parentModule.path
+    )
+    .forEach(dependency =>
+      removeDependency(
+        module,
+        dependency.absolutePath,
+        graph,
+        delta,
+        canBeRemovedSafely
+      )
+    ); // This module is not used anywhere else!! we can clear it from the bundle
 
   graph.dependencies.delete(module.path);
 }
 
 function resolveDependencies(parentPath, dependencies, options) {
-  return new Map(
-    dependencies.map(result => {
-      const relativePath = result.name;
-      const dependency = {
-        absolutePath: options.resolve(parentPath, result.name),
-        data: result
-      };
-      return [relativePath, dependency];
-    })
-  );
+  const resolve = (parentPath, result) => {
+    const relativePath = result.name;
+
+    try {
+      return [
+        relativePath,
+        {
+          absolutePath: options.resolve(parentPath, relativePath),
+          data: result
+        }
+      ];
+    } catch (error) {
+      // Ignore unavailable optional dependencies. They are guarded
+      // with a try-catch block and will be handled during runtime.
+      if (result.data.isOptional !== true) {
+        throw error;
+      }
+    }
+
+    return undefined;
+  };
+
+  const resolved = dependencies.reduce((list, result) => {
+    const resolvedPath = resolve(parentPath, result);
+
+    if (resolvedPath) {
+      list.push(resolvedPath);
+    }
+
+    return list;
+  }, []);
+  return new Map(resolved);
 }
 /**
  * Re-traverse the dependency graph in DFS order to reorder the modules and
@@ -463,7 +685,7 @@ function reorderDependencies(graph, module, orderedDependencies, options) {
     const childModule = graph.dependencies.get(path);
 
     if (!childModule) {
-      if (dependency.data.data.isAsync || options.shallow) {
+      if (dependency.data.data.asyncType != null || options.shallow) {
         return;
       } else {
         throw new ReferenceError("Module not registered in graph: " + path);
diff --git a/node_modules/metro/src/DeltaBundler/traverseDependencies.js.flow b/node_modules/metro/src/DeltaBundler/traverseDependencies.js.flow
index a4afc76..69ab4bf 100644
--- a/node_modules/metro/src/DeltaBundler/traverseDependencies.js.flow
+++ b/node_modules/metro/src/DeltaBundler/traverseDependencies.js.flow
@@ -24,6 +24,7 @@ type Result<T> = {
   added: Map<string, Module<T>>,
   modified: Map<string, Module<T>>,
   deleted: Set<string>,
+  ...
 };
 
 /**
@@ -225,11 +226,22 @@ async function processModule<T>(
     module.dependencies.set(relativePath, dependency);
   }
 
-  for (const [relativePath, dependency] of previousDependencies) {
-    if (!currentDependencies.has(relativePath)) {
-      removeDependency(module, dependency.absolutePath, graph, delta);
-    }
-  }
+  Array.from(previousDependencies.entries())
+    .filter(
+      ([relativePath, dependency]) =>
+        !currentDependencies.has(relativePath) ||
+        nullthrows(currentDependencies.get(relativePath)).absolutePath !==
+          dependency.absolutePath,
+    )
+    .forEach(([relativePath, dependency]) =>
+      removeDependency(
+        module,
+        dependency.absolutePath,
+        graph,
+        delta,
+        new Set(),
+      ),
+    );
 
   // Check all the module dependencies and start traversing the tree from each
   // added and removed dependency, to get all the modules that have to be added
@@ -240,10 +252,14 @@ async function processModule<T>(
     if (!options.shallow) {
       if (
         options.experimentalImportBundleSupport &&
-        dependency.data.data.isAsync
+        dependency.data.data.asyncType != null
       ) {
         graph.importBundleNames.add(dependency.absolutePath);
-      } else if (!previousDependencies.has(relativePath)) {
+      } else if (
+        !previousDependencies.has(relativePath) ||
+        nullthrows(previousDependencies.get(relativePath)).absolutePath !==
+          dependency.absolutePath
+      ) {
         promises.push(
           addDependency(module, dependency.absolutePath, graph, delta, options),
         );
@@ -300,11 +316,105 @@ async function addDependency<T>(
   options.onDependencyAdded();
 }
 
+/**
+ * Recursively look up `inverseDependencies` until it is empty,
+ * returning a set of paths for the last module that does not have
+ * `inverseDependencies`.
+ */
+function getAllTopLevelInverseDependencies<T>(
+  inverseDependencies: Set<string>,
+  graph: Graph<T>,
+  currModule: string,
+  visited: Set<string>,
+): Set<string> {
+  if (visited.has(currModule)) {
+    return new Set();
+  }
+  visited.add(currModule);
+  if (!inverseDependencies.size) {
+    return new Set([currModule]);
+  }
+
+  return Array.from(inverseDependencies)
+    .filter(inverseDep => graph.dependencies.has(inverseDep))
+    .reduce((acc, inverseDep) => {
+      const mod = graph.dependencies.get(inverseDep);
+      if (!mod) {
+        return acc;
+      }
+      getAllTopLevelInverseDependencies(
+        mod.inverseDependencies,
+        graph,
+        inverseDep,
+        visited,
+      ).forEach(x => {
+        acc.add(x);
+      });
+      return acc;
+    }, new Set());
+}
+
+/**
+ * Given `inverseDependencies`, tracing back inverse dependencies to
+ * see if it only leads back to `parentModule`.
+ */
+function canSafelyRemoveFromParentModule<T>(
+  inverseDependencies: Set<string>,
+  parentModule: string,
+  graph: Graph<T>,
+  canBeRemovedSafely: Set<string>,
+  delta: Delta,
+): boolean {
+  const visited = new Set();
+  const topInverseDependencies = getAllTopLevelInverseDependencies(
+    inverseDependencies,
+    graph,
+    '', // current module name
+    visited,
+  );
+
+  if (!topInverseDependencies.size) {
+    /**
+     * This happens when parentModule and inverseDependencies have a circular dependency.
+     * This will eventually become an empty set due to the `visited` Set being the
+     * base case for the recursive call.
+     */
+    return true;
+  }
+
+  const undeletedInverseDependencies = Array.from(
+    topInverseDependencies,
+  ).filter(x => !delta.deleted.has(x));
+
+  /**
+   * We can only mark the `visited` Set of modules to be safely removable if
+   * 1. We do not have top a level module to compare with parentModule.
+   *   This can happen when trying to see if we can safely remove from
+   *   a module that was deleted. This is why we filtered them out with `delta.deleted`
+   * 2. We have one top module and it is parentModule
+   */
+  const canSafelyRemove =
+    !undeletedInverseDependencies.length ||
+    (undeletedInverseDependencies.length === 1 &&
+      undeletedInverseDependencies[0] === parentModule);
+
+  if (canSafelyRemove) {
+    visited.forEach(mod => {
+      canBeRemovedSafely.add(mod);
+    });
+  }
+  return canSafelyRemove;
+}
+
 function removeDependency<T>(
   parentModule: Module<T>,
   absolutePath: string,
   graph: Graph<T>,
   delta: Delta,
+  // We use `canBeRemovedSafely` set to keep track of visited
+  // module(s) that we're sure can be removed. This will skip expensive
+  // inverse dependency traversals.
+  canBeRemovedSafely: Set<string> = new Set(),
 ): void {
   const module = graph.dependencies.get(absolutePath);
 
@@ -314,10 +424,22 @@ function removeDependency<T>(
 
   module.inverseDependencies.delete(parentModule.path);
 
-  // This module is still used by another modules, so we cannot remove it from
-  // the bundle.
-  if (module.inverseDependencies.size) {
-    return;
+  // Even if there are modules still using parentModule, we want to ensure
+  // there is no circular dependency. Thus, we check if it can be safely removed
+  // by tracing back the inverseDependencies.
+  if (!canBeRemovedSafely.has(module.path)) {
+    if (
+      module.inverseDependencies.size &&
+      !canSafelyRemoveFromParentModule(
+        module.inverseDependencies,
+        module.path,
+        graph,
+        canBeRemovedSafely,
+        delta,
+      )
+    ) {
+      return;
+    }
   }
 
   delta.deleted.add(module.path);
@@ -325,10 +447,21 @@ function removeDependency<T>(
   // Now we need to iterate through the module dependencies in order to
   // clean up everything (we cannot read the module because it may have
   // been deleted).
-  for (const dependency of module.dependencies.values()) {
-    removeDependency(module, dependency.absolutePath, graph, delta);
-  }
-
+  Array.from(module.dependencies.values())
+    .filter(
+      dependency =>
+        !delta.deleted.has(dependency.absolutePath) &&
+        dependency.absolutePath !== parentModule.path,
+    )
+    .forEach(dependency =>
+      removeDependency(
+        module,
+        dependency.absolutePath,
+        graph,
+        delta,
+        canBeRemovedSafely,
+      ),
+    );
   // This module is not used anywhere else!! we can clear it from the bundle
   graph.dependencies.delete(module.path);
 }
@@ -338,25 +471,47 @@ function resolveDependencies<T>(
   dependencies: $ReadOnlyArray<TransformResultDependency>,
   options: InternalOptions<T>,
 ): Map<string, Dependency> {
-  return new Map(
-    dependencies.map((result: TransformResultDependency) => {
-      const relativePath = result.name;
-
-      const dependency = {
-        absolutePath: options.resolve(parentPath, result.name),
-        data: result,
-      };
+  const resolve = (parentPath: string, result: TransformResultDependency) => {
+    const relativePath = result.name;
+    try {
+      return [
+        relativePath,
+        {
+          absolutePath: options.resolve(parentPath, relativePath),
+          data: result,
+        },
+      ];
+    } catch (error) {
+      // Ignore unavailable optional dependencies. They are guarded
+      // with a try-catch block and will be handled during runtime.
+      if (result.data.isOptional !== true) {
+        throw error;
+      }
+    }
+    return undefined;
+  };
 
-      return [relativePath, dependency];
-    }),
+  const resolved = dependencies.reduce(
+    (list: Array<[string, Dependency]>, result: TransformResultDependency) => {
+      const resolvedPath = resolve(parentPath, result);
+      if (resolvedPath) {
+        list.push(resolvedPath);
+      }
+      return list;
+    },
+    [],
   );
+  return new Map(resolved);
 }
 
 /**
  * Re-traverse the dependency graph in DFS order to reorder the modules and
  * guarantee the same order between runs. This method mutates the passed graph.
  */
-function reorderGraph<T>(graph: Graph<T>, options: {shallow: boolean}): void {
+function reorderGraph<T>(
+  graph: Graph<T>,
+  options: {shallow: boolean, ...},
+): void {
   const orderedDependencies = new Map();
 
   graph.entryPoints.forEach((entryPoint: string) => {
@@ -376,9 +531,7 @@ function reorderDependencies<T>(
   graph: Graph<T>,
   module: Module<T>,
   orderedDependencies: Map<string, Module<T>>,
-  options: {
-    shallow: boolean,
-  },
+  options: {shallow: boolean, ...},
 ): void {
   if (module.path) {
     if (orderedDependencies.has(module.path)) {
@@ -393,7 +546,7 @@ function reorderDependencies<T>(
     const childModule = graph.dependencies.get(path);
 
     if (!childModule) {
-      if (dependency.data.data.isAsync || options.shallow) {
+      if (dependency.data.data.asyncType != null || options.shallow) {
         return;
       } else {
         throw new ReferenceError('Module not registered in graph: ' + path);
diff --git a/node_modules/metro/src/DeltaBundler/types.flow.js b/node_modules/metro/src/DeltaBundler/types.flow.js
index 7c6bffd..7e72086 100644
--- a/node_modules/metro/src/DeltaBundler/types.flow.js
+++ b/node_modules/metro/src/DeltaBundler/types.flow.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/DeltaBundler/types.flow.js.flow b/node_modules/metro/src/DeltaBundler/types.flow.js.flow
index a9dc228..da1f7ac 100644
--- a/node_modules/metro/src/DeltaBundler/types.flow.js.flow
+++ b/node_modules/metro/src/DeltaBundler/types.flow.js.flow
@@ -15,6 +15,8 @@ export type MixedOutput = {|
   +type: string,
 |};
 
+export type AsyncDependencyType = 'async' | 'prefetch';
+
 export type TransformResultDependency = {|
   /**
    * The literal name provided to a require or import call. For example 'foo' in
@@ -28,14 +30,21 @@ export type TransformResultDependency = {|
    */
   +data: {|
     /**
-     * If `true` this dependency is due to a dynamic `import()` call. If `false`,
-     * this dependency was pulled using a synchronous `require()` call.
+     * If not null, this dependency is due to a dynamic `import()` or `__prefetchImport()` call.
+     */
+    +asyncType: AsyncDependencyType | null,
+    /**
+     * The condition for splitting on this dependency edge.
      */
-    +isAsync: boolean,
+    +splitCondition?: {|
+      +mobileConfigName: string,
+    |},
     /**
-     * The dependency is actually a `__prefetchImport()` call.
+     * The dependency is enclosed in a try/catch block.
      */
-    +isPrefetchOnly?: true,
+    +isOptional?: boolean,
+
+    +locs: $ReadOnlyArray<BabelSourceLocation>,
   |},
 |};
 
@@ -52,8 +61,10 @@ export type Module<T = MixedOutput> = {|
   +getSource: () => Buffer,
 |};
 
+export type Dependencies<T = MixedOutput> = Map<string, Module<T>>;
+
 export type Graph<T = MixedOutput> = {|
-  dependencies: Map<string, Module<T>>,
+  dependencies: Dependencies<T>,
   importBundleNames: Set<string>,
   +entryPoints: $ReadOnlyArray<string>,
 |};
@@ -71,6 +82,12 @@ export type TransformResultWithSource<T = MixedOutput> = $ReadOnly<{|
 export type TransformFn<T = MixedOutput> = string => Promise<
   TransformResultWithSource<T>,
 >;
+export type AllowOptionalDependenciesWithOptions = {|
+  +exclude: Array<string>,
+|};
+export type AllowOptionalDependencies =
+  | boolean
+  | AllowOptionalDependenciesWithOptions;
 
 export type Options<T = MixedOutput> = {|
   +resolve: (from: string, to: string) => string,
diff --git a/node_modules/metro/src/HmrServer.js b/node_modules/metro/src/HmrServer.js
index a341a51..9e022b9 100644
--- a/node_modules/metro/src/HmrServer.js
+++ b/node_modules/metro/src/HmrServer.js
@@ -9,21 +9,84 @@
  */
 "use strict";
 
+function _toConsumableArray(arr) {
+  return (
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
+  );
+}
+
+function _nonIterableSpread() {
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _iterableToArray(iter) {
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
+    return Array.from(iter);
+}
+
+function _arrayWithoutHoles(arr) {
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,33 +101,44 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
-function _toConsumableArray(arr) {
-  return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
-  );
-}
+function _objectWithoutProperties(source, excluded) {
+  if (source == null) return {};
 
-function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
-}
+  var target = _objectWithoutPropertiesLoose(source, excluded);
 
-function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
-    return Array.from(iter);
+  var key, i;
+
+  if (Object.getOwnPropertySymbols) {
+    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
+
+    for (i = 0; i < sourceSymbolKeys.length; i++) {
+      key = sourceSymbolKeys[i];
+      if (excluded.indexOf(key) >= 0) continue;
+      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
+      target[key] = source[key];
+    }
+  }
+
+  return target;
 }
 
-function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
+function _objectWithoutPropertiesLoose(source, excluded) {
+  if (source == null) return {};
+  var target = {};
+  var sourceKeys = Object.keys(source);
+  var key, i;
+
+  for (i = 0; i < sourceKeys.length; i++) {
+    key = sourceKeys[i];
+    if (excluded.indexOf(key) >= 0) continue;
+    target[key] = source[key];
   }
+
+  return target;
 }
 
 function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
@@ -75,6 +149,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -88,12 +163,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -113,8 +191,6 @@ const getGraphId = require("./lib/getGraphId");
 
 const hmrJSBundle = require("./DeltaBundler/Serializers/hmrJSBundle");
 
-const logToConsole = require("./lib/logToConsole");
-
 const nullthrows = require("nullthrows");
 
 const parseOptionsFromUrl = require("./lib/parseOptionsFromUrl");
@@ -131,6 +207,9 @@ const _require = require("metro-core"),
   createActionEndEntry = _require$Logger.createActionEndEntry,
   log = _require$Logger.log;
 
+const _require2 = require("metro-hermes-compiler"),
+  BYTECODE_VERSION = _require2.VERSION;
+
 function send(sendFns, message) {
   const strMessage = JSON.stringify(message);
   sendFns.forEach(sendFn => sendFn(strMessage));
@@ -167,66 +246,50 @@ class HmrServer {
     var _this = this;
 
     return _asyncToGenerator(function*() {
+      requestUrl = _this._config.server.rewriteRequestUrl(requestUrl);
       const clientUrl = nullthrows(url.parse(requestUrl, true));
-      const query = nullthrows(clientUrl.query);
-      let revPromise;
+      const options = parseOptionsFromUrl(
+        requestUrl,
+        new Set(_this._config.resolver.platforms),
+        BYTECODE_VERSION
+      );
 
-      if (query.revisionId) {
-        const revisionId = query.revisionId;
-        revPromise = _this._bundler.getRevision(revisionId);
+      const _splitBundleOptions = splitBundleOptions(options),
+        entryFile = _splitBundleOptions.entryFile,
+        transformOptions = _splitBundleOptions.transformOptions,
+        graphOptions = _splitBundleOptions.graphOptions;
+      /**
+       * `entryFile` is relative to projectRoot, we need to use resolution function
+       * to find the appropriate file with supported extensions.
+       */
+
+      const resolutionFn = yield transformHelpers.getResolveDependencyFn(
+        _this._bundler.getBundler(),
+        transformOptions.platform
+      );
+      const resolvedEntryFilePath = resolutionFn(
+        _this._config.projectRoot + "/.",
+        entryFile
+      );
+      const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {
+        shallow: graphOptions.shallow,
+        experimentalImportBundleSupport:
+          _this._config.transformer.experimentalImportBundleSupport
+      });
 
-        if (!revPromise) {
-          send([sendFn], {
-            type: "error",
-            body: formatBundlingError(new RevisionNotFoundError(revisionId))
-          });
-          return;
-        }
-      } else if (query.bundleEntry != null) {
-        const _parseOptionsFromUrl = parseOptionsFromUrl(
-            requestUrl,
-            new Set(_this._config.resolver.platforms)
-          ),
-          options = _parseOptionsFromUrl.options;
-
-        const _splitBundleOptions = splitBundleOptions(options),
-          entryFile = _splitBundleOptions.entryFile,
-          transformOptions = _splitBundleOptions.transformOptions,
-          graphOptions = _splitBundleOptions.graphOptions;
-        /**
-         * `entryFile` is relative to projectRoot, we need to use resolution function
-         * to find the appropriate file with supported extensions.
-         */
-
-        const resolutionFn = yield transformHelpers.getResolveDependencyFn(
-          _this._bundler.getBundler(),
-          transformOptions.platform
-        );
-        const resolvedEntryFilePath = resolutionFn(
-          _this._config.projectRoot + "/.",
-          entryFile
-        );
-        const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {
-          shallow: graphOptions.shallow,
-          experimentalImportBundleSupport:
-            _this._config.transformer.experimentalImportBundleSupport
-        });
-        revPromise = _this._bundler.getRevisionByGraphId(graphId);
+      const revPromise = _this._bundler.getRevisionByGraphId(graphId);
 
-        if (!revPromise) {
-          send([sendFn], {
-            type: "error",
-            body: formatBundlingError(new GraphNotFoundError(graphId))
-          });
-          return;
-        }
-      } else {
+      if (!revPromise) {
+        send([sendFn], {
+          type: "error",
+          body: formatBundlingError(new GraphNotFoundError(graphId))
+        });
         return;
       }
 
-      const _ref = yield revPromise,
-        graph = _ref.graph,
-        id = _ref.id;
+      const _yield$revPromise = yield revPromise,
+        graph = _yield$revPromise.graph,
+        id = _yield$revPromise.id;
 
       client.revisionIds.push(id);
 
@@ -238,20 +301,29 @@ class HmrServer {
         // Prepare the clientUrl to be used as sourceUrl in HMR updates.
         clientUrl.protocol = "http";
 
-        const _ref2 = clientUrl.query || {},
-          platform = _ref2.platform,
-          dev = _ref2.dev,
-          minify = _ref2.minify,
-          runModule = _ref2.runModule;
-
-        clientUrl.query = {
-          platform,
-          dev: dev || "true",
-          minify: minify || "false",
-          modulesOnly: "true",
-          runModule: runModule || "false",
-          shallow: "true"
-        };
+        const _ref = clientUrl.query || {},
+          dev = _ref.dev,
+          minify = _ref.minify,
+          runModule = _ref.runModule,
+          _bundleEntry = _ref.bundleEntry,
+          query = _objectWithoutProperties(_ref, [
+            "dev",
+            "minify",
+            "runModule",
+            "bundleEntry"
+          ]);
+
+        clientUrl.query = _objectSpread(
+          _objectSpread({}, query),
+          {},
+          {
+            dev: dev || "true",
+            minify: minify || "false",
+            modulesOnly: "true",
+            runModule: runModule || "false",
+            shallow: "true"
+          }
+        );
         clientUrl.search = "";
         clientGroup = {
           clients: new Set([client]),
@@ -308,7 +380,12 @@ class HmrServer {
             );
 
           case "log":
-            logToConsole(data.level, data.data);
+            _this2._config.reporter.update({
+              type: "client_log",
+              level: data.level,
+              data: data.data
+            });
+
             break;
 
           case "log-opt-in":
@@ -385,12 +462,16 @@ class HmrServer {
         type: "update-done"
       });
       log(
-        _objectSpread({}, createActionEndEntry(processingHmrChange), {
-          outdated_modules:
-            message.type === "update"
-              ? message.body.added.length + message.body.modified.length
-              : undefined
-        })
+        _objectSpread(
+          _objectSpread({}, createActionEndEntry(processingHmrChange)),
+          {},
+          {
+            outdated_modules:
+              message.type === "update"
+                ? message.body.added.length + message.body.modified.length
+                : undefined
+          }
+        )
       );
     })();
   }
@@ -411,12 +492,12 @@ class HmrServer {
           };
         }
 
-        const _ref3 = yield _this4._bundler.updateGraph(
+        const _yield$_this4$_bundle = yield _this4._bundler.updateGraph(
             yield revPromise,
             false
           ),
-          revision = _ref3.revision,
-          delta = _ref3.delta;
+          revision = _yield$_this4$_bundle.revision,
+          delta = _yield$_this4$_bundle.delta;
 
         _this4._clientGroups.delete(group.revisionId);
 
diff --git a/node_modules/metro/src/HmrServer.js.flow b/node_modules/metro/src/HmrServer.js.flow
index 9856780..b00bb9c 100644
--- a/node_modules/metro/src/HmrServer.js.flow
+++ b/node_modules/metro/src/HmrServer.js.flow
@@ -18,7 +18,6 @@ const debounceAsyncQueue = require('./lib/debounceAsyncQueue');
 const formatBundlingError = require('./lib/formatBundlingError');
 const getGraphId = require('./lib/getGraphId');
 const hmrJSBundle = require('./DeltaBundler/Serializers/hmrJSBundle');
-const logToConsole = require('./lib/logToConsole');
 const nullthrows = require('nullthrows');
 const parseOptionsFromUrl = require('./lib/parseOptionsFromUrl');
 const splitBundleOptions = require('./lib/splitBundleOptions');
@@ -28,15 +27,16 @@ const url = require('url');
 const {
   Logger: {createActionStartEntry, createActionEndEntry, log},
 } = require('metro-core');
+const {VERSION: BYTECODE_VERSION} = require('metro-hermes-compiler');
 
 import type {RevisionId} from './IncrementalBundler';
+import type {ConfigT} from 'metro-config/src/configTypes.flow';
 import type {
   HmrMessage,
   HmrClientMessage,
   HmrUpdateMessage,
   HmrErrorMessage,
-} from './lib/bundle-modules/types.flow';
-import type {ConfigT} from 'metro-config/src/configTypes.flow';
+} from 'metro-runtime/src/modules/types.flow';
 
 type $ReturnType<F> = $Call<<A, R>((...A) => R) => R, F>;
 export type EntryPointURL = $ReturnType<typeof url.parse>;
@@ -101,57 +101,40 @@ class HmrServer<TClient: Client> {
     requestUrl: string,
     sendFn: (data: string) => void,
   ): Promise<void> {
+    requestUrl = this._config.server.rewriteRequestUrl(requestUrl);
     const clientUrl = nullthrows(url.parse(requestUrl, true));
-    const query = nullthrows(clientUrl.query);
-
-    let revPromise;
-    if (query.revisionId) {
-      const revisionId = query.revisionId;
-      revPromise = this._bundler.getRevision(revisionId);
-
-      if (!revPromise) {
-        send([sendFn], {
-          type: 'error',
-          body: formatBundlingError(new RevisionNotFoundError(revisionId)),
-        });
-        return;
-      }
-    } else if (query.bundleEntry != null) {
-      const {options} = parseOptionsFromUrl(
-        requestUrl,
-        new Set(this._config.resolver.platforms),
-      );
-      const {entryFile, transformOptions, graphOptions} = splitBundleOptions(
-        options,
-      );
+    const options = parseOptionsFromUrl(
+      requestUrl,
+      new Set(this._config.resolver.platforms),
+      BYTECODE_VERSION,
+    );
+    const {entryFile, transformOptions, graphOptions} = splitBundleOptions(
+      options,
+    );
 
-      /**
-       * `entryFile` is relative to projectRoot, we need to use resolution function
-       * to find the appropriate file with supported extensions.
-       */
-      const resolutionFn = await transformHelpers.getResolveDependencyFn(
-        this._bundler.getBundler(),
-        transformOptions.platform,
-      );
-      const resolvedEntryFilePath = resolutionFn(
-        this._config.projectRoot + '/.',
-        entryFile,
-      );
-      const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {
-        shallow: graphOptions.shallow,
-        experimentalImportBundleSupport: this._config.transformer
-          .experimentalImportBundleSupport,
+    /**
+     * `entryFile` is relative to projectRoot, we need to use resolution function
+     * to find the appropriate file with supported extensions.
+     */
+    const resolutionFn = await transformHelpers.getResolveDependencyFn(
+      this._bundler.getBundler(),
+      transformOptions.platform,
+    );
+    const resolvedEntryFilePath = resolutionFn(
+      this._config.projectRoot + '/.',
+      entryFile,
+    );
+    const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {
+      shallow: graphOptions.shallow,
+      experimentalImportBundleSupport: this._config.transformer
+        .experimentalImportBundleSupport,
+    });
+    const revPromise = this._bundler.getRevisionByGraphId(graphId);
+    if (!revPromise) {
+      send([sendFn], {
+        type: 'error',
+        body: formatBundlingError(new GraphNotFoundError(graphId)),
       });
-      revPromise = this._bundler.getRevisionByGraphId(graphId);
-
-      if (!revPromise) {
-        send([sendFn], {
-          type: 'error',
-          body: formatBundlingError(new GraphNotFoundError(graphId)),
-        });
-        return;
-      }
-    } else {
       return;
     }
 
@@ -164,9 +147,10 @@ class HmrServer<TClient: Client> {
     } else {
       // Prepare the clientUrl to be used as sourceUrl in HMR updates.
       clientUrl.protocol = 'http';
-      const {platform, dev, minify, runModule} = clientUrl.query || {};
+      const {dev, minify, runModule, bundleEntry: _bundleEntry, ...query} =
+        clientUrl.query || {};
       clientUrl.query = {
-        platform,
+        ...query,
         dev: dev || 'true',
         minify: minify || 'false',
         modulesOnly: 'true',
@@ -223,7 +207,11 @@ class HmrServer<TClient: Client> {
             ),
           );
         case 'log':
-          logToConsole(data.level, data.data);
+          this._config.reporter.update({
+            type: 'client_log',
+            level: data.level,
+            data: data.data,
+          });
           break;
         case 'log-opt-in':
           client.optedIntoHMR = true;
diff --git a/node_modules/metro/src/IncrementalBundler.js b/node_modules/metro/src/IncrementalBundler.js
index 11c6a1f..de073e0 100644
--- a/node_modules/metro/src/IncrementalBundler.js
+++ b/node_modules/metro/src/IncrementalBundler.js
@@ -9,21 +9,78 @@
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
+  return target;
+}
+
+function _objectWithoutProperties(source, excluded) {
+  if (source == null) return {};
+
+  var target = _objectWithoutPropertiesLoose(source, excluded);
+
+  var key, i;
+
+  if (Object.getOwnPropertySymbols) {
+    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
+
+    for (i = 0; i < sourceSymbolKeys.length; i++) {
+      key = sourceSymbolKeys[i];
+      if (excluded.indexOf(key) >= 0) continue;
+      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
+      target[key] = source[key];
+    }
+  }
+
+  return target;
+}
+
+function _objectWithoutPropertiesLoose(source, excluded) {
+  if (source == null) return {};
+  var target = {};
+  var sourceKeys = Object.keys(source);
+  var key, i;
+
+  for (i = 0; i < sourceKeys.length; i++) {
+    key = sourceKeys[i];
+    if (excluded.indexOf(key) >= 0) continue;
+    target[key] = source[key];
+  }
+
   return target;
 }
 
@@ -35,6 +92,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -48,12 +106,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -70,6 +131,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -100,13 +162,13 @@ function revisionIdFromString(str) {
 }
 
 class IncrementalBundler {
-  constructor(config) {
+  constructor(config, options) {
     _defineProperty(this, "_revisionsById", new Map());
 
     _defineProperty(this, "_revisionsByGraphId", new Map());
 
     this._config = config;
-    this._bundler = new Bundler(config);
+    this._bundler = new Bundler(config, options);
     this._deltaBundler = new DeltaBundler(this._bundler);
   }
 
@@ -143,25 +205,7 @@ class IncrementalBundler {
             shallow: false
           };
     return _asyncToGenerator(function*() {
-      const absoluteEntryFiles = entryFiles.map(entryFile =>
-        path.resolve(_this._config.projectRoot, entryFile)
-      );
-      yield Promise.all(
-        absoluteEntryFiles.map(
-          entryFile =>
-            new Promise((resolve, reject) => {
-              // This should throw an error if the file doesn't exist.
-              // Using this instead of fs.exists to account for SimLinks.
-              fs.realpath(entryFile, err => {
-                if (err) {
-                  reject(new ResourceNotFoundError(entryFile));
-                } else {
-                  resolve();
-                }
-              });
-            })
-        )
-      );
+      const absoluteEntryFiles = yield _this._getAbsoluteEntryFiles(entryFiles);
       const graph = yield _this._deltaBundler.buildGraph(absoluteEntryFiles, {
         resolve: yield transformHelpers.getResolveDependencyFn(
           _this._bundler,
@@ -191,7 +235,7 @@ class IncrementalBundler {
     })();
   }
 
-  buildGraph(entryFile, transformOptions) {
+  getDependencies(entryFiles, transformOptions) {
     var _this2 = this;
 
     let otherOptions =
@@ -202,26 +246,61 @@ class IncrementalBundler {
             shallow: false
           };
     return _asyncToGenerator(function*() {
-      const graph = yield _this2.buildGraphForEntries(
+      const absoluteEntryFiles = yield _this2._getAbsoluteEntryFiles(
+        entryFiles
+      );
+      const dependencies = yield _this2._deltaBundler.getDependencies(
+        absoluteEntryFiles,
+        {
+          resolve: yield transformHelpers.getResolveDependencyFn(
+            _this2._bundler,
+            transformOptions.platform
+          ),
+          transform: yield transformHelpers.getTransformFn(
+            absoluteEntryFiles,
+            _this2._bundler,
+            _this2._deltaBundler,
+            _this2._config,
+            transformOptions
+          ),
+          onProgress: otherOptions.onProgress,
+          experimentalImportBundleSupport:
+            _this2._config.transformer.experimentalImportBundleSupport,
+          shallow: otherOptions.shallow
+        }
+      );
+      return dependencies;
+    })();
+  }
+
+  buildGraph(entryFile, transformOptions) {
+    var _this3 = this;
+
+    let otherOptions =
+      arguments.length > 2 && arguments[2] !== undefined
+        ? arguments[2]
+        : {
+            onProgress: null,
+            shallow: false
+          };
+    return _asyncToGenerator(function*() {
+      const graph = yield _this3.buildGraphForEntries(
         [entryFile],
         transformOptions,
         otherOptions
       );
-      const transformOptionsWithoutType = {
-        customTransformOptions: transformOptions.customTransformOptions,
-        dev: transformOptions.dev,
-        experimentalImportSupport: transformOptions.experimentalImportSupport,
-        hot: transformOptions.hot,
-        minify: transformOptions.minify,
-        unstable_disableES6Transforms:
-          transformOptions.unstable_disableES6Transforms,
-        platform: transformOptions.platform
-      };
+
+      const _ = transformOptions.type,
+        transformOptionsWithoutType = _objectWithoutProperties(
+          transformOptions,
+          ["type"]
+        );
+
       const prepend = yield getPrependedScripts(
-        _this2._config,
+        _this3._config,
         transformOptionsWithoutType,
-        _this2._bundler,
-        _this2._deltaBundler
+        _this3._bundler,
+        _this3._deltaBundler
       );
       return {
         prepend,
@@ -232,7 +311,7 @@ class IncrementalBundler {
   // this class exposes only initializeGraph and updateGraph.
 
   initializeGraph(entryFile, transformOptions) {
-    var _this3 = this;
+    var _this4 = this;
 
     let otherOptions =
       arguments.length > 2 && arguments[2] !== undefined
@@ -245,18 +324,18 @@ class IncrementalBundler {
       const graphId = getGraphId(entryFile, transformOptions, {
         shallow: otherOptions.shallow,
         experimentalImportBundleSupport:
-          _this3._config.transformer.experimentalImportBundleSupport
+          _this4._config.transformer.experimentalImportBundleSupport
       });
       const revisionId = createRevisionId();
 
       const revisionPromise = _asyncToGenerator(function*() {
-        const _ref2 = yield _this3.buildGraph(
+        const _yield$_this4$buildGr = yield _this4.buildGraph(
             entryFile,
             transformOptions,
             otherOptions
           ),
-          graph = _ref2.graph,
-          prepend = _ref2.prepend;
+          graph = _yield$_this4$buildGr.graph,
+          prepend = _yield$_this4$buildGr.prepend;
 
         return {
           id: revisionId,
@@ -267,9 +346,9 @@ class IncrementalBundler {
         };
       })();
 
-      _this3._revisionsById.set(revisionId, revisionPromise);
+      _this4._revisionsById.set(revisionId, revisionPromise);
 
-      _this3._revisionsByGraphId.set(graphId, revisionPromise);
+      _this4._revisionsByGraphId.set(graphId, revisionPromise);
 
       try {
         const revision = yield revisionPromise;
@@ -286,9 +365,9 @@ class IncrementalBundler {
       } catch (err) {
         // Evict a bad revision from the cache since otherwise
         // we'll keep getting it even after the build is fixed.
-        _this3._revisionsById.delete(revisionId);
+        _this4._revisionsById.delete(revisionId);
 
-        _this3._revisionsByGraphId.delete(graphId);
+        _this4._revisionsByGraphId.delete(graphId);
 
         throw err;
       }
@@ -296,15 +375,15 @@ class IncrementalBundler {
   }
 
   updateGraph(revision, reset) {
-    var _this4 = this;
+    var _this5 = this;
 
     return _asyncToGenerator(function*() {
-      const delta = yield _this4._deltaBundler.getDelta(revision.graph, {
+      const delta = yield _this5._deltaBundler.getDelta(revision.graph, {
         reset,
         shallow: false
       });
 
-      _this4._config.serializer.experimentalSerializerHook(
+      _this5._config.serializer.experimentalSerializerHook(
         revision.graph,
         delta
       );
@@ -314,19 +393,23 @@ class IncrementalBundler {
         delta.modified.size > 0 ||
         delta.deleted.size > 0
       ) {
-        _this4._revisionsById.delete(revision.id);
-
-        revision = _objectSpread({}, revision, {
-          // Generate a new revision id, to be used to verify the next incremental
-          // request.
-          id: crypto.randomBytes(8).toString("hex"),
-          date: new Date()
-        });
+        _this5._revisionsById.delete(revision.id);
+
+        revision = _objectSpread(
+          _objectSpread({}, revision),
+          {},
+          {
+            // Generate a new revision id, to be used to verify the next incremental
+            // request.
+            id: crypto.randomBytes(8).toString("hex"),
+            date: new Date()
+          }
+        );
         const revisionPromise = Promise.resolve(revision);
 
-        _this4._revisionsById.set(revision.id, revisionPromise);
+        _this5._revisionsById.set(revision.id, revisionPromise);
 
-        _this4._revisionsByGraphId.set(revision.graphId, revisionPromise);
+        _this5._revisionsByGraphId.set(revision.graphId, revisionPromise);
       }
 
       return {
@@ -335,6 +418,53 @@ class IncrementalBundler {
       };
     })();
   }
+
+  endGraph(graphId) {
+    var _this6 = this;
+
+    return _asyncToGenerator(function*() {
+      const revPromise = _this6._revisionsByGraphId.get(graphId);
+
+      if (!revPromise) {
+        return;
+      }
+
+      const revision = yield revPromise;
+
+      _this6._deltaBundler.endGraph(revision.graph);
+
+      _this6._revisionsByGraphId.delete(graphId);
+
+      _this6._revisionsById.delete(revision.id);
+    })();
+  }
+
+  _getAbsoluteEntryFiles(entryFiles) {
+    var _this7 = this;
+
+    return _asyncToGenerator(function*() {
+      const absoluteEntryFiles = entryFiles.map(entryFile =>
+        path.resolve(_this7._config.projectRoot, entryFile)
+      );
+      yield Promise.all(
+        absoluteEntryFiles.map(
+          entryFile =>
+            new Promise((resolve, reject) => {
+              // This should throw an error if the file doesn't exist.
+              // Using this instead of fs.exists to account for SimLinks.
+              fs.realpath(entryFile, err => {
+                if (err) {
+                  reject(new ResourceNotFoundError(entryFile));
+                } else {
+                  resolve();
+                }
+              });
+            })
+        )
+      );
+      return absoluteEntryFiles;
+    })();
+  }
 }
 
 _defineProperty(
diff --git a/node_modules/metro/src/IncrementalBundler.js.flow b/node_modules/metro/src/IncrementalBundler.js.flow
index c47b816..38f0439 100644
--- a/node_modules/metro/src/IncrementalBundler.js.flow
+++ b/node_modules/metro/src/IncrementalBundler.js.flow
@@ -21,7 +21,10 @@ const getPrependedScripts = require('./lib/getPrependedScripts');
 const path = require('path');
 const transformHelpers = require('./lib/transformHelpers');
 
-import type {Options as DeltaBundlerOptions} from './DeltaBundler/types.flow';
+import type {
+  Options as DeltaBundlerOptions,
+  Dependencies,
+} from './DeltaBundler/types.flow';
 import type {DeltaResult, Module, Graph} from './DeltaBundler';
 import type {GraphId} from './lib/getGraphId';
 import type {TransformInputOptions} from './lib/transformHelpers';
@@ -45,6 +48,11 @@ export type GraphRevision = {|
   +prepend: $ReadOnlyArray<Module<>>,
 |};
 
+export type IncrementalBundlerOptions = $ReadOnly<{|
+  hasReducedPerformance?: boolean,
+  watch?: boolean,
+|}>;
+
 function createRevisionId(): RevisionId {
   return crypto.randomBytes(8).toString('hex');
 }
@@ -60,11 +68,13 @@ class IncrementalBundler {
   _revisionsById: Map<RevisionId, Promise<GraphRevision>> = new Map();
   _revisionsByGraphId: Map<GraphId, Promise<GraphRevision>> = new Map();
 
-  static revisionIdFromString = revisionIdFromString;
+  static revisionIdFromString: (
+    str: string,
+  ) => RevisionId = revisionIdFromString;
 
-  constructor(config: ConfigT) {
+  constructor(config: ConfigT, options?: IncrementalBundlerOptions) {
     this._config = config;
-    this._bundler = new Bundler(config);
+    this._bundler = new Bundler(config, options);
     this._deltaBundler = new DeltaBundler(this._bundler);
   }
 
@@ -97,26 +107,7 @@ class IncrementalBundler {
       shallow: false,
     },
   ): Promise<OutputGraph> {
-    const absoluteEntryFiles = entryFiles.map((entryFile: string) =>
-      path.resolve(this._config.projectRoot, entryFile),
-    );
-
-    await Promise.all(
-      absoluteEntryFiles.map(
-        (entryFile: string) =>
-          new Promise((resolve: void => void, reject: mixed => mixed) => {
-            // This should throw an error if the file doesn't exist.
-            // Using this instead of fs.exists to account for SimLinks.
-            fs.realpath(entryFile, err => {
-              if (err) {
-                reject(new ResourceNotFoundError(entryFile));
-              } else {
-                resolve();
-              }
-            });
-          }),
-      ),
-    );
+    const absoluteEntryFiles = await this._getAbsoluteEntryFiles(entryFiles);
 
     const graph = await this._deltaBundler.buildGraph(absoluteEntryFiles, {
       resolve: await transformHelpers.getResolveDependencyFn(
@@ -146,6 +137,40 @@ class IncrementalBundler {
     return graph;
   }
 
+  async getDependencies(
+    entryFiles: $ReadOnlyArray<string>,
+    transformOptions: TransformInputOptions,
+    otherOptions?: OtherOptions = {
+      onProgress: null,
+      shallow: false,
+    },
+  ): Promise<Dependencies<>> {
+    const absoluteEntryFiles = await this._getAbsoluteEntryFiles(entryFiles);
+
+    const dependencies = await this._deltaBundler.getDependencies(
+      absoluteEntryFiles,
+      {
+        resolve: await transformHelpers.getResolveDependencyFn(
+          this._bundler,
+          transformOptions.platform,
+        ),
+        transform: await transformHelpers.getTransformFn(
+          absoluteEntryFiles,
+          this._bundler,
+          this._deltaBundler,
+          this._config,
+          transformOptions,
+        ),
+        onProgress: otherOptions.onProgress,
+        experimentalImportBundleSupport: this._config.transformer
+          .experimentalImportBundleSupport,
+        shallow: otherOptions.shallow,
+      },
+    );
+
+    return dependencies;
+  }
+
   async buildGraph(
     entryFile: string,
     transformOptions: TransformInputOptions,
@@ -160,16 +185,7 @@ class IncrementalBundler {
       otherOptions,
     );
 
-    const transformOptionsWithoutType = {
-      customTransformOptions: transformOptions.customTransformOptions,
-      dev: transformOptions.dev,
-      experimentalImportSupport: transformOptions.experimentalImportSupport,
-      hot: transformOptions.hot,
-      minify: transformOptions.minify,
-      unstable_disableES6Transforms:
-        transformOptions.unstable_disableES6Transforms,
-      platform: transformOptions.platform,
-    };
+    const {type: _, ...transformOptionsWithoutType} = transformOptions;
 
     const prepend = await getPrependedScripts(
       this._config,
@@ -193,7 +209,11 @@ class IncrementalBundler {
       onProgress: null,
       shallow: false,
     },
-  ): Promise<{delta: DeltaResult<>, revision: GraphRevision}> {
+  ): Promise<{
+    delta: DeltaResult<>,
+    revision: GraphRevision,
+    ...
+  }> {
     const graphId = getGraphId(entryFile, transformOptions, {
       shallow: otherOptions.shallow,
       experimentalImportBundleSupport: this._config.transformer
@@ -241,7 +261,11 @@ class IncrementalBundler {
   async updateGraph(
     revision: GraphRevision,
     reset: boolean,
-  ): Promise<{delta: DeltaResult<>, revision: GraphRevision}> {
+  ): Promise<{
+    delta: DeltaResult<>,
+    revision: GraphRevision,
+    ...
+  }> {
     const delta = await this._deltaBundler.getDelta(revision.graph, {
       reset,
       shallow: false,
@@ -269,6 +293,44 @@ class IncrementalBundler {
 
     return {revision, delta};
   }
+
+  async endGraph(graphId: GraphId): Promise<void> {
+    const revPromise = this._revisionsByGraphId.get(graphId);
+    if (!revPromise) {
+      return;
+    }
+    const revision = await revPromise;
+    this._deltaBundler.endGraph(revision.graph);
+    this._revisionsByGraphId.delete(graphId);
+    this._revisionsById.delete(revision.id);
+  }
+
+  async _getAbsoluteEntryFiles(
+    entryFiles: $ReadOnlyArray<string>,
+  ): Promise<$ReadOnlyArray<string>> {
+    const absoluteEntryFiles = entryFiles.map((entryFile: string) =>
+      path.resolve(this._config.projectRoot, entryFile),
+    );
+
+    await Promise.all(
+      absoluteEntryFiles.map(
+        (entryFile: string) =>
+          new Promise((resolve: void => void, reject: mixed => mixed) => {
+            // This should throw an error if the file doesn't exist.
+            // Using this instead of fs.exists to account for SimLinks.
+            fs.realpath(entryFile, err => {
+              if (err) {
+                reject(new ResourceNotFoundError(entryFile));
+              } else {
+                resolve();
+              }
+            });
+          }),
+      ),
+    );
+
+    return absoluteEntryFiles;
+  }
 }
 
 module.exports = IncrementalBundler;
diff --git a/node_modules/metro/src/JSTransformer/worker.js b/node_modules/metro/src/JSTransformer/worker.js
deleted file mode 100644
index 4d12744..0000000
--- a/node_modules/metro/src/JSTransformer/worker.js
+++ /dev/null
@@ -1,485 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-function _objectWithoutProperties(source, excluded) {
-  if (source == null) return {};
-  var target = _objectWithoutPropertiesLoose(source, excluded);
-  var key, i;
-  if (Object.getOwnPropertySymbols) {
-    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
-    for (i = 0; i < sourceSymbolKeys.length; i++) {
-      key = sourceSymbolKeys[i];
-      if (excluded.indexOf(key) >= 0) continue;
-      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
-      target[key] = source[key];
-    }
-  }
-  return target;
-}
-
-function _objectWithoutPropertiesLoose(source, excluded) {
-  if (source == null) return {};
-  var target = {};
-  var sourceKeys = Object.keys(source);
-  var key, i;
-  for (i = 0; i < sourceKeys.length; i++) {
-    key = sourceKeys[i];
-    if (excluded.indexOf(key) >= 0) continue;
-    target[key] = source[key];
-  }
-  return target;
-}
-
-function _objectSpread(target) {
-  for (var i = 1; i < arguments.length; i++) {
-    var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
-    }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
-  }
-  return target;
-}
-
-function _defineProperty(obj, key, value) {
-  if (key in obj) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-  } else {
-    obj[key] = value;
-  }
-  return obj;
-}
-
-function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
-  try {
-    var info = gen[key](arg);
-    var value = info.value;
-  } catch (error) {
-    reject(error);
-    return;
-  }
-  if (info.done) {
-    resolve(value);
-  } else {
-    Promise.resolve(value).then(_next, _throw);
-  }
-}
-
-function _asyncToGenerator(fn) {
-  return function() {
-    var self = this,
-      args = arguments;
-    return new Promise(function(resolve, reject) {
-      var gen = fn.apply(self, args);
-      function _next(value) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
-      }
-      function _throw(err) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
-      }
-      _next(undefined);
-    });
-  };
-}
-
-const JsFileWrapping = require("../ModuleGraph/worker/JsFileWrapping");
-
-const assetTransformer = require("../assetTransformer");
-
-const babylon = require("@babel/parser");
-
-const collectDependencies = require("../ModuleGraph/worker/collectDependencies");
-
-const constantFoldingPlugin = require("./worker/constant-folding-plugin");
-
-const generateImportNames = require("../ModuleGraph/worker/generateImportNames");
-
-const generate = require("@babel/generator").default;
-
-const getKeyFromFiles = require("../lib/getKeyFromFiles");
-
-const getMinifier = require("../lib/getMinifier");
-
-const importExportPlugin = require("./worker/import-export-plugin");
-
-const inlinePlugin = require("./worker/inline-plugin");
-
-const inlineRequiresPlugin = require("babel-preset-fbjs/plugins/inline-requires");
-
-const normalizePseudoglobals = require("./worker/normalizePseudoglobals");
-
-const _require = require("@babel/core"),
-  transformFromAstSync = _require.transformFromAstSync;
-
-const _require2 = require("metro-cache"),
-  stableHash = _require2.stableHash;
-
-const types = require("@babel/types");
-
-const countLines = require("../lib/countLines");
-
-const _require3 = require("metro-source-map"),
-  fromRawMappings = _require3.fromRawMappings,
-  toBabelSegments = _require3.toBabelSegments,
-  toSegmentTuple = _require3.toSegmentTuple;
-
-function getDynamicDepsBehavior(inPackages, filename) {
-  switch (inPackages) {
-    case "reject":
-      return "reject";
-
-    case "throwAtRuntime":
-      const isPackage = /(?:^|[/\\])node_modules[/\\]/.test(filename);
-      return isPackage ? inPackages : "reject";
-
-    default:
-      inPackages;
-      throw new Error(
-        `invalid value for dynamic deps behavior: \`${inPackages}\``
-      );
-  }
-}
-
-class JsTransformer {
-  constructor(projectRoot, config) {
-    this._projectRoot = projectRoot;
-    this._config = config;
-  }
-
-  transform(filename, data, options) {
-    var _this = this;
-
-    return _asyncToGenerator(function*() {
-      const sourceCode = data.toString("utf8");
-      let type = "js/module";
-
-      if (options.type === "asset") {
-        type = "js/module/asset";
-      }
-
-      if (options.type === "script") {
-        type = "js/script";
-      }
-
-      if (filename.endsWith(".json")) {
-        let code = JsFileWrapping.wrapJson(sourceCode);
-        let map = [];
-
-        if (options.minify) {
-          var _ref = yield _this._minifyCode(filename, code, sourceCode, map);
-
-          map = _ref.map;
-          code = _ref.code;
-        }
-
-        return {
-          dependencies: [],
-          output: [
-            {
-              data: {
-                code,
-                lineCount: countLines(code),
-                map,
-                functionMap: null
-              },
-              type
-            }
-          ]
-        };
-      } // $FlowFixMe TODO t26372934 Plugin system
-
-      const transformer = require(_this._config.babelTransformerPath);
-
-      const transformerArgs = {
-        filename,
-        options: _objectSpread({}, options, {
-          enableBabelRCLookup: _this._config.enableBabelRCLookup,
-          enableBabelRuntime: _this._config.enableBabelRuntime,
-          // Inline requires are now performed at a secondary step. We cannot
-          // unfortunately remove it from the internal transformer, since this one
-          // is used by other tooling, and this would affect it.
-          inlineRequires: false,
-          projectRoot: _this._projectRoot,
-          publicPath: _this._config.publicPath
-        }),
-        plugins: [],
-        src: sourceCode
-      };
-      const transformResult =
-        type === "js/module/asset"
-          ? _objectSpread(
-              {},
-              yield assetTransformer.transform(
-                transformerArgs,
-                _this._config.assetRegistryPath,
-                _this._config.assetPlugins
-              ),
-              {
-                functionMap: null
-              }
-            )
-          : yield transformer.transform(transformerArgs); // Transformers can ouptut null ASTs (if they ignore the file). In that case
-      // we need to parse the module source code to get their AST.
-
-      let ast =
-        transformResult.ast ||
-        babylon.parse(sourceCode, {
-          sourceType: "unambiguous"
-        });
-
-      const _generateImportNames = generateImportNames(ast),
-        importDefault = _generateImportNames.importDefault,
-        importAll = _generateImportNames.importAll; // Add "use strict" if the file was parsed as a module, and the directive did
-      // not exist yet.
-
-      const directives = ast.program.directives;
-
-      if (
-        ast.program.sourceType === "module" &&
-        directives.findIndex(d => d.value.value === "use strict") === -1
-      ) {
-        directives.push(types.directive(types.directiveLiteral("use strict")));
-      } // Perform the import-export transform (in case it's still needed), then
-      // fold requires and perform constant folding (if in dev).
-
-      const plugins = [];
-
-      const opts = _objectSpread({}, options, {
-        inlineableCalls: [importDefault, importAll],
-        importDefault,
-        importAll
-      });
-
-      if (options.experimentalImportSupport) {
-        plugins.push([importExportPlugin, opts]);
-      }
-
-      if (options.inlineRequires) {
-        plugins.push([inlineRequiresPlugin, opts]);
-      }
-
-      if (!options.dev) {
-        plugins.push([constantFoldingPlugin, opts]);
-      }
-
-      plugins.push([inlinePlugin, opts]);
-
-      var _transformFromAstSync = transformFromAstSync(ast, "", {
-        ast: true,
-        babelrc: false,
-        code: false,
-        configFile: false,
-        comments: false,
-        compact: false,
-        filename,
-        plugins,
-        sourceMaps: false
-      });
-
-      ast = _transformFromAstSync.ast;
-      let dependencyMapName = "";
-      let dependencies;
-      let wrappedAst; // If the module to transform is a script (meaning that is not part of the
-      // dependency graph and it code will just be prepended to the bundle modules),
-      // we need to wrap it differently than a commonJS module (also, scripts do
-      // not have dependencies).
-
-      if (type === "js/script") {
-        dependencies = [];
-        wrappedAst = JsFileWrapping.wrapPolyfill(ast);
-      } else {
-        try {
-          const opts = {
-            asyncRequireModulePath: _this._config.asyncRequireModulePath,
-            dynamicRequires: getDynamicDepsBehavior(
-              _this._config.dynamicDepsInPackages,
-              filename
-            ),
-            inlineableCalls: [importDefault, importAll],
-            keepRequireNames: options.dev
-          };
-
-          var _collectDependencies = collectDependencies(ast, opts);
-
-          ast = _collectDependencies.ast;
-          dependencies = _collectDependencies.dependencies;
-          dependencyMapName = _collectDependencies.dependencyMapName;
-        } catch (error) {
-          if (error instanceof collectDependencies.InvalidRequireCallError) {
-            throw new InvalidRequireCallError(error, filename);
-          }
-
-          throw error;
-        }
-
-        var _JsFileWrapping$wrapM = JsFileWrapping.wrapModule(
-          ast,
-          importDefault,
-          importAll,
-          dependencyMapName
-        );
-
-        wrappedAst = _JsFileWrapping$wrapM.ast;
-      }
-
-      const reserved =
-        options.minify && data.length <= _this._config.optimizationSizeLimit
-          ? normalizePseudoglobals(wrappedAst)
-          : [];
-      const result = generate(
-        wrappedAst,
-        {
-          comments: false,
-          compact: false,
-          filename,
-          retainLines: false,
-          sourceFileName: filename,
-          sourceMaps: true
-        },
-        sourceCode
-      );
-      let map = result.rawMappings
-        ? result.rawMappings.map(toSegmentTuple)
-        : [];
-      let code = result.code;
-
-      if (options.minify) {
-        var _ref2 = yield _this._minifyCode(
-          filename,
-          result.code,
-          sourceCode,
-          map,
-          reserved
-        );
-
-        map = _ref2.map;
-        code = _ref2.code;
-      }
-
-      const functionMap = transformResult.functionMap;
-      return {
-        dependencies,
-        output: [
-          {
-            data: {
-              code,
-              lineCount: countLines(code),
-              map,
-              functionMap
-            },
-            type
-          }
-        ]
-      };
-    })();
-  }
-
-  _minifyCode(filename, code, source, map) {
-    var _this2 = this;
-
-    let reserved =
-      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
-    return _asyncToGenerator(function*() {
-      const sourceMap = fromRawMappings([
-        {
-          code,
-          source,
-          map,
-          functionMap: null,
-          path: filename
-        }
-      ]).toMap(undefined, {});
-      const minify = getMinifier(_this2._config.minifierPath);
-
-      try {
-        const minified = minify({
-          code,
-          map: sourceMap,
-          filename,
-          reserved,
-          config: _this2._config.minifierConfig
-        });
-        return {
-          code: minified.code,
-          map: minified.map
-            ? toBabelSegments(minified.map).map(toSegmentTuple)
-            : []
-        };
-      } catch (error) {
-        if (error.constructor.name === "JS_Parse_Error") {
-          throw new Error(
-            `${error.message} in file ${filename} at ${error.line}:${error.col}`
-          );
-        }
-
-        throw error;
-      }
-    })();
-  }
-
-  getCacheKey() {
-    const _this$_config = this._config,
-      babelTransformerPath = _this$_config.babelTransformerPath,
-      minifierPath = _this$_config.minifierPath,
-      config = _objectWithoutProperties(_this$_config, [
-        "babelTransformerPath",
-        "minifierPath"
-      ]);
-
-    const filesKey = getKeyFromFiles([
-      require.resolve(babelTransformerPath),
-      require.resolve(minifierPath),
-      require.resolve("../ModuleGraph/worker/JsFileWrapping"),
-      require.resolve("../assetTransformer"),
-      require.resolve("../ModuleGraph/worker/collectDependencies"),
-      require.resolve("./worker/constant-folding-plugin"),
-      require.resolve("../lib/getMinifier"),
-      require.resolve("./worker/inline-plugin"),
-      require.resolve("./worker/import-export-plugin"),
-      require.resolve("./worker/normalizePseudoglobals"),
-      require.resolve("../ModuleGraph/worker/optimizeDependencies"),
-      require.resolve("../ModuleGraph/worker/generateImportNames")
-    ]);
-
-    const babelTransformer = require(babelTransformerPath);
-
-    const babelTransformerKey = babelTransformer.getCacheKey
-      ? babelTransformer.getCacheKey()
-      : "";
-    return [
-      filesKey,
-      stableHash(config).toString("hex"),
-      babelTransformerKey
-    ].join("$");
-  }
-}
-
-class InvalidRequireCallError extends Error {
-  constructor(innerError, filename) {
-    super(`${filename}:${innerError.message}`);
-    this.innerError = innerError;
-    this.filename = filename;
-  }
-}
-
-module.exports = JsTransformer;
diff --git a/node_modules/metro/src/JSTransformer/worker.js.flow b/node_modules/metro/src/JSTransformer/worker.js.flow
deleted file mode 100644
index b5b3910..0000000
--- a/node_modules/metro/src/JSTransformer/worker.js.flow
+++ /dev/null
@@ -1,419 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-const JsFileWrapping = require('../ModuleGraph/worker/JsFileWrapping');
-
-const assetTransformer = require('../assetTransformer');
-const babylon = require('@babel/parser');
-const collectDependencies = require('../ModuleGraph/worker/collectDependencies');
-const constantFoldingPlugin = require('./worker/constant-folding-plugin');
-const generateImportNames = require('../ModuleGraph/worker/generateImportNames');
-const generate = require('@babel/generator').default;
-const getKeyFromFiles = require('../lib/getKeyFromFiles');
-const getMinifier = require('../lib/getMinifier');
-const importExportPlugin = require('./worker/import-export-plugin');
-const inlinePlugin = require('./worker/inline-plugin');
-const inlineRequiresPlugin = require('babel-preset-fbjs/plugins/inline-requires');
-const normalizePseudoglobals = require('./worker/normalizePseudoglobals');
-const {transformFromAstSync} = require('@babel/core');
-const {stableHash} = require('metro-cache');
-const types = require('@babel/types');
-const countLines = require('../lib/countLines');
-
-const {
-  fromRawMappings,
-  toBabelSegments,
-  toSegmentTuple,
-} = require('metro-source-map');
-import type {TransformResultDependency} from 'metro/src/DeltaBundler';
-import type {DynamicRequiresBehavior} from '../ModuleGraph/worker/collectDependencies';
-import type {
-  BasicSourceMap,
-  FBSourceFunctionMap,
-  MetroSourceMapSegmentTuple,
-} from 'metro-source-map';
-
-type MinifierConfig = $ReadOnly<{[string]: mixed}>;
-
-export type MinifierOptions = {
-  code: string,
-  map: ?BasicSourceMap,
-  filename: string,
-  reserved: $ReadOnlyArray<string>,
-  config: MinifierConfig,
-};
-
-export type Type = 'script' | 'module' | 'asset';
-
-export type JsTransformerConfig = $ReadOnly<{|
-  assetPlugins: $ReadOnlyArray<string>,
-  assetRegistryPath: string,
-  asyncRequireModulePath: string,
-  babelTransformerPath: string,
-  dynamicDepsInPackages: DynamicRequiresBehavior,
-  enableBabelRCLookup: boolean,
-  enableBabelRuntime: boolean,
-  experimentalImportBundleSupport: boolean,
-  minifierConfig: MinifierConfig,
-  minifierPath: string,
-  optimizationSizeLimit: number,
-  publicPath: string,
-|}>;
-
-import type {CustomTransformOptions} from 'metro-babel-transformer';
-export type {CustomTransformOptions} from 'metro-babel-transformer';
-
-export type JsTransformOptions = $ReadOnly<{|
-  customTransformOptions?: CustomTransformOptions,
-  dev: boolean,
-  disableFlowStripTypesTransform?: boolean,
-  experimentalImportSupport?: boolean,
-  hot: boolean,
-  inlinePlatform: boolean,
-  inlineRequires: boolean,
-  minify: boolean,
-  unstable_disableES6Transforms?: boolean,
-  platform: ?string,
-  type: Type,
-|}>;
-
-export type JsOutput = $ReadOnly<{|
-  data: $ReadOnly<{|
-    code: string,
-    lineCount: number,
-    map: Array<MetroSourceMapSegmentTuple>,
-    functionMap: ?FBSourceFunctionMap,
-  |}>,
-  type: string,
-|}>;
-
-type Result = {|
-  output: $ReadOnlyArray<JsOutput>,
-  dependencies: $ReadOnlyArray<TransformResultDependency>,
-|};
-
-function getDynamicDepsBehavior(
-  inPackages: DynamicRequiresBehavior,
-  filename: string,
-): DynamicRequiresBehavior {
-  switch (inPackages) {
-    case 'reject':
-      return 'reject';
-    case 'throwAtRuntime':
-      const isPackage = /(?:^|[/\\])node_modules[/\\]/.test(filename);
-      return isPackage ? inPackages : 'reject';
-    default:
-      (inPackages: empty);
-      throw new Error(
-        `invalid value for dynamic deps behavior: \`${inPackages}\``,
-      );
-  }
-}
-
-class JsTransformer {
-  _config: JsTransformerConfig;
-  _projectRoot: string;
-
-  constructor(projectRoot: string, config: JsTransformerConfig) {
-    this._projectRoot = projectRoot;
-    this._config = config;
-  }
-
-  async transform(
-    filename: string,
-    data: Buffer,
-    options: JsTransformOptions,
-  ): Promise<Result> {
-    const sourceCode = data.toString('utf8');
-    let type = 'js/module';
-
-    if (options.type === 'asset') {
-      type = 'js/module/asset';
-    }
-    if (options.type === 'script') {
-      type = 'js/script';
-    }
-
-    if (filename.endsWith('.json')) {
-      let code = JsFileWrapping.wrapJson(sourceCode);
-      let map = [];
-
-      if (options.minify) {
-        ({map, code} = await this._minifyCode(filename, code, sourceCode, map));
-      }
-
-      return {
-        dependencies: [],
-        output: [
-          {
-            data: {code, lineCount: countLines(code), map, functionMap: null},
-            type,
-          },
-        ],
-      };
-    }
-
-    // $FlowFixMe TODO t26372934 Plugin system
-    const transformer: Transformer<*> = require(this._config
-      .babelTransformerPath);
-
-    const transformerArgs = {
-      filename,
-      options: {
-        ...options,
-        enableBabelRCLookup: this._config.enableBabelRCLookup,
-        enableBabelRuntime: this._config.enableBabelRuntime,
-        // Inline requires are now performed at a secondary step. We cannot
-        // unfortunately remove it from the internal transformer, since this one
-        // is used by other tooling, and this would affect it.
-        inlineRequires: false,
-        projectRoot: this._projectRoot,
-        publicPath: this._config.publicPath,
-      },
-      plugins: [],
-      src: sourceCode,
-    };
-
-    const transformResult =
-      type === 'js/module/asset'
-        ? {
-            ...(await assetTransformer.transform(
-              transformerArgs,
-              this._config.assetRegistryPath,
-              this._config.assetPlugins,
-            )),
-            functionMap: null,
-          }
-        : await transformer.transform(transformerArgs);
-
-    // Transformers can ouptut null ASTs (if they ignore the file). In that case
-    // we need to parse the module source code to get their AST.
-    let ast =
-      transformResult.ast ||
-      babylon.parse(sourceCode, {sourceType: 'unambiguous'});
-
-    const {importDefault, importAll} = generateImportNames(ast);
-
-    // Add "use strict" if the file was parsed as a module, and the directive did
-    // not exist yet.
-    const {directives} = ast.program;
-
-    if (
-      ast.program.sourceType === 'module' &&
-      directives.findIndex(d => d.value.value === 'use strict') === -1
-    ) {
-      directives.push(types.directive(types.directiveLiteral('use strict')));
-    }
-
-    // Perform the import-export transform (in case it's still needed), then
-    // fold requires and perform constant folding (if in dev).
-    const plugins = [];
-    const opts = {
-      ...options,
-      inlineableCalls: [importDefault, importAll],
-      importDefault,
-      importAll,
-    };
-
-    if (options.experimentalImportSupport) {
-      plugins.push([importExportPlugin, opts]);
-    }
-
-    if (options.inlineRequires) {
-      plugins.push([inlineRequiresPlugin, opts]);
-    }
-
-    if (!options.dev) {
-      plugins.push([constantFoldingPlugin, opts]);
-    }
-
-    plugins.push([inlinePlugin, opts]);
-
-    ({ast} = transformFromAstSync(ast, '', {
-      ast: true,
-      babelrc: false,
-      code: false,
-      configFile: false,
-      comments: false,
-      compact: false,
-      filename,
-      plugins,
-      sourceMaps: false,
-    }));
-
-    let dependencyMapName = '';
-    let dependencies;
-    let wrappedAst;
-
-    // If the module to transform is a script (meaning that is not part of the
-    // dependency graph and it code will just be prepended to the bundle modules),
-    // we need to wrap it differently than a commonJS module (also, scripts do
-    // not have dependencies).
-    if (type === 'js/script') {
-      dependencies = [];
-      wrappedAst = JsFileWrapping.wrapPolyfill(ast);
-    } else {
-      try {
-        const opts = {
-          asyncRequireModulePath: this._config.asyncRequireModulePath,
-          dynamicRequires: getDynamicDepsBehavior(
-            this._config.dynamicDepsInPackages,
-            filename,
-          ),
-          inlineableCalls: [importDefault, importAll],
-          keepRequireNames: options.dev,
-        };
-        ({ast, dependencies, dependencyMapName} = collectDependencies(
-          ast,
-          opts,
-        ));
-      } catch (error) {
-        if (error instanceof collectDependencies.InvalidRequireCallError) {
-          throw new InvalidRequireCallError(error, filename);
-        }
-        throw error;
-      }
-
-      ({ast: wrappedAst} = JsFileWrapping.wrapModule(
-        ast,
-        importDefault,
-        importAll,
-        dependencyMapName,
-      ));
-    }
-
-    const reserved =
-      options.minify && data.length <= this._config.optimizationSizeLimit
-        ? normalizePseudoglobals(wrappedAst)
-        : [];
-
-    const result = generate(
-      wrappedAst,
-      {
-        comments: false,
-        compact: false,
-        filename,
-        retainLines: false,
-        sourceFileName: filename,
-        sourceMaps: true,
-      },
-      sourceCode,
-    );
-
-    let map = result.rawMappings ? result.rawMappings.map(toSegmentTuple) : [];
-    let code = result.code;
-
-    if (options.minify) {
-      ({map, code} = await this._minifyCode(
-        filename,
-        result.code,
-        sourceCode,
-        map,
-        reserved,
-      ));
-    }
-
-    const {functionMap} = transformResult;
-
-    return {
-      dependencies,
-      output: [
-        {data: {code, lineCount: countLines(code), map, functionMap}, type},
-      ],
-    };
-  }
-
-  async _minifyCode(
-    filename: string,
-    code: string,
-    source: string,
-    map: Array<MetroSourceMapSegmentTuple>,
-    reserved?: $ReadOnlyArray<string> = [],
-  ): Promise<{code: string, map: Array<MetroSourceMapSegmentTuple>}> {
-    const sourceMap = fromRawMappings([
-      {code, source, map, functionMap: null, path: filename},
-    ]).toMap(undefined, {});
-
-    const minify = getMinifier(this._config.minifierPath);
-
-    try {
-      const minified = minify({
-        code,
-        map: sourceMap,
-        filename,
-        reserved,
-        config: this._config.minifierConfig,
-      });
-
-      return {
-        code: minified.code,
-        map: minified.map
-          ? toBabelSegments(minified.map).map(toSegmentTuple)
-          : [],
-      };
-    } catch (error) {
-      if (error.constructor.name === 'JS_Parse_Error') {
-        throw new Error(
-          `${error.message} in file ${filename} at ${error.line}:${error.col}`,
-        );
-      }
-
-      throw error;
-    }
-  }
-
-  getCacheKey(): string {
-    const {babelTransformerPath, minifierPath, ...config} = this._config;
-
-    const filesKey = getKeyFromFiles([
-      require.resolve(babelTransformerPath),
-      require.resolve(minifierPath),
-      require.resolve('../ModuleGraph/worker/JsFileWrapping'),
-      require.resolve('../assetTransformer'),
-      require.resolve('../ModuleGraph/worker/collectDependencies'),
-      require.resolve('./worker/constant-folding-plugin'),
-      require.resolve('../lib/getMinifier'),
-      require.resolve('./worker/inline-plugin'),
-      require.resolve('./worker/import-export-plugin'),
-      require.resolve('./worker/normalizePseudoglobals'),
-      require.resolve('../ModuleGraph/worker/optimizeDependencies'),
-      require.resolve('../ModuleGraph/worker/generateImportNames'),
-    ]);
-
-    const babelTransformer = require(babelTransformerPath);
-    const babelTransformerKey = babelTransformer.getCacheKey
-      ? babelTransformer.getCacheKey()
-      : '';
-
-    return [
-      filesKey,
-      stableHash(config).toString('hex'),
-      babelTransformerKey,
-    ].join('$');
-  }
-}
-
-class InvalidRequireCallError extends Error {
-  innerError: collectDependencies.InvalidRequireCallError;
-  filename: string;
-
-  constructor(
-    innerError: collectDependencies.InvalidRequireCallError,
-    filename: string,
-  ) {
-    super(`${filename}:${innerError.message}`);
-    this.innerError = innerError;
-    this.filename = filename;
-  }
-}
-
-module.exports = JsTransformer;
diff --git a/node_modules/metro/src/JSTransformer/worker/constant-folding-plugin.js b/node_modules/metro/src/JSTransformer/worker/constant-folding-plugin.js
deleted file mode 100644
index 8ab5a70..0000000
--- a/node_modules/metro/src/JSTransformer/worker/constant-folding-plugin.js
+++ /dev/null
@@ -1,191 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-function _objectSpread(target) {
-  for (var i = 1; i < arguments.length; i++) {
-    var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
-    }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
-  }
-  return target;
-}
-
-function _defineProperty(obj, key, value) {
-  if (key in obj) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-  } else {
-    obj[key] = value;
-  }
-  return obj;
-}
-
-function constantFoldingPlugin(context) {
-  const t = context.types;
-
-  const evaluate = function(path) {
-    const state = {
-      safe: true
-    };
-
-    const unsafe = (path, state) => (state.safe = false);
-
-    path.traverse(
-      {
-        CallExpression: unsafe,
-        AssignmentExpression: unsafe
-      },
-      state
-    );
-
-    try {
-      return state.safe
-        ? path.evaluate()
-        : {
-            confident: false,
-            value: null
-          };
-    } catch (err) {
-      return {
-        confident: false,
-        value: null
-      };
-    }
-  };
-
-  const FunctionDeclaration = {
-    exit(path, state) {
-      const binding =
-        path.node.id !== null && path.scope.getBinding(path.node.id.name);
-
-      if (binding && !binding.referenced) {
-        state.stripped = true;
-        path.remove();
-      }
-    }
-  };
-  const FunctionExpression = {
-    exit(path, state) {
-      const parentPath = path.parentPath;
-
-      if (t.isVariableDeclarator(parentPath)) {
-        const binding = parentPath.scope.getBinding(parentPath.node.id.name);
-
-        if (binding && !binding.referenced) {
-          state.stripped = true;
-          parentPath.remove();
-        }
-      }
-    }
-  };
-  const Conditional = {
-    exit(path, state) {
-      const node = path.node;
-      const result = evaluate(path.get("test"));
-
-      if (result.confident) {
-        state.stripped = true;
-
-        if (result.value || node.alternate) {
-          path.replaceWith(result.value ? node.consequent : node.alternate);
-        } else if (!result.value) {
-          path.remove();
-        }
-      }
-    }
-  };
-  const Expression = {
-    exit(path) {
-      const result = evaluate(path);
-
-      if (result.confident) {
-        path.replaceWith(t.valueToNode(result.value));
-        path.skip();
-      }
-    }
-  };
-  const LogicalExpression = {
-    exit(path) {
-      const node = path.node;
-      const result = evaluate(path.get("left"));
-
-      if (result.confident) {
-        const value = result.value;
-
-        switch (node.operator) {
-          case "||":
-            path.replaceWith(value ? node.left : node.right);
-            break;
-
-          case "&&":
-            path.replaceWith(value ? node.right : node.left);
-            break;
-
-          case "??":
-            path.replaceWith(value == null ? node.right : node.left);
-            break;
-        }
-      }
-    }
-  };
-  const Program = {
-    enter(path, state) {
-      state.stripped = false;
-    },
-
-    exit(path, state) {
-      path.traverse(
-        {
-          ArrowFunctionExpression: FunctionExpression,
-          ConditionalExpression: Conditional,
-          FunctionDeclaration,
-          FunctionExpression,
-          IfStatement: Conditional
-        },
-        state
-      );
-
-      if (state.stripped) {
-        path.scope.crawl(); // Re-traverse all program, if we removed any blocks. Manually re-call
-        // enter and exit, because traversing a Program node won't call them.
-
-        Program.enter(path, state);
-        path.traverse(visitor);
-        Program.exit(path, state);
-      }
-    }
-  };
-  const visitor = {
-    BinaryExpression: Expression,
-    LogicalExpression,
-    Program: _objectSpread({}, Program),
-    // Babel mutates objects passed.
-    UnaryExpression: Expression
-  };
-  return {
-    visitor
-  };
-}
-
-module.exports = constantFoldingPlugin;
diff --git a/node_modules/metro/src/JSTransformer/worker/constant-folding-plugin.js.flow b/node_modules/metro/src/JSTransformer/worker/constant-folding-plugin.js.flow
deleted file mode 100644
index 8ee69ad..0000000
--- a/node_modules/metro/src/JSTransformer/worker/constant-folding-plugin.js.flow
+++ /dev/null
@@ -1,156 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-import typeof {types as BabelTypes} from '@babel/core';
-
-function constantFoldingPlugin(context: {types: BabelTypes}) {
-  const t = context.types;
-
-  const evaluate = function(path: Object) {
-    const state = {safe: true};
-    const unsafe = (path: Object, state: Object) => (state.safe = false);
-
-    path.traverse(
-      {
-        CallExpression: unsafe,
-        AssignmentExpression: unsafe,
-      },
-      state,
-    );
-
-    try {
-      return state.safe ? path.evaluate() : {confident: false, value: null};
-    } catch (err) {
-      return {confident: false, value: null};
-    }
-  };
-
-  const FunctionDeclaration = {
-    exit(path: Object, state: Object): void {
-      const binding =
-        path.node.id !== null && path.scope.getBinding(path.node.id.name);
-
-      if (binding && !binding.referenced) {
-        state.stripped = true;
-        path.remove();
-      }
-    },
-  };
-
-  const FunctionExpression = {
-    exit(path: Object, state: Object): void {
-      const parentPath = path.parentPath;
-
-      if (t.isVariableDeclarator(parentPath)) {
-        const binding = parentPath.scope.getBinding(parentPath.node.id.name);
-
-        if (binding && !binding.referenced) {
-          state.stripped = true;
-          parentPath.remove();
-        }
-      }
-    },
-  };
-
-  const Conditional = {
-    exit(path: Object, state: Object): void {
-      const node = path.node;
-      const result = evaluate(path.get('test'));
-
-      if (result.confident) {
-        state.stripped = true;
-
-        if (result.value || node.alternate) {
-          path.replaceWith(result.value ? node.consequent : node.alternate);
-        } else if (!result.value) {
-          path.remove();
-        }
-      }
-    },
-  };
-
-  const Expression = {
-    exit(path: Object): void {
-      const result = evaluate(path);
-
-      if (result.confident) {
-        path.replaceWith(t.valueToNode(result.value));
-        path.skip();
-      }
-    },
-  };
-
-  const LogicalExpression = {
-    exit(path: Object): void {
-      const node = path.node;
-      const result = evaluate(path.get('left'));
-
-      if (result.confident) {
-        const value = result.value;
-
-        switch (node.operator) {
-          case '||':
-            path.replaceWith(value ? node.left : node.right);
-            break;
-
-          case '&&':
-            path.replaceWith(value ? node.right : node.left);
-            break;
-
-          case '??':
-            path.replaceWith(value == null ? node.right : node.left);
-            break;
-        }
-      }
-    },
-  };
-
-  const Program = {
-    enter(path: Object, state: Object): void {
-      state.stripped = false;
-    },
-
-    exit(path: Object, state: Object): void {
-      path.traverse(
-        {
-          ArrowFunctionExpression: FunctionExpression,
-          ConditionalExpression: Conditional,
-          FunctionDeclaration,
-          FunctionExpression,
-          IfStatement: Conditional,
-        },
-        state,
-      );
-
-      if (state.stripped) {
-        path.scope.crawl();
-
-        // Re-traverse all program, if we removed any blocks. Manually re-call
-        // enter and exit, because traversing a Program node won't call them.
-        Program.enter(path, state);
-        path.traverse(visitor);
-        Program.exit(path, state);
-      }
-    },
-  };
-
-  const visitor = {
-    BinaryExpression: Expression,
-    LogicalExpression,
-    Program: {...Program}, // Babel mutates objects passed.
-    UnaryExpression: Expression,
-  };
-
-  return {visitor};
-}
-
-module.exports = constantFoldingPlugin;
diff --git a/node_modules/metro/src/JSTransformer/worker/import-export-plugin.js b/node_modules/metro/src/JSTransformer/worker/import-export-plugin.js
deleted file mode 100644
index 24a7977..0000000
--- a/node_modules/metro/src/JSTransformer/worker/import-export-plugin.js
+++ /dev/null
@@ -1,413 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict
- * @format
- */
-"use strict";
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
-
-function _toConsumableArray(arr) {
-  return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
-  );
-}
-
-function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
-}
-
-function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
-    return Array.from(iter);
-}
-
-function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
-}
-
-const template = require("@babel/template").default;
-
-/**
- * Produces a Babel template that transforms an "import * as x from ..." or an
- * "import x from ..." call into a "const x = importAll(...)" call with the
- * corresponding id in it.
- */
-const importTemplate = template(`
-  var LOCAL = IMPORT(FILE);
-`);
-/**
- * Produces a Babel template that transforms an "import {x as y} from ..." into
- * "const y = require(...).x" call with the corresponding id in it.
- */
-
-const importNamedTemplate = template(`
-  var LOCAL = require(FILE).REMOTE;
-`);
-/**
- * Produces a Babel template that transforms an "import ..." into
- * "require(...)", which is considered a side-effect call.
- */
-
-const importSideEffectTemplate = template(`
-  require(FILE);
-`);
-/**
- * Produces an "export all" template that traverses all exported symbols and
- * re-exposes them.
- */
-
-const exportAllTemplate = template(`
-  var REQUIRED = require(FILE);
-
-  for (var KEY in REQUIRED) {
-    exports[KEY] = REQUIRED[KEY];
-  }
-`);
-/**
- * Produces a "named export" or "default export" template to export a single
- * symbol.
- */
-
-const exportTemplate = template(`
-  exports.REMOTE = LOCAL;
-`);
-/**
- * Flags the exported module as a transpiled ES module. Needs to be kept in 1:1
- * compatibility with Babel.
- */
-
-const esModuleExportTemplate = template(`
-  Object.defineProperty(exports, '__esModule', {value: true});
-`);
-/**
- * Resolution template in case it is requested.
- */
-
-const resolveTemplate = template.expression(`
-  require.resolve(NODE)
-`);
-/**
- * Enforces the resolution of a path to a fully-qualified one, if set.
- */
-
-function resolvePath(node, resolve) {
-  if (!resolve) {
-    return node;
-  }
-
-  return resolveTemplate({
-    NODE: node
-  });
-} // eslint-disable-next-line lint/flow-no-fixme
-
-function importExportPlugin(_ref) {
-  let t = _ref.types;
-  return {
-    visitor: {
-      ExportAllDeclaration(path, state) {
-        if (path.node.exportKind && path.node.exportKind !== "value") {
-          return;
-        }
-
-        state.exportAll.push({
-          file: path.get("source").node.value
-        });
-        path.remove();
-      },
-
-      ExportDefaultDeclaration(path, state) {
-        if (path.node.exportKind && path.node.exportKind !== "value") {
-          return;
-        }
-
-        const declaration = path.get("declaration");
-        const node = declaration.node;
-        const id = node.id || path.scope.generateUidIdentifier("default");
-        node.id = id;
-        state.exportDefault.push({
-          local: id.name
-        });
-
-        if (t.isDeclaration(declaration)) {
-          path.insertBefore(node);
-        } else {
-          path.insertBefore(
-            t.variableDeclaration("var", [t.variableDeclarator(id, node)])
-          );
-        }
-
-        path.remove();
-      },
-
-      ExportNamedDeclaration(path, state) {
-        if (path.node.exportKind && path.node.exportKind !== "value") {
-          return;
-        }
-
-        const declaration = path.get("declaration");
-        const specifiers = path.get("specifiers");
-
-        if (declaration.node) {
-          if (t.isVariableDeclaration(declaration)) {
-            declaration.get("declarations").forEach(d => {
-              switch (d.get("id").node.type) {
-                case "ObjectPattern":
-                  {
-                    const properties = d.get("id").get("properties");
-                    properties.forEach(p => {
-                      const name = p.get("key").node.name;
-                      state.exportNamed.push({
-                        local: name,
-                        remote: name
-                      });
-                    });
-                  }
-                  break;
-
-                case "ArrayPattern":
-                  {
-                    const elements = d.get("id").get("elements");
-                    elements.forEach(e => {
-                      const name = e.node.name;
-                      state.exportNamed.push({
-                        local: name,
-                        remote: name
-                      });
-                    });
-                  }
-                  break;
-
-                default:
-                  {
-                    const name = d.get("id").node.name;
-                    state.exportNamed.push({
-                      local: name,
-                      remote: name
-                    });
-                  }
-                  break;
-              }
-            });
-          } else {
-            const id =
-              declaration.node.id || path.scope.generateUidIdentifier();
-            const name = id.name;
-            declaration.node.id = id;
-            state.exportNamed.push({
-              local: name,
-              remote: name
-            });
-          }
-
-          path.insertBefore(declaration.node);
-        }
-
-        if (specifiers) {
-          specifiers.forEach(s => {
-            const local = s.node.local;
-            const remote = s.node.exported;
-
-            if (path.node.source) {
-              const temp = path.scope.generateUidIdentifier(local.name);
-
-              if (local.name === "default") {
-                path.insertBefore(
-                  importTemplate({
-                    IMPORT: state.importDefault,
-                    FILE: resolvePath(path.node.source, state.opts.resolve),
-                    LOCAL: temp
-                  })
-                );
-                state.exportNamed.push({
-                  local: temp.name,
-                  remote: remote.name
-                });
-              } else if (remote.name === "default") {
-                path.insertBefore(
-                  importNamedTemplate({
-                    FILE: resolvePath(path.node.source, state.opts.resolve),
-                    LOCAL: temp,
-                    REMOTE: local
-                  })
-                );
-                state.exportDefault.push({
-                  local: temp.name
-                });
-              } else {
-                path.insertBefore(
-                  importNamedTemplate({
-                    FILE: resolvePath(path.node.source, state.opts.resolve),
-                    LOCAL: temp,
-                    REMOTE: local
-                  })
-                );
-                state.exportNamed.push({
-                  local: temp.name,
-                  remote: remote.name
-                });
-              }
-            } else {
-              if (remote.name === "default") {
-                state.exportDefault.push({
-                  local: local.name
-                });
-              } else {
-                state.exportNamed.push({
-                  local: local.name,
-                  remote: remote.name
-                });
-              }
-            }
-          });
-        }
-
-        path.remove();
-      },
-
-      ImportDeclaration(path, state) {
-        if (path.node.importKind && path.node.importKind !== "value") {
-          return;
-        }
-
-        const file = path.get("source").node;
-        const specifiers = path.get("specifiers");
-        const anchor = path.scope.path.get("body.0");
-
-        if (!specifiers.length) {
-          anchor.insertBefore(
-            importSideEffectTemplate({
-              FILE: resolvePath(file, state.opts.resolve)
-            })
-          );
-        } else {
-          path.get("specifiers").forEach(s => {
-            const imported = s.get("imported").node;
-            const local = s.get("local").node;
-
-            switch (s.node.type) {
-              case "ImportNamespaceSpecifier":
-                anchor.insertBefore(
-                  importTemplate({
-                    IMPORT: state.importAll,
-                    FILE: resolvePath(file, state.opts.resolve),
-                    LOCAL: local
-                  })
-                );
-                break;
-
-              case "ImportDefaultSpecifier":
-                anchor.insertBefore(
-                  importTemplate({
-                    IMPORT: state.importDefault,
-                    FILE: resolvePath(file, state.opts.resolve),
-                    LOCAL: local
-                  })
-                );
-                break;
-
-              case "ImportSpecifier":
-                if (imported.name === "default") {
-                  anchor.insertBefore(
-                    importTemplate({
-                      IMPORT: state.importDefault,
-                      FILE: resolvePath(file, state.opts.resolve),
-                      LOCAL: local
-                    })
-                  );
-                } else {
-                  anchor.insertBefore(
-                    importNamedTemplate({
-                      FILE: resolvePath(file, state.opts.resolve),
-                      LOCAL: local,
-                      REMOTE: imported
-                    })
-                  );
-                }
-
-                break;
-
-              default:
-                throw new TypeError("Unknown import type: " + s.node.type);
-            }
-          });
-        }
-
-        path.remove();
-      },
-
-      Program: {
-        enter(path, state) {
-          state.exportAll = [];
-          state.exportDefault = [];
-          state.exportNamed = [];
-          state.importAll = t.identifier(state.opts.importAll);
-          state.importDefault = t.identifier(state.opts.importDefault);
-        },
-
-        exit(path, state) {
-          const body = path.node.body;
-          state.exportDefault.forEach(e => {
-            body.push(
-              exportTemplate({
-                LOCAL: t.identifier(e.local),
-                REMOTE: t.identifier("default")
-              })
-            );
-          });
-          state.exportAll.forEach(e => {
-            body.push.apply(
-              body,
-              _toConsumableArray(
-                exportAllTemplate({
-                  FILE: resolvePath(
-                    t.stringLiteral(e.file),
-                    state.opts.resolve
-                  ),
-                  REQUIRED: path.scope.generateUidIdentifier(e.file),
-                  KEY: path.scope.generateUidIdentifier("key")
-                })
-              )
-            );
-          });
-          state.exportNamed.forEach(e => {
-            body.push(
-              exportTemplate({
-                LOCAL: t.identifier(e.local),
-                REMOTE: t.identifier(e.remote)
-              })
-            );
-          });
-
-          if (
-            state.exportDefault.length ||
-            state.exportAll.length ||
-            state.exportNamed.length
-          ) {
-            body.unshift(esModuleExportTemplate());
-
-            if (state.opts.out) {
-              state.opts.out.isESModule = true;
-            }
-          } else if (state.opts.out) {
-            state.opts.out.isESModule = false;
-          }
-        }
-      }
-    }
-  };
-}
-
-module.exports = importExportPlugin;
diff --git a/node_modules/metro/src/JSTransformer/worker/import-export-plugin.js.flow b/node_modules/metro/src/JSTransformer/worker/import-export-plugin.js.flow
deleted file mode 100644
index 4a491fb..0000000
--- a/node_modules/metro/src/JSTransformer/worker/import-export-plugin.js.flow
+++ /dev/null
@@ -1,386 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict
- * @format
- */
-
-'use strict';
-
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
-const template = require('@babel/template').default;
-
-import type {Ast} from '@babel/core';
-import type {Path} from '@babel/traverse';
-
-type State = {
-  exportAll: Array<{file: string}>,
-  exportDefault: Array<{local: string}>,
-  exportNamed: Array<{local: string, remote: string}>,
-
-  importDefault: Ast,
-  importAll: Ast,
-
-  opts: {
-    importDefault: string,
-    importAll: string,
-    resolve: boolean,
-    out?: {isESModule: boolean},
-  },
-};
-
-/**
- * Produces a Babel template that transforms an "import * as x from ..." or an
- * "import x from ..." call into a "const x = importAll(...)" call with the
- * corresponding id in it.
- */
-const importTemplate = template(`
-  var LOCAL = IMPORT(FILE);
-`);
-
-/**
- * Produces a Babel template that transforms an "import {x as y} from ..." into
- * "const y = require(...).x" call with the corresponding id in it.
- */
-const importNamedTemplate = template(`
-  var LOCAL = require(FILE).REMOTE;
-`);
-
-/**
- * Produces a Babel template that transforms an "import ..." into
- * "require(...)", which is considered a side-effect call.
- */
-const importSideEffectTemplate = template(`
-  require(FILE);
-`);
-
-/**
- * Produces an "export all" template that traverses all exported symbols and
- * re-exposes them.
- */
-const exportAllTemplate = template(`
-  var REQUIRED = require(FILE);
-
-  for (var KEY in REQUIRED) {
-    exports[KEY] = REQUIRED[KEY];
-  }
-`);
-
-/**
- * Produces a "named export" or "default export" template to export a single
- * symbol.
- */
-const exportTemplate = template(`
-  exports.REMOTE = LOCAL;
-`);
-
-/**
- * Flags the exported module as a transpiled ES module. Needs to be kept in 1:1
- * compatibility with Babel.
- */
-const esModuleExportTemplate = template(`
-  Object.defineProperty(exports, '__esModule', {value: true});
-`);
-
-/**
- * Resolution template in case it is requested.
- */
-const resolveTemplate = template.expression(`
-  require.resolve(NODE)
-`);
-
-/**
- * Enforces the resolution of a path to a fully-qualified one, if set.
- */
-function resolvePath(node: {value: string}, resolve: boolean) {
-  if (!resolve) {
-    return node;
-  }
-
-  return resolveTemplate({
-    NODE: node,
-  });
-}
-
-// eslint-disable-next-line lint/flow-no-fixme
-function importExportPlugin({types: t}: $FlowFixMe) {
-  return {
-    visitor: {
-      ExportAllDeclaration(path: Path, state: State): void {
-        if (path.node.exportKind && path.node.exportKind !== 'value') {
-          return;
-        }
-
-        state.exportAll.push({
-          file: path.get('source').node.value,
-        });
-
-        path.remove();
-      },
-
-      ExportDefaultDeclaration(path: Path, state: State): void {
-        if (path.node.exportKind && path.node.exportKind !== 'value') {
-          return;
-        }
-
-        const declaration = path.get('declaration');
-        const node = declaration.node;
-        const id = node.id || path.scope.generateUidIdentifier('default');
-
-        node.id = id;
-
-        state.exportDefault.push({
-          local: id.name,
-        });
-
-        if (t.isDeclaration(declaration)) {
-          path.insertBefore(node);
-        } else {
-          path.insertBefore(
-            t.variableDeclaration('var', [t.variableDeclarator(id, node)]),
-          );
-        }
-
-        path.remove();
-      },
-
-      ExportNamedDeclaration(path: Path, state: State): void {
-        if (path.node.exportKind && path.node.exportKind !== 'value') {
-          return;
-        }
-
-        const declaration = path.get('declaration');
-        const specifiers = path.get('specifiers');
-
-        if (declaration.node) {
-          if (t.isVariableDeclaration(declaration)) {
-            declaration.get('declarations').forEach(d => {
-              switch (d.get('id').node.type) {
-                case 'ObjectPattern':
-                  {
-                    const properties = d.get('id').get('properties');
-                    properties.forEach(p => {
-                      const name = p.get('key').node.name;
-                      state.exportNamed.push({local: name, remote: name});
-                    });
-                  }
-                  break;
-                case 'ArrayPattern':
-                  {
-                    const elements = d.get('id').get('elements');
-                    elements.forEach(e => {
-                      const name = e.node.name;
-                      state.exportNamed.push({local: name, remote: name});
-                    });
-                  }
-                  break;
-                default:
-                  {
-                    const name = d.get('id').node.name;
-                    state.exportNamed.push({local: name, remote: name});
-                  }
-                  break;
-              }
-            });
-          } else {
-            const id =
-              declaration.node.id || path.scope.generateUidIdentifier();
-            const name = id.name;
-
-            declaration.node.id = id;
-            state.exportNamed.push({local: name, remote: name});
-          }
-
-          path.insertBefore(declaration.node);
-        }
-
-        if (specifiers) {
-          specifiers.forEach(s => {
-            const local = s.node.local;
-            const remote = s.node.exported;
-
-            if (path.node.source) {
-              const temp = path.scope.generateUidIdentifier(local.name);
-
-              if (local.name === 'default') {
-                path.insertBefore(
-                  importTemplate({
-                    IMPORT: state.importDefault,
-                    FILE: resolvePath(path.node.source, state.opts.resolve),
-                    LOCAL: temp,
-                  }),
-                );
-
-                state.exportNamed.push({local: temp.name, remote: remote.name});
-              } else if (remote.name === 'default') {
-                path.insertBefore(
-                  importNamedTemplate({
-                    FILE: resolvePath(path.node.source, state.opts.resolve),
-                    LOCAL: temp,
-                    REMOTE: local,
-                  }),
-                );
-
-                state.exportDefault.push({local: temp.name});
-              } else {
-                path.insertBefore(
-                  importNamedTemplate({
-                    FILE: resolvePath(path.node.source, state.opts.resolve),
-                    LOCAL: temp,
-                    REMOTE: local,
-                  }),
-                );
-
-                state.exportNamed.push({local: temp.name, remote: remote.name});
-              }
-            } else {
-              if (remote.name === 'default') {
-                state.exportDefault.push({local: local.name});
-              } else {
-                state.exportNamed.push({
-                  local: local.name,
-                  remote: remote.name,
-                });
-              }
-            }
-          });
-        }
-
-        path.remove();
-      },
-
-      ImportDeclaration(path: Path, state: State): void {
-        if (path.node.importKind && path.node.importKind !== 'value') {
-          return;
-        }
-
-        const file = path.get('source').node;
-        const specifiers = path.get('specifiers');
-        const anchor = path.scope.path.get('body.0');
-
-        if (!specifiers.length) {
-          anchor.insertBefore(
-            importSideEffectTemplate({
-              FILE: resolvePath(file, state.opts.resolve),
-            }),
-          );
-        } else {
-          path.get('specifiers').forEach(s => {
-            const imported = s.get('imported').node;
-            const local = s.get('local').node;
-
-            switch (s.node.type) {
-              case 'ImportNamespaceSpecifier':
-                anchor.insertBefore(
-                  importTemplate({
-                    IMPORT: state.importAll,
-                    FILE: resolvePath(file, state.opts.resolve),
-                    LOCAL: local,
-                  }),
-                );
-                break;
-
-              case 'ImportDefaultSpecifier':
-                anchor.insertBefore(
-                  importTemplate({
-                    IMPORT: state.importDefault,
-                    FILE: resolvePath(file, state.opts.resolve),
-                    LOCAL: local,
-                  }),
-                );
-                break;
-
-              case 'ImportSpecifier':
-                if (imported.name === 'default') {
-                  anchor.insertBefore(
-                    importTemplate({
-                      IMPORT: state.importDefault,
-                      FILE: resolvePath(file, state.opts.resolve),
-                      LOCAL: local,
-                    }),
-                  );
-                } else {
-                  anchor.insertBefore(
-                    importNamedTemplate({
-                      FILE: resolvePath(file, state.opts.resolve),
-                      LOCAL: local,
-                      REMOTE: imported,
-                    }),
-                  );
-                }
-                break;
-
-              default:
-                throw new TypeError('Unknown import type: ' + s.node.type);
-            }
-          });
-        }
-
-        path.remove();
-      },
-
-      Program: {
-        enter(path: Path, state: State): void {
-          state.exportAll = [];
-          state.exportDefault = [];
-          state.exportNamed = [];
-
-          state.importAll = t.identifier(state.opts.importAll);
-          state.importDefault = t.identifier(state.opts.importDefault);
-        },
-
-        exit(path: Path, state: State): void {
-          const body = path.node.body;
-
-          state.exportDefault.forEach((e: {local: string}) => {
-            body.push(
-              exportTemplate({
-                LOCAL: t.identifier(e.local),
-                REMOTE: t.identifier('default'),
-              }),
-            );
-          });
-
-          state.exportAll.forEach((e: {file: string}) => {
-            body.push(
-              ...exportAllTemplate({
-                FILE: resolvePath(t.stringLiteral(e.file), state.opts.resolve),
-                REQUIRED: path.scope.generateUidIdentifier(e.file),
-                KEY: path.scope.generateUidIdentifier('key'),
-              }),
-            );
-          });
-
-          state.exportNamed.forEach((e: {local: string, remote: string}) => {
-            body.push(
-              exportTemplate({
-                LOCAL: t.identifier(e.local),
-                REMOTE: t.identifier(e.remote),
-              }),
-            );
-          });
-
-          if (
-            state.exportDefault.length ||
-            state.exportAll.length ||
-            state.exportNamed.length
-          ) {
-            body.unshift(esModuleExportTemplate());
-            if (state.opts.out) {
-              state.opts.out.isESModule = true;
-            }
-          } else if (state.opts.out) {
-            state.opts.out.isESModule = false;
-          }
-        },
-      },
-    },
-  };
-}
-
-module.exports = importExportPlugin;
diff --git a/node_modules/metro/src/JSTransformer/worker/inline-platform.js b/node_modules/metro/src/JSTransformer/worker/inline-platform.js
deleted file mode 100644
index 05e4992..0000000
--- a/node_modules/metro/src/JSTransformer/worker/inline-platform.js
+++ /dev/null
@@ -1,152 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-const importMap = new Map([["ReactNative", "react-native"]]);
-
-function createInlinePlatformChecks(t) {
-  let requireName =
-    arguments.length > 1 && arguments[1] !== undefined
-      ? arguments[1]
-      : "require";
-
-  const isPlatformNode = (node, scope, isWrappedModule) =>
-    isPlatformOS(node, scope, isWrappedModule) ||
-    isReactPlatformOS(node, scope, isWrappedModule);
-
-  const isPlatformSelectNode = (node, scope, isWrappedModule) =>
-    isPlatformSelect(node, scope, isWrappedModule) ||
-    isReactPlatformSelect(node, scope, isWrappedModule);
-
-  const isPlatformOS = (node, scope, isWrappedModule) =>
-    t.isIdentifier(node.property, {
-      name: "OS"
-    }) &&
-    isImportOrGlobal(
-      node.object,
-      scope,
-      [
-        {
-          name: "Platform"
-        }
-      ],
-      isWrappedModule
-    );
-
-  const isReactPlatformOS = (node, scope, isWrappedModule) =>
-    t.isIdentifier(node.property, {
-      name: "OS"
-    }) &&
-    t.isMemberExpression(node.object) &&
-    t.isIdentifier(node.object.property, {
-      name: "Platform"
-    }) &&
-    isImportOrGlobal(
-      node.object.object,
-      scope,
-      [
-        {
-          name: "React"
-        },
-        {
-          name: "ReactNative"
-        }
-      ],
-      isWrappedModule
-    );
-
-  const isPlatformSelect = (node, scope, isWrappedModule) =>
-    t.isMemberExpression(node.callee) &&
-    t.isIdentifier(node.callee.property, {
-      name: "select"
-    }) &&
-    isImportOrGlobal(
-      node.callee.object,
-      scope,
-      [
-        {
-          name: "Platform"
-        }
-      ],
-      isWrappedModule
-    );
-
-  const isReactPlatformSelect = (node, scope, isWrappedModule) =>
-    t.isMemberExpression(node.callee) &&
-    t.isIdentifier(node.callee.property, {
-      name: "select"
-    }) &&
-    t.isMemberExpression(node.callee.object) &&
-    t.isIdentifier(node.callee.object.property, {
-      name: "Platform"
-    }) &&
-    isImportOrGlobal(
-      node.callee.object.object,
-      scope,
-      [
-        {
-          name: "React"
-        },
-        {
-          name: "ReactNative"
-        }
-      ],
-      isWrappedModule
-    );
-
-  const isGlobal = binding => !binding;
-
-  const isRequireCall = (node, dependencyId, scope) =>
-    t.isCallExpression(node) &&
-    t.isIdentifier(node.callee, {
-      name: requireName
-    }) &&
-    checkRequireArgs(node.arguments, dependencyId);
-
-  const isImport = (node, scope, patterns) =>
-    patterns.some(pattern => {
-      const importName = importMap.get(pattern.name) || pattern.name;
-      return isRequireCall(node, importName, scope);
-    });
-
-  const isImportOrGlobal = (node, scope, patterns, isWrappedModule) => {
-    const identifier = patterns.find(pattern => t.isIdentifier(node, pattern));
-    return (
-      (!!identifier &&
-        isToplevelBinding(
-          scope.getBinding(identifier.name),
-          isWrappedModule
-        )) ||
-      isImport(node, scope, patterns)
-    );
-  };
-
-  const checkRequireArgs = (args, dependencyId) => {
-    const pattern = t.stringLiteral(dependencyId);
-    return (
-      t.isStringLiteral(args[0], pattern) ||
-      (t.isMemberExpression(args[0]) &&
-        t.isNumericLiteral(args[0].property) &&
-        t.isStringLiteral(args[1], pattern))
-    );
-  };
-
-  const isToplevelBinding = (binding, isWrappedModule) =>
-    isGlobal(binding) ||
-    !binding.scope.parent ||
-    (isWrappedModule && !binding.scope.parent.parent);
-
-  return {
-    isPlatformNode,
-    isPlatformSelectNode
-  };
-}
-
-module.exports = createInlinePlatformChecks;
diff --git a/node_modules/metro/src/JSTransformer/worker/inline-platform.js.flow b/node_modules/metro/src/JSTransformer/worker/inline-platform.js.flow
deleted file mode 100644
index 711c447..0000000
--- a/node_modules/metro/src/JSTransformer/worker/inline-platform.js.flow
+++ /dev/null
@@ -1,131 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-import typeof {types as BabelTypes} from '@babel/core';
-
-const importMap = new Map([['ReactNative', 'react-native']]);
-
-function createInlinePlatformChecks(
-  t: BabelTypes,
-  requireName: string = 'require',
-) {
-  const isPlatformNode = (
-    node: Object,
-    scope: Object,
-    isWrappedModule: boolean,
-  ): boolean =>
-    isPlatformOS(node, scope, isWrappedModule) ||
-    isReactPlatformOS(node, scope, isWrappedModule);
-
-  const isPlatformSelectNode = (
-    node: Object,
-    scope: Object,
-    isWrappedModule: boolean,
-  ): boolean =>
-    isPlatformSelect(node, scope, isWrappedModule) ||
-    isReactPlatformSelect(node, scope, isWrappedModule);
-
-  const isPlatformOS = (node, scope, isWrappedModule: boolean): boolean =>
-    t.isIdentifier(node.property, {name: 'OS'}) &&
-    isImportOrGlobal(node.object, scope, [{name: 'Platform'}], isWrappedModule);
-
-  const isReactPlatformOS = (node, scope, isWrappedModule: boolean): boolean =>
-    t.isIdentifier(node.property, {name: 'OS'}) &&
-    t.isMemberExpression(node.object) &&
-    t.isIdentifier(node.object.property, {name: 'Platform'}) &&
-    isImportOrGlobal(
-      node.object.object,
-      scope,
-      [{name: 'React'}, {name: 'ReactNative'}],
-      isWrappedModule,
-    );
-
-  const isPlatformSelect = (node, scope, isWrappedModule: boolean): boolean =>
-    t.isMemberExpression(node.callee) &&
-    t.isIdentifier(node.callee.property, {name: 'select'}) &&
-    isImportOrGlobal(
-      node.callee.object,
-      scope,
-      [{name: 'Platform'}],
-      isWrappedModule,
-    );
-
-  const isReactPlatformSelect = (
-    node,
-    scope,
-    isWrappedModule: boolean,
-  ): boolean =>
-    t.isMemberExpression(node.callee) &&
-    t.isIdentifier(node.callee.property, {name: 'select'}) &&
-    t.isMemberExpression(node.callee.object) &&
-    t.isIdentifier(node.callee.object.property, {name: 'Platform'}) &&
-    isImportOrGlobal(
-      node.callee.object.object,
-      scope,
-      [{name: 'React'}, {name: 'ReactNative'}],
-      isWrappedModule,
-    );
-
-  const isGlobal = (binding): boolean => !binding;
-
-  const isRequireCall = (node, dependencyId: string, scope): boolean =>
-    t.isCallExpression(node) &&
-    t.isIdentifier(node.callee, {name: requireName}) &&
-    checkRequireArgs(node.arguments, dependencyId);
-
-  const isImport = (node, scope, patterns: Array<{|name: string|}>): boolean =>
-    patterns.some((pattern: {|name: string|}) => {
-      const importName = importMap.get(pattern.name) || pattern.name;
-      return isRequireCall(node, importName, scope);
-    });
-
-  const isImportOrGlobal = (
-    node,
-    scope,
-    patterns: Array<{|name: string|}>,
-    isWrappedModule: boolean,
-  ): boolean => {
-    const identifier = patterns.find((pattern: {|name: string|}) =>
-      t.isIdentifier(node, pattern),
-    );
-    return (
-      (!!identifier &&
-        isToplevelBinding(
-          scope.getBinding(identifier.name),
-          isWrappedModule,
-        )) ||
-      isImport(node, scope, patterns)
-    );
-  };
-
-  const checkRequireArgs = (args, dependencyId: string): boolean => {
-    const pattern = t.stringLiteral(dependencyId);
-    return (
-      t.isStringLiteral(args[0], pattern) ||
-      (t.isMemberExpression(args[0]) &&
-        t.isNumericLiteral(args[0].property) &&
-        t.isStringLiteral(args[1], pattern))
-    );
-  };
-
-  const isToplevelBinding = (binding, isWrappedModule: boolean): boolean =>
-    isGlobal(binding) ||
-    !binding.scope.parent ||
-    (isWrappedModule && !binding.scope.parent.parent);
-
-  return {
-    isPlatformNode,
-    isPlatformSelectNode,
-  };
-}
-
-module.exports = createInlinePlatformChecks;
diff --git a/node_modules/metro/src/JSTransformer/worker/inline-plugin.js b/node_modules/metro/src/JSTransformer/worker/inline-plugin.js
deleted file mode 100644
index f76481b..0000000
--- a/node_modules/metro/src/JSTransformer/worker/inline-plugin.js
+++ /dev/null
@@ -1,137 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-const createInlinePlatformChecks = require("./inline-platform");
-
-const env = {
-  name: "env"
-};
-const nodeEnv = {
-  name: "NODE_ENV"
-};
-const processId = {
-  name: "process"
-};
-const dev = {
-  name: "__DEV__"
-};
-
-function inlinePlugin(context, options) {
-  const t = context.types;
-
-  const _createInlinePlatform = createInlinePlatformChecks(
-      t,
-      options.requireName || "require"
-    ),
-    isPlatformNode = _createInlinePlatform.isPlatformNode,
-    isPlatformSelectNode = _createInlinePlatform.isPlatformSelectNode;
-
-  const isGlobal = binding => !binding;
-
-  const isFlowDeclared = binding => t.isDeclareVariable(binding.path);
-
-  const isGlobalOrFlowDeclared = binding =>
-    isGlobal(binding) || isFlowDeclared(binding);
-
-  const isLeftHandSideOfAssignmentExpression = (node, parent) =>
-    t.isAssignmentExpression(parent) && parent.left === node;
-
-  const isProcessEnvNodeEnv = (node, scope) =>
-    t.isIdentifier(node.property, nodeEnv) &&
-    t.isMemberExpression(node.object) &&
-    t.isIdentifier(node.object.property, env) &&
-    t.isIdentifier(node.object.object, processId) &&
-    isGlobal(scope.getBinding(processId.name));
-
-  const isDev = (node, parent, scope) =>
-    t.isIdentifier(node, dev) &&
-    isGlobalOrFlowDeclared(scope.getBinding(dev.name)) &&
-    !t.isMemberExpression(parent);
-
-  function findProperty(objectExpression, key, fallback) {
-    const property = objectExpression.properties.find(p => {
-      if (t.isIdentifier(p.key) && p.key.name === key) {
-        return true;
-      }
-
-      if (t.isStringLiteral(p.key) && p.key.value === key) {
-        return true;
-      }
-
-      return false;
-    });
-    return property ? property.value : fallback();
-  }
-
-  function hasStaticProperties(objectExpression) {
-    if (!t.isObjectExpression(objectExpression)) {
-      return false;
-    }
-
-    return objectExpression.properties.every(p => {
-      if (p.computed) {
-        return false;
-      }
-
-      return t.isIdentifier(p.key) || t.isStringLiteral(p.key);
-    });
-  }
-
-  return {
-    visitor: {
-      Identifier(path, state) {
-        if (!state.opts.dev && isDev(path.node, path.parent, path.scope)) {
-          path.replaceWith(t.booleanLiteral(state.opts.dev));
-        }
-      },
-
-      MemberExpression(path, state) {
-        const node = path.node;
-        const scope = path.scope;
-        const opts = state.opts;
-
-        if (!isLeftHandSideOfAssignmentExpression(node, path.parent)) {
-          if (
-            opts.inlinePlatform &&
-            isPlatformNode(node, scope, !!opts.isWrapped)
-          ) {
-            path.replaceWith(t.stringLiteral(opts.platform));
-          } else if (!opts.dev && isProcessEnvNodeEnv(node, scope)) {
-            path.replaceWith(
-              t.stringLiteral(opts.dev ? "development" : "production")
-            );
-          }
-        }
-      },
-
-      CallExpression(path, state) {
-        const node = path.node;
-        const scope = path.scope;
-        const arg = node.arguments[0];
-        const opts = state.opts;
-
-        if (
-          opts.inlinePlatform &&
-          isPlatformSelectNode(node, scope, !!opts.isWrapped)
-        ) {
-          if (hasStaticProperties(arg)) {
-            const fallback = () =>
-              findProperty(arg, "default", () => t.identifier("undefined"));
-
-            path.replaceWith(findProperty(arg, opts.platform, fallback));
-          }
-        }
-      }
-    }
-  };
-}
-
-module.exports = inlinePlugin;
diff --git a/node_modules/metro/src/JSTransformer/worker/inline-plugin.js.flow b/node_modules/metro/src/JSTransformer/worker/inline-plugin.js.flow
deleted file mode 100644
index c2b0e6e..0000000
--- a/node_modules/metro/src/JSTransformer/worker/inline-plugin.js.flow
+++ /dev/null
@@ -1,145 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-const createInlinePlatformChecks = require('./inline-platform');
-
-import typeof {types as BabelTypes} from '@babel/core';
-import type {Ast} from '@babel/core';
-import type {Path} from '@babel/traverse';
-
-type Context = {types: BabelTypes};
-
-type Options = {
-  dev: boolean,
-  inlinePlatform: boolean,
-  isWrapped: boolean,
-  requireName?: string,
-  platform: string,
-};
-
-type State = {
-  opts: Options,
-};
-
-const env = {name: 'env'};
-const nodeEnv = {name: 'NODE_ENV'};
-const processId = {name: 'process'};
-
-const dev = {name: '__DEV__'};
-
-function inlinePlugin(context: Context, options: Options) {
-  const t = context.types;
-
-  const {isPlatformNode, isPlatformSelectNode} = createInlinePlatformChecks(
-    t,
-    options.requireName || 'require',
-  );
-
-  const isGlobal = binding => !binding;
-
-  const isFlowDeclared = binding => t.isDeclareVariable(binding.path);
-
-  const isGlobalOrFlowDeclared = binding =>
-    isGlobal(binding) || isFlowDeclared(binding);
-
-  const isLeftHandSideOfAssignmentExpression = (node: Ast, parent) =>
-    t.isAssignmentExpression(parent) && parent.left === node;
-
-  const isProcessEnvNodeEnv = (node: Ast, scope) =>
-    t.isIdentifier(node.property, nodeEnv) &&
-    t.isMemberExpression(node.object) &&
-    t.isIdentifier(node.object.property, env) &&
-    t.isIdentifier(node.object.object, processId) &&
-    isGlobal(scope.getBinding(processId.name));
-
-  const isDev = (node: Ast, parent, scope) =>
-    t.isIdentifier(node, dev) &&
-    isGlobalOrFlowDeclared(scope.getBinding(dev.name)) &&
-    !t.isMemberExpression(parent);
-
-  function findProperty(objectExpression, key: string, fallback) {
-    const property = objectExpression.properties.find(p => {
-      if (t.isIdentifier(p.key) && p.key.name === key) {
-        return true;
-      }
-
-      if (t.isStringLiteral(p.key) && p.key.value === key) {
-        return true;
-      }
-
-      return false;
-    });
-    return property ? property.value : fallback();
-  }
-
-  function hasStaticProperties(objectExpression): boolean {
-    if (!t.isObjectExpression(objectExpression)) {
-      return false;
-    }
-
-    return objectExpression.properties.every(p => {
-      if (p.computed) {
-        return false;
-      }
-
-      return t.isIdentifier(p.key) || t.isStringLiteral(p.key);
-    });
-  }
-
-  return {
-    visitor: {
-      Identifier(path: Path, state: State): void {
-        if (!state.opts.dev && isDev(path.node, path.parent, path.scope)) {
-          path.replaceWith(t.booleanLiteral(state.opts.dev));
-        }
-      },
-      MemberExpression(path: Path, state: State): void {
-        const node = path.node;
-        const scope = path.scope;
-        const opts = state.opts;
-
-        if (!isLeftHandSideOfAssignmentExpression(node, path.parent)) {
-          if (
-            opts.inlinePlatform &&
-            isPlatformNode(node, scope, !!opts.isWrapped)
-          ) {
-            path.replaceWith(t.stringLiteral(opts.platform));
-          } else if (!opts.dev && isProcessEnvNodeEnv(node, scope)) {
-            path.replaceWith(
-              t.stringLiteral(opts.dev ? 'development' : 'production'),
-            );
-          }
-        }
-      },
-      CallExpression(path: Path, state: State): void {
-        const node = path.node;
-        const scope = path.scope;
-        const arg = node.arguments[0];
-        const opts = state.opts;
-
-        if (
-          opts.inlinePlatform &&
-          isPlatformSelectNode(node, scope, !!opts.isWrapped)
-        ) {
-          if (hasStaticProperties(arg)) {
-            const fallback = () =>
-              findProperty(arg, 'default', () => t.identifier('undefined'));
-
-            path.replaceWith(findProperty(arg, opts.platform, fallback));
-          }
-        }
-      },
-    },
-  };
-}
-
-module.exports = inlinePlugin;
diff --git a/node_modules/metro/src/JSTransformer/worker/normalizePseudoglobals.js b/node_modules/metro/src/JSTransformer/worker/normalizePseudoglobals.js
deleted file mode 100644
index 8685d3f..0000000
--- a/node_modules/metro/src/JSTransformer/worker/normalizePseudoglobals.js
+++ /dev/null
@@ -1,90 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict
- * @format
- */
-"use strict";
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
-
-const traverse = require("@babel/traverse").default;
-
-function normalizePseudoglobals(ast) {
-  let pseudoglobals = [];
-  const reserved = [];
-  let params = null;
-  let body = null;
-  traverse(ast, {
-    Program: {
-      enter(path) {
-        params = path.get("body.0.expression.arguments.0.params");
-        body = path.get("body.0.expression.arguments.0.body");
-
-        if (!body || !(params instanceof Array)) {
-          params = null;
-          body = null;
-          return;
-        }
-
-        pseudoglobals = params.map(path => path.node.name);
-
-        for (let i = 0; i < pseudoglobals.length; i++) {
-          // Try finding letters that are semantically relatable to the name
-          // of the variable given. For instance, in XMLHttpRequest, it will
-          // first match "X", then "H", then "R".
-          const regexp = /^[^A-Za-z]*([A-Za-z])|([A-Z])[a-z]|([A-Z])[A-Z]+$/g;
-          let match;
-
-          while ((match = regexp.exec(pseudoglobals[i]))) {
-            const name = (match[1] || match[2] || match[3] || "").toLowerCase();
-
-            if (!name) {
-              throw new ReferenceError(
-                "Could not identify any valid name for " + pseudoglobals[i]
-              );
-            }
-
-            if (reserved.indexOf(name) === -1) {
-              reserved[i] = name;
-              break;
-            }
-          }
-        }
-
-        if (new Set(reserved).size !== pseudoglobals.length) {
-          throw new ReferenceError(
-            "Shortened variables are not unique: " + reserved.join(", ")
-          );
-        }
-      },
-
-      exit(path) {
-        reserved.forEach((shortName, i) => {
-          if (pseudoglobals[i] && shortName && body && params) {
-            body.scope.rename(pseudoglobals[i], shortName);
-          }
-        });
-      }
-    },
-
-    Scope(path) {
-      path.scope.crawl();
-
-      if (body && params && path.node !== body.node) {
-        reserved.forEach((shortName, i) => {
-          if (pseudoglobals[i] && shortName) {
-            path.scope.rename(shortName, path.scope.generateUid(shortName));
-          }
-        });
-      }
-    }
-  });
-  return reserved;
-}
-
-module.exports = normalizePseudoglobals;
diff --git a/node_modules/metro/src/JSTransformer/worker/normalizePseudoglobals.js.flow b/node_modules/metro/src/JSTransformer/worker/normalizePseudoglobals.js.flow
deleted file mode 100644
index 120ecbf..0000000
--- a/node_modules/metro/src/JSTransformer/worker/normalizePseudoglobals.js.flow
+++ /dev/null
@@ -1,97 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict
- * @format
- */
-
-'use strict';
-
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
-const traverse = require('@babel/traverse').default;
-
-import type {Ast} from '@babel/core';
-import type {Path} from '@babel/traverse';
-
-function normalizePseudoglobals(ast: Ast): $ReadOnlyArray<string> {
-  let pseudoglobals = [];
-  const reserved = [];
-  let params = null;
-  let body = null;
-
-  traverse(ast, {
-    Program: {
-      enter(path: Path): void {
-        params = path.get('body.0.expression.arguments.0.params');
-        body = path.get('body.0.expression.arguments.0.body');
-
-        if (!body || !(params instanceof Array)) {
-          params = null;
-          body = null;
-
-          return;
-        }
-
-        pseudoglobals = params.map(path => path.node.name);
-
-        for (let i = 0; i < pseudoglobals.length; i++) {
-          // Try finding letters that are semantically relatable to the name
-          // of the variable given. For instance, in XMLHttpRequest, it will
-          // first match "X", then "H", then "R".
-          const regexp = /^[^A-Za-z]*([A-Za-z])|([A-Z])[a-z]|([A-Z])[A-Z]+$/g;
-          let match;
-
-          while ((match = regexp.exec(pseudoglobals[i]))) {
-            const name = (match[1] || match[2] || match[3] || '').toLowerCase();
-
-            if (!name) {
-              throw new ReferenceError(
-                'Could not identify any valid name for ' + pseudoglobals[i],
-              );
-            }
-
-            if (reserved.indexOf(name) === -1) {
-              reserved[i] = name;
-              break;
-            }
-          }
-        }
-
-        if (new Set(reserved).size !== pseudoglobals.length) {
-          throw new ReferenceError(
-            'Shortened variables are not unique: ' + reserved.join(', '),
-          );
-        }
-      },
-
-      exit(path: Path): void {
-        reserved.forEach((shortName: string, i: number) => {
-          if (pseudoglobals[i] && shortName && body && params) {
-            body.scope.rename(pseudoglobals[i], shortName);
-          }
-        });
-      },
-    },
-
-    Scope(path: Path): void {
-      path.scope.crawl();
-
-      if (body && params && path.node !== body.node) {
-        reserved.forEach((shortName: string, i: number) => {
-          if (pseudoglobals[i] && shortName) {
-            path.scope.rename(shortName, path.scope.generateUid(shortName));
-          }
-        });
-      }
-    },
-  });
-
-  return reserved;
-}
-
-module.exports = normalizePseudoglobals;
diff --git a/node_modules/metro/src/JSTransformer/worker/test-helpers.js b/node_modules/metro/src/JSTransformer/worker/test-helpers.js
deleted file mode 100644
index 5e8f90e..0000000
--- a/node_modules/metro/src/JSTransformer/worker/test-helpers.js
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @emails oncall+js_foundation
- * @format
- */
-"use strict";
-
-const generate = require("@babel/generator").default;
-
-const _require = require("@babel/core"),
-  transformSync = _require.transformSync;
-
-function transform(code, plugins, options) {
-  const optionsPlugins = plugins.length
-    ? plugins.map(plugin => [plugin, options])
-    : [
-        () => ({
-          visitor: {}
-        })
-      ];
-  const babelOptions = {
-    ast: true,
-    babelrc: false,
-    code: false,
-    compact: true,
-    configFile: false,
-    plugins: optionsPlugins,
-    sourceType: "module"
-  };
-  return generate(transformSync(code, babelOptions).ast).code;
-}
-
-function compare(plugins, code, expected) {
-  let options =
-    arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
-  const result = transform(code, plugins, options);
-  const reference = transform(expected, [], {});
-  expect(result).toBe(reference);
-}
-
-exports.transform = transform;
-exports.compare = compare;
diff --git a/node_modules/metro/src/ModuleGraph/module.js b/node_modules/metro/src/ModuleGraph/module.js
index c31ed28..0cf91bc 100644
--- a/node_modules/metro/src/ModuleGraph/module.js
+++ b/node_modules/metro/src/ModuleGraph/module.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/ModuleGraph/module.js.flow b/node_modules/metro/src/ModuleGraph/module.js.flow
index ab6b501..b9c8320 100644
--- a/node_modules/metro/src/ModuleGraph/module.js.flow
+++ b/node_modules/metro/src/ModuleGraph/module.js.flow
@@ -7,6 +7,7 @@
  * @flow strict-local
  * @format
  */
+
 'use strict';
 
 import type {Module} from './types.flow';
diff --git a/node_modules/metro/src/ModuleGraph/node-haste/HasteFS.js b/node_modules/metro/src/ModuleGraph/node-haste/HasteFS.js
index d28a73b..75ea7a4 100644
--- a/node_modules/metro/src/ModuleGraph/node-haste/HasteFS.js
+++ b/node_modules/metro/src/ModuleGraph/node-haste/HasteFS.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/ModuleGraph/node-haste/HasteFS.js.flow b/node_modules/metro/src/ModuleGraph/node-haste/HasteFS.js.flow
index 92b21ca..7d04ecf 100644
--- a/node_modules/metro/src/ModuleGraph/node-haste/HasteFS.js.flow
+++ b/node_modules/metro/src/ModuleGraph/node-haste/HasteFS.js.flow
@@ -18,6 +18,7 @@ type pathParseResult = {
   base: string,
   ext: string,
   name: string,
+  ...
 };
 
 module.exports = class HasteFS {
diff --git a/node_modules/metro/src/ModuleGraph/node-haste/ModuleCache.js b/node_modules/metro/src/ModuleGraph/node-haste/ModuleCache.js
index eb6bd80..79b6079 100644
--- a/node_modules/metro/src/ModuleGraph/node-haste/ModuleCache.js
+++ b/node_modules/metro/src/ModuleGraph/node-haste/ModuleCache.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/ModuleGraph/node-haste/Package.js b/node_modules/metro/src/ModuleGraph/node-haste/Package.js
index e0c931b..28716c8 100644
--- a/node_modules/metro/src/ModuleGraph/node-haste/Package.js
+++ b/node_modules/metro/src/ModuleGraph/node-haste/Package.js
@@ -9,21 +9,42 @@
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,6 +59,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -156,5 +178,5 @@ function getReplacements(pkg) {
   } // merge with "browser" as default,
   // "react-native" as override
 
-  return _objectSpread({}, browser, rn);
+  return _objectSpread(_objectSpread({}, browser), rn);
 }
diff --git a/node_modules/metro/src/ModuleGraph/node-haste/Package.js.flow b/node_modules/metro/src/ModuleGraph/node-haste/Package.js.flow
index c7fd5dc..3f430b4 100644
--- a/node_modules/metro/src/ModuleGraph/node-haste/Package.js.flow
+++ b/node_modules/metro/src/ModuleGraph/node-haste/Package.js.flow
@@ -57,7 +57,7 @@ module.exports = class Package {
     return !!this.data.name;
   }
 
-  redirectRequire(name: string) {
+  redirectRequire(name: string): any | boolean | string {
     // Copied from node-haste/Package.js
     const replacements = getReplacements(this.data);
 
diff --git a/node_modules/metro/src/ModuleGraph/node-haste/node-haste.flow.js b/node_modules/metro/src/ModuleGraph/node-haste/node-haste.flow.js
index f1036ef..d5a79f0 100644
--- a/node_modules/metro/src/ModuleGraph/node-haste/node-haste.flow.js
+++ b/node_modules/metro/src/ModuleGraph/node-haste/node-haste.flow.js
@@ -9,11 +9,3 @@
  */
 "use strict";
 "use strict";
-
-var _DependencyGraphHelpers = _interopRequireDefault(
-  require("../../node-haste/DependencyGraph/DependencyGraphHelpers")
-);
-
-function _interopRequireDefault(obj) {
-  return obj && obj.__esModule ? obj : { default: obj };
-}
diff --git a/node_modules/metro/src/ModuleGraph/node-haste/node-haste.flow.js.flow b/node_modules/metro/src/ModuleGraph/node-haste/node-haste.flow.js.flow
index c26c5d2..0014314 100644
--- a/node_modules/metro/src/ModuleGraph/node-haste/node-haste.flow.js.flow
+++ b/node_modules/metro/src/ModuleGraph/node-haste/node-haste.flow.js.flow
@@ -7,11 +7,10 @@
  * @flow
  * @format
  */
-'use strict';
 
 'use strict';
 
-import DependencyGraphHelpers from '../../node-haste/DependencyGraph/DependencyGraphHelpers';
+'use strict';
 
 type ModuleID = string;
 export type Path = string;
@@ -26,6 +25,7 @@ export type Module = {
   getName(): ModuleID,
   getPackage(): ?Package,
   isHaste(): Promise<boolean>,
+  ...
 };
 
 export type Package = {
@@ -36,12 +36,14 @@ export type Package = {
   getName(): ModuleID,
   isHaste(): Promise<boolean>,
   redirectRequire(id: ModuleID): Path | false,
+  ...
 };
 
 export type ModuleCache = {
   getModule(path: Path): Module,
   getPackage(path: Path): Package,
   getPackageOf(path: Path): ?Package,
+  ...
 };
 
 export type FastFS = {
@@ -50,21 +52,19 @@ export type FastFS = {
   fileExists(path: Path): boolean,
   getAllFiles(): Array<Path>,
   matches(directory: Path, pattern: RegExp): Array<Path>,
+  ...
 };
 
 type HasteMapOptions = {|
   extensions: Extensions,
   files: Array<string>,
-  helpers: DependencyGraphHelpers,
   moduleCache: ModuleCache,
   platforms: Platforms,
   preferNativePlatform: true,
 |};
 
-/* eslint-disable flowtype/object-type-delimiter */
 declare class HasteMap {
   // node-haste/DependencyGraph/HasteMap.js
   build(): Promise<Object>;
   constructor(options: HasteMapOptions): void;
 }
-/* eslint-enable flowtype/object-type-delimiter */
diff --git a/node_modules/metro/src/ModuleGraph/node-haste/node-haste.js b/node_modules/metro/src/ModuleGraph/node-haste/node-haste.js
index a3e9d20..2108c59 100644
--- a/node_modules/metro/src/ModuleGraph/node-haste/node-haste.js
+++ b/node_modules/metro/src/ModuleGraph/node-haste/node-haste.js
@@ -9,11 +9,47 @@
  */
 "use strict";
 
-const AssetResolutionCache = require("../../node-haste/AssetResolutionCache");
+function _toConsumableArray(arr) {
+  return (
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
+  );
+}
+
+function _nonIterableSpread() {
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _iterableToArray(iter) {
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
+    return Array.from(iter);
+}
+
+function _arrayWithoutHoles(arr) {
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
 
-const DependencyGraphHelpers = require("../../node-haste/DependencyGraph/DependencyGraphHelpers");
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
 
-const FilesByDirNameIndex = require("../../node-haste/FilesByDirNameIndex");
+  return arr2;
+}
 
 const HasteFS = require("./HasteFS");
 
@@ -48,16 +84,18 @@ const NULL_MODULE = {
   getName() {
     throw new Error("not implemented");
   }
-}; // This function maps the ModuleGraph data structure to jest-haste-map's ModuleMap
+};
+const NODE_MODULES = path.sep + "node_modules" + path.sep;
+
+const isNodeModules = file => file.includes(NODE_MODULES); // This function maps the ModuleGraph data structure to jest-haste-map's ModuleMap
 
 const createModuleMap = _ref => {
   let files = _ref.files,
-    helpers = _ref.helpers,
     moduleCache = _ref.moduleCache,
     sourceExts = _ref.sourceExts;
   const map = new Map();
   files.forEach(filePath => {
-    if (helpers.isNodeModulesDir(filePath)) {
+    if (isNodeModules(filePath)) {
       return;
     }
 
@@ -103,6 +141,7 @@ const createModuleMap = _ref => {
 
 exports.createResolveFn = function(options) {
   const assetExts = options.assetExts,
+    assetResolutions = options.assetResolutions,
     extraNodeModules = options.extraNodeModules,
     transformedFiles = options.transformedFiles,
     sourceExts = options.sourceExts,
@@ -119,42 +158,49 @@ exports.createResolveFn = function(options) {
     return result;
   }
 
-  const helpers = new DependencyGraphHelpers({
-    assetExts
-  });
   const hasteFS = new HasteFS(files);
   const moduleCache = new ModuleCache(
     filePath => hasteFS.closest(filePath, "package.json"),
     getTransformedFile
   );
-  const filesByDirNameIndex = new FilesByDirNameIndex(files);
-  const assetResolutionCache = new AssetResolutionCache({
-    assetExtensions: new Set(assetExts),
-    getDirFiles: dirPath => filesByDirNameIndex.getAllFiles(dirPath),
-    platforms
-  });
+  const assetExtensions = new Set(assetExts.map(asset => "." + asset));
+
+  const isAssetFile = file => assetExtensions.has(path.extname(file));
+
   const moduleResolver = new ModuleResolver({
     dirExists: filePath => hasteFS.dirExists(filePath),
     doesFileExist: filePath => hasteFS.exists(filePath),
     extraNodeModules,
-    isAssetFile: filePath => helpers.isAssetFile(filePath),
+    isAssetFile,
     mainFields: options.mainFields,
+    // $FlowFixMe -- error revealed by types-first codemod
     moduleCache,
     moduleMap: new ModuleMap({
       duplicates: new Map(),
       map: createModuleMap({
         files,
-        helpers,
         moduleCache,
         sourceExts
       }),
       mocks: new Map(),
       rootDir: ""
     }),
+    nodeModulesPaths: options.nodeModulesPaths,
     preferNativePlatform: true,
     projectRoot: "",
-    resolveAsset: (dirPath, assetName, platform) =>
-      assetResolutionCache.resolve(dirPath, assetName, platform),
+    resolveAsset: (dirPath, assetName, extension) => {
+      const basePath = dirPath + path.sep + assetName;
+      const assets = [basePath + extension]
+        .concat(
+          _toConsumableArray(
+            assetResolutions.map(
+              resolution => basePath + "@" + resolution + "x" + extension
+            )
+          )
+        )
+        .filter(candidate => hasteFS.exists(candidate));
+      return assets.length ? assets : null;
+    },
     resolveRequest: options.resolveRequest,
     sourceExts
   });
@@ -163,7 +209,8 @@ exports.createResolveFn = function(options) {
       sourcePath != null
         ? new Module(sourcePath, moduleCache, getTransformedFile(sourcePath))
         : NULL_MODULE;
-    const allowHaste = !helpers.isNodeModulesDir(from.path);
+    const allowHaste = !isNodeModules(from.path); // $FlowFixMe -- error revealed by types-first codemod
+
     return moduleResolver.resolveDependency(from, id, allowHaste, platform)
       .path;
   };
diff --git a/node_modules/metro/src/ModuleGraph/node-haste/node-haste.js.flow b/node_modules/metro/src/ModuleGraph/node-haste/node-haste.js.flow
index 8253a48..aa9bf37 100644
--- a/node_modules/metro/src/ModuleGraph/node-haste/node-haste.js.flow
+++ b/node_modules/metro/src/ModuleGraph/node-haste/node-haste.js.flow
@@ -10,9 +10,6 @@
 
 'use strict';
 
-const AssetResolutionCache = require('../../node-haste/AssetResolutionCache');
-const DependencyGraphHelpers = require('../../node-haste/DependencyGraph/DependencyGraphHelpers');
-const FilesByDirNameIndex = require('../../node-haste/FilesByDirNameIndex');
 const HasteFS = require('./HasteFS');
 const Module = require('./Module');
 const ModuleCache = require('./ModuleCache');
@@ -26,19 +23,21 @@ const {
 } = require('../../node-haste/DependencyGraph/ModuleResolution');
 const {ModuleMap} = require('jest-haste-map');
 
-import type {Moduleish} from '../../node-haste/DependencyGraph/ResolutionRequest';
+import type {Moduleish} from '../../node-haste/DependencyGraph/ModuleResolution';
 import type {ResolveFn, TransformedCodeFile} from '../types.flow';
 import type {Extensions, Path} from './node-haste.flow';
 import type {CustomResolver} from 'metro-resolver';
 
 type ResolveOptions = {|
+  +platform: string,
+  +sourceExts: Extensions,
   assetExts: Extensions,
-  extraNodeModules: {[id: string]: string},
+  assetResolutions: $ReadOnlyArray<string>,
+  extraNodeModules: {[id: string]: string, ...},
   mainFields: $ReadOnlyArray<string>,
+  nodeModulesPaths: $ReadOnlyArray<string>,
   resolveRequest?: ?CustomResolver,
-  +sourceExts: Extensions,
-  transformedFiles: {[path: Path]: TransformedCodeFile},
-  +platform: string,
+  transformedFiles: {[path: Path]: TransformedCodeFile, ...},
 |};
 
 const platforms = new Set(defaults.platforms);
@@ -56,12 +55,15 @@ const NULL_MODULE: Moduleish = {
   },
 };
 
+const NODE_MODULES = path.sep + 'node_modules' + path.sep;
+const isNodeModules = file => file.includes(NODE_MODULES);
+
 // This function maps the ModuleGraph data structure to jest-haste-map's ModuleMap
-const createModuleMap = ({files, helpers, moduleCache, sourceExts}) => {
+const createModuleMap = ({files, moduleCache, sourceExts}) => {
   const map = new Map();
 
   files.forEach((filePath: string) => {
-    if (helpers.isNodeModulesDir(filePath)) {
+    if (isNodeModules(filePath)) {
       return;
     }
     let id;
@@ -108,6 +110,7 @@ const createModuleMap = ({files, helpers, moduleCache, sourceExts}) => {
 exports.createResolveFn = function(options: ResolveOptions): ResolveFn {
   const {
     assetExts,
+    assetResolutions,
     extraNodeModules,
     transformedFiles,
     sourceExts,
@@ -122,44 +125,46 @@ exports.createResolveFn = function(options: ResolveOptions): ResolveFn {
     return result;
   }
 
-  const helpers = new DependencyGraphHelpers({
-    assetExts,
-  });
-
   const hasteFS = new HasteFS(files);
   const moduleCache = new ModuleCache(
     (filePath: string) => hasteFS.closest(filePath, 'package.json'),
     getTransformedFile,
   );
 
-  const filesByDirNameIndex = new FilesByDirNameIndex(files);
-  const assetResolutionCache = new AssetResolutionCache({
-    assetExtensions: new Set(assetExts),
-    getDirFiles: (dirPath: string): $ReadOnlyArray<string> =>
-      filesByDirNameIndex.getAllFiles(dirPath),
-    platforms,
-  });
+  const assetExtensions = new Set(assetExts.map(asset => '.' + asset));
+  const isAssetFile = file => assetExtensions.has(path.extname(file));
+
   const moduleResolver = new ModuleResolver({
     dirExists: (filePath: string): boolean => hasteFS.dirExists(filePath),
     doesFileExist: (filePath: string): boolean => hasteFS.exists(filePath),
     extraNodeModules,
-    isAssetFile: (filePath: string): boolean => helpers.isAssetFile(filePath),
+    isAssetFile,
     mainFields: options.mainFields,
+    // $FlowFixMe -- error revealed by types-first codemod
     moduleCache,
     moduleMap: new ModuleMap({
       duplicates: new Map(),
-      map: createModuleMap({files, helpers, moduleCache, sourceExts}),
+      map: createModuleMap({files, moduleCache, sourceExts}),
       mocks: new Map(),
       rootDir: '',
     }),
+    nodeModulesPaths: options.nodeModulesPaths,
     preferNativePlatform: true,
     projectRoot: '',
     resolveAsset: (
       dirPath: string,
       assetName: string,
-      platform: null | string,
-    ): ?$ReadOnlyArray<string> =>
-      assetResolutionCache.resolve(dirPath, assetName, platform),
+      extension: string,
+    ): ?$ReadOnlyArray<string> => {
+      const basePath = dirPath + path.sep + assetName;
+      const assets = [
+        basePath + extension,
+        ...assetResolutions.map(
+          resolution => basePath + '@' + resolution + 'x' + extension,
+        ),
+      ].filter(candidate => hasteFS.exists(candidate));
+      return assets.length ? assets : null;
+    },
     resolveRequest: options.resolveRequest,
     sourceExts,
   });
@@ -169,7 +174,8 @@ exports.createResolveFn = function(options: ResolveOptions): ResolveFn {
       sourcePath != null
         ? new Module(sourcePath, moduleCache, getTransformedFile(sourcePath))
         : NULL_MODULE;
-    const allowHaste = !helpers.isNodeModulesDir(from.path);
+    const allowHaste = !isNodeModules(from.path);
+    // $FlowFixMe -- error revealed by types-first codemod
     return moduleResolver.resolveDependency(from, id, allowHaste, platform)
       .path;
   };
diff --git a/node_modules/metro/src/ModuleGraph/output/indexed-ram-bundle.js b/node_modules/metro/src/ModuleGraph/output/indexed-ram-bundle.js
index 72a0c19..8a89872 100644
--- a/node_modules/metro/src/ModuleGraph/output/indexed-ram-bundle.js
+++ b/node_modules/metro/src/ModuleGraph/output/indexed-ram-bundle.js
@@ -4,26 +4,47 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,50 +59,75 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
 }
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -89,6 +135,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -101,6 +148,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
@@ -125,7 +173,9 @@ const _require3 = require("./util"),
   toModuleTransport = _require3.toModuleTransport;
 
 function asIndexedRamBundle(_ref) {
-  let filename = _ref.filename,
+  let dependencyMapReservedName = _ref.dependencyMapReservedName,
+    filename = _ref.filename,
+    globalPrefix = _ref.globalPrefix,
     idsForPath = _ref.idsForPath,
     modules = _ref.modules,
     preloadedModules = _ref.preloadedModules,
@@ -139,11 +189,16 @@ function asIndexedRamBundle(_ref) {
     startup = _partition2[0],
     deferred = _partition2[1];
 
-  const startupModules = _toConsumableArray(startup).concat(
+  const startupModules = [].concat(
+    _toConsumableArray(startup),
     _toConsumableArray(requireCalls)
   );
-
-  const deferredModules = deferred.map(m => toModuleTransport(m, idsForPath));
+  const deferredModules = deferred.map(m =>
+    toModuleTransport(m, idsForPath, {
+      dependencyMapReservedName,
+      globalPrefix
+    })
+  );
 
   for (const m of deferredModules) {
     invariant(
@@ -164,7 +219,9 @@ function asIndexedRamBundle(_ref) {
       .map(
         m =>
           getModuleCodeAndMap(m, idForPath, {
-            enableIDInlining: true
+            dependencyMapReservedName,
+            enableIDInlining: true,
+            globalPrefix
           }).moduleCode
       )
       .join("\n"),
@@ -178,7 +235,12 @@ function asIndexedRamBundle(_ref) {
       fixWrapperOffset: false,
       lazyModules: deferredModules,
       moduleGroups,
-      startupModules: startupModules.map(m => toModuleTransport(m, idsForPath))
+      startupModules: startupModules.map(m =>
+        toModuleTransport(m, idsForPath, {
+          dependencyMapReservedName,
+          globalPrefix
+        })
+      )
     })
   };
 }
@@ -204,10 +266,14 @@ function* subtree(moduleTransport, moduleTransportsByPath) {
 function createBuilder(preloadedModules, ramGroupHeads) {
   return x =>
     asIndexedRamBundle(
-      _objectSpread({}, x, {
-        preloadedModules,
-        ramGroupHeads
-      })
+      _objectSpread(
+        _objectSpread({}, x),
+        {},
+        {
+          preloadedModules,
+          ramGroupHeads
+        }
+      )
     );
 }
 
diff --git a/node_modules/metro/src/ModuleGraph/output/indexed-ram-bundle.js.flow b/node_modules/metro/src/ModuleGraph/output/indexed-ram-bundle.js.flow
index 0c1ff2c..0fa4e4f 100644
--- a/node_modules/metro/src/ModuleGraph/output/indexed-ram-bundle.js.flow
+++ b/node_modules/metro/src/ModuleGraph/output/indexed-ram-bundle.js.flow
@@ -24,7 +24,9 @@ import type {Module, OutputFn, OutputFnArg} from '../types.flow';
 import type {IndexMap} from 'metro-source-map';
 
 function asIndexedRamBundle({
+  dependencyMapReservedName,
   filename,
+  globalPrefix,
   idsForPath,
   modules,
   preloadedModules,
@@ -35,11 +37,11 @@ function asIndexedRamBundle({
   extraFiles?: Iterable<[string, string | Buffer]>,
   map: IndexMap,
 |} {
-  const idForPath = (x: {path: string}) => idsForPath(x).moduleId;
+  const idForPath = (x: {path: string, ...}) => idsForPath(x).moduleId;
   const [startup, deferred] = partition(modules, preloadedModules);
   const startupModules = [...startup, ...requireCalls];
   const deferredModules = deferred.map((m: Module) =>
-    toModuleTransport(m, idsForPath),
+    toModuleTransport(m, idsForPath, {dependencyMapReservedName, globalPrefix}),
   );
   for (const m of deferredModules) {
     invariant(
@@ -59,8 +61,11 @@ function asIndexedRamBundle({
     startupModules
       .map(
         (m: Module) =>
-          getModuleCodeAndMap(m, idForPath, {enableIDInlining: true})
-            .moduleCode,
+          getModuleCodeAndMap(m, idForPath, {
+            dependencyMapReservedName,
+            enableIDInlining: true,
+            globalPrefix,
+          }).moduleCode,
       )
       .join('\n'),
     deferredModules,
@@ -75,7 +80,10 @@ function asIndexedRamBundle({
       lazyModules: deferredModules,
       moduleGroups,
       startupModules: startupModules.map((m: Module) =>
-        toModuleTransport(m, idsForPath),
+        toModuleTransport(m, idsForPath, {
+          dependencyMapReservedName,
+          globalPrefix,
+        }),
       ),
     }),
   };
diff --git a/node_modules/metro/src/ModuleGraph/output/multiple-files-ram-bundle.js b/node_modules/metro/src/ModuleGraph/output/multiple-files-ram-bundle.js
index b955d07..6dbcae6 100644
--- a/node_modules/metro/src/ModuleGraph/output/multiple-files-ram-bundle.js
+++ b/node_modules/metro/src/ModuleGraph/output/multiple-files-ram-bundle.js
@@ -4,26 +4,47 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,50 +59,75 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
 }
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -89,6 +135,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -101,6 +148,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
@@ -123,7 +171,9 @@ const _require = require("./util"),
   toModuleTransport = _require.toModuleTransport;
 
 function asMultipleFilesRamBundle(_ref) {
-  let filename = _ref.filename,
+  let dependencyMapReservedName = _ref.dependencyMapReservedName,
+    filename = _ref.filename,
+    globalPrefix = _ref.globalPrefix,
     idsForPath = _ref.idsForPath,
     modules = _ref.modules,
     requireCalls = _ref.requireCalls,
@@ -136,18 +186,25 @@ function asMultipleFilesRamBundle(_ref) {
     startup = _partition2[0],
     deferred = _partition2[1];
 
-  const startupModules = _toConsumableArray(startup).concat(
+  const startupModules = [].concat(
+    _toConsumableArray(startup),
     _toConsumableArray(requireCalls)
   );
-
-  const deferredModules = deferred.map(m => toModuleTransport(m, idsForPath));
+  const deferredModules = deferred.map(m =>
+    toModuleTransport(m, idsForPath, {
+      dependencyMapReservedName,
+      globalPrefix
+    })
+  );
   const magicFileContents = Buffer.alloc(4); // Just concatenate all startup modules, one after the other.
 
   const code = startupModules
     .map(
       m =>
         getModuleCodeAndMap(m, idForPath, {
-          enableIDInlining: true
+          dependencyMapReservedName,
+          enableIDInlining: true,
+          globalPrefix
         }).moduleCode
     )
     .join("\n"); // Write one file per module, wrapped with __d() call if it proceeds.
@@ -170,7 +227,12 @@ function asMultipleFilesRamBundle(_ref) {
     fixWrapperOffset: false,
     lazyModules: deferredModules,
     moduleGroups: null,
-    startupModules: startupModules.map(m => toModuleTransport(m, idsForPath))
+    startupModules: startupModules.map(m =>
+      toModuleTransport(m, idsForPath, {
+        dependencyMapReservedName,
+        globalPrefix
+      })
+    )
   });
   return {
     code,
@@ -182,10 +244,14 @@ function asMultipleFilesRamBundle(_ref) {
 function createBuilder(preloadedModules, ramGroupHeads) {
   return x =>
     asMultipleFilesRamBundle(
-      _objectSpread({}, x, {
-        preloadedModules,
-        ramGroupHeads
-      })
+      _objectSpread(
+        _objectSpread({}, x),
+        {},
+        {
+          preloadedModules,
+          ramGroupHeads
+        }
+      )
     );
 }
 
diff --git a/node_modules/metro/src/ModuleGraph/output/multiple-files-ram-bundle.js.flow b/node_modules/metro/src/ModuleGraph/output/multiple-files-ram-bundle.js.flow
index a20c3d8..e31c589 100644
--- a/node_modules/metro/src/ModuleGraph/output/multiple-files-ram-bundle.js.flow
+++ b/node_modules/metro/src/ModuleGraph/output/multiple-files-ram-bundle.js.flow
@@ -23,17 +23,19 @@ import type {IndexMap} from 'metro-source-map';
 import type {Module, OutputFn, OutputFnArg, OutputResult} from '../types.flow';
 
 function asMultipleFilesRamBundle({
+  dependencyMapReservedName,
   filename,
+  globalPrefix,
   idsForPath,
   modules,
   requireCalls,
   preloadedModules,
 }): OutputResult<IndexMap> {
-  const idForPath = (x: {path: string}) => idsForPath(x).moduleId;
+  const idForPath = (x: {path: string, ...}) => idsForPath(x).moduleId;
   const [startup, deferred] = partition(modules, preloadedModules);
   const startupModules = [...startup, ...requireCalls];
   const deferredModules = deferred.map((m: Module) =>
-    toModuleTransport(m, idsForPath),
+    toModuleTransport(m, idsForPath, {dependencyMapReservedName, globalPrefix}),
   );
   const magicFileContents = Buffer.alloc(4);
 
@@ -41,7 +43,11 @@ function asMultipleFilesRamBundle({
   const code = startupModules
     .map(
       (m: Module) =>
-        getModuleCodeAndMap(m, idForPath, {enableIDInlining: true}).moduleCode,
+        getModuleCodeAndMap(m, idForPath, {
+          dependencyMapReservedName,
+          enableIDInlining: true,
+          globalPrefix,
+        }).moduleCode,
     )
     .join('\n');
 
@@ -67,7 +73,10 @@ function asMultipleFilesRamBundle({
     lazyModules: deferredModules,
     moduleGroups: null,
     startupModules: startupModules.map((m: Module) =>
-      toModuleTransport(m, idsForPath),
+      toModuleTransport(m, idsForPath, {
+        dependencyMapReservedName,
+        globalPrefix,
+      }),
     ),
   });
 
diff --git a/node_modules/metro/src/ModuleGraph/output/plain-bundle.js b/node_modules/metro/src/ModuleGraph/output/plain-bundle.js
index 2ddef56..cbf4099 100644
--- a/node_modules/metro/src/ModuleGraph/output/plain-bundle.js
+++ b/node_modules/metro/src/ModuleGraph/output/plain-bundle.js
@@ -19,7 +19,9 @@ const _require2 = require("metro-source-map"),
   BundleBuilder = _require2.BundleBuilder;
 
 function asPlainBundle(_ref) {
-  let filename = _ref.filename,
+  let dependencyMapReservedName = _ref.dependencyMapReservedName,
+    filename = _ref.filename,
+    globalPrefix = _ref.globalPrefix,
     idsForPath = _ref.idsForPath,
     modules = _ref.modules,
     requireCalls = _ref.requireCalls,
@@ -31,7 +33,9 @@ function asPlainBundle(_ref) {
 
   for (const module of concat(modules, requireCalls)) {
     const _getModuleCodeAndMap = getModuleCodeAndMap(module, modIdForPath, {
-        enableIDInlining
+        dependencyMapReservedName,
+        enableIDInlining,
+        globalPrefix
       }),
       moduleCode = _getModuleCodeAndMap.moduleCode,
       moduleMap = _getModuleCodeAndMap.moduleMap;
diff --git a/node_modules/metro/src/ModuleGraph/output/plain-bundle.js.flow b/node_modules/metro/src/ModuleGraph/output/plain-bundle.js.flow
index aa1cd8c..d89b340 100644
--- a/node_modules/metro/src/ModuleGraph/output/plain-bundle.js.flow
+++ b/node_modules/metro/src/ModuleGraph/output/plain-bundle.js.flow
@@ -19,7 +19,9 @@ import type {OutputFn} from '../types.flow';
 import type {MixedSourceMap} from 'metro-source-map';
 
 function asPlainBundle({
+  dependencyMapReservedName,
   filename,
+  globalPrefix,
   idsForPath,
   modules,
   requireCalls,
@@ -31,11 +33,13 @@ function asPlainBundle({
   map: MixedSourceMap,
 |} {
   const builder = new BundleBuilder(filename);
-  const modIdForPath = (x: {path: string}) => idsForPath(x).moduleId;
+  const modIdForPath = (x: {path: string, ...}) => idsForPath(x).moduleId;
 
   for (const module of concat(modules, requireCalls)) {
     const {moduleCode, moduleMap} = getModuleCodeAndMap(module, modIdForPath, {
+      dependencyMapReservedName,
       enableIDInlining,
+      globalPrefix,
     });
 
     builder.append(moduleCode + '\n', moduleMap);
diff --git a/node_modules/metro/src/ModuleGraph/output/reverse-dependency-map-references.js b/node_modules/metro/src/ModuleGraph/output/reverse-dependency-map-references.js
index c3bf460..099f847 100644
--- a/node_modules/metro/src/ModuleGraph/output/reverse-dependency-map-references.js
+++ b/node_modules/metro/src/ModuleGraph/output/reverse-dependency-map-references.js
@@ -4,11 +4,23 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
+var _invariant = _interopRequireDefault(require("invariant"));
+
+var _nullthrows = _interopRequireDefault(require("nullthrows"));
+
+function _interopRequireDefault(obj) {
+  return obj && obj.__esModule
+    ? obj
+    : {
+        default: obj
+      };
+}
+
 function reverseDependencyMapReferences(_ref) {
   let t = _ref.types;
   return {
@@ -16,29 +28,41 @@ function reverseDependencyMapReferences(_ref) {
       CallExpression(path, state) {
         const node = path.node;
 
-        if (node.callee.name === "__d") {
-          const lastArg = node.arguments[0].params.slice(-1)[0];
+        if (node.callee.name === `${state.opts.globalPrefix}__d`) {
+          // $FlowFixMe Flow error uncovered by typing Babel more strictly
+          const lastArg = node.arguments[0].params.slice(-1)[0]; // $FlowFixMe Flow error uncovered by typing Babel more strictly
+
           const depMapName = lastArg && lastArg.name;
 
-          if (!depMapName) {
+          if (depMapName == null) {
             return;
           }
 
-          const scope = path.get("arguments.0.body").scope;
-          const binding = scope.getBinding(depMapName);
+          const body = path.get("arguments.0.body");
+          (0, _invariant.default)(
+            !Array.isArray(body),
+            "meetro: Expected `body` to be a single path."
+          );
+          const scope = body.scope;
+          const binding = (0, _nullthrows.default)(
+            scope.getBinding(depMapName)
+          );
           binding.referencePaths.forEach(_ref2 => {
             let parentPath = _ref2.parentPath;
-            const memberNode = parentPath.node;
+            const memberNode =
+              parentPath === null || parentPath === void 0
+                ? void 0
+                : parentPath.node;
 
             if (
+              memberNode != null &&
               memberNode.type === "MemberExpression" &&
               memberNode.property.type === "NumericLiteral"
             ) {
-              parentPath.replaceWith(
-                t.numericLiteral(
-                  state.opts.dependencyIds[memberNode.property.value]
-                )
+              const numericLiteral = t.numericLiteral(
+                state.opts.dependencyIds[memberNode.property.value]
               );
+              (0, _nullthrows.default)(parentPath).replaceWith(numericLiteral);
             }
           });
         }
diff --git a/node_modules/metro/src/ModuleGraph/output/reverse-dependency-map-references.js.flow b/node_modules/metro/src/ModuleGraph/output/reverse-dependency-map-references.js.flow
index 18b9f76..fb04031 100644
--- a/node_modules/metro/src/ModuleGraph/output/reverse-dependency-map-references.js.flow
+++ b/node_modules/metro/src/ModuleGraph/output/reverse-dependency-map-references.js.flow
@@ -10,44 +10,65 @@
 
 'use strict';
 
-import typeof {types as BabelTypes} from '@babel/core';
-import type {Path} from '@babel/traverse';
+import type {NodePath} from '@babel/traverse';
+import typeof * as Types from '@babel/types';
+import type {CallExpression} from '@babel/types';
+import invariant from 'invariant';
+import nullthrows from 'nullthrows';
 
 type State = {|
   opts: {|
     +dependencyIds: $ReadOnlyArray<number>,
+    +globalPrefix: string,
   |},
 |};
 
-function reverseDependencyMapReferences({types: t}: {types: BabelTypes}) {
+function reverseDependencyMapReferences({
+  types: t,
+}: {
+  types: Types,
+  ...
+}): {|
+  visitor: {|
+    CallExpression: (path: NodePath<CallExpression>, state: State) => void,
+  |},
+|} {
   return {
     visitor: {
-      CallExpression(path: Path, state: State) {
+      CallExpression(path: NodePath<CallExpression>, state: State) {
         const {node} = path;
 
-        if (node.callee.name === '__d') {
+        if (node.callee.name === `${state.opts.globalPrefix}__d`) {
+          // $FlowFixMe Flow error uncovered by typing Babel more strictly
           const lastArg = node.arguments[0].params.slice(-1)[0];
-          const depMapName = lastArg && lastArg.name;
+          // $FlowFixMe Flow error uncovered by typing Babel more strictly
+          const depMapName: ?string = lastArg && lastArg.name;
 
-          if (!depMapName) {
+          if (depMapName == null) {
             return;
           }
 
-          const scope = path.get('arguments.0.body').scope;
-          const binding = scope.getBinding(depMapName);
+          const body = path.get('arguments.0.body');
+          invariant(
+            !Array.isArray(body),
+            'meetro: Expected `body` to be a single path.',
+          );
+
+          const scope = body.scope;
+          const binding = nullthrows(scope.getBinding(depMapName));
 
           binding.referencePaths.forEach(({parentPath}) => {
-            const memberNode = parentPath.node;
+            const memberNode = parentPath?.node;
 
             if (
+              memberNode != null &&
               memberNode.type === 'MemberExpression' &&
               memberNode.property.type === 'NumericLiteral'
             ) {
-              parentPath.replaceWith(
-                t.numericLiteral(
-                  state.opts.dependencyIds[memberNode.property.value],
-                ),
+              const numericLiteral = t.numericLiteral(
+                state.opts.dependencyIds[memberNode.property.value],
               );
+              nullthrows(parentPath).replaceWith(numericLiteral);
             }
           });
         }
diff --git a/node_modules/metro/src/ModuleGraph/output/util.js b/node_modules/metro/src/ModuleGraph/output/util.js
index 1ea8fd7..c035b1a 100644
--- a/node_modules/metro/src/ModuleGraph/output/util.js
+++ b/node_modules/metro/src/ModuleGraph/output/util.js
@@ -4,26 +4,47 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,29 +59,77 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
-const addParamsToDefineCall = require("../../lib/addParamsToDefineCall");
+function _toConsumableArray(arr) {
+  return (
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
+  );
+}
+
+function _nonIterableSpread() {
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _iterableToArray(iter) {
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
+    return Array.from(iter);
+}
+
+function _arrayWithoutHoles(arr) {
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
 
 const generate = require("../worker/generate");
 
 const mergeSourceMaps = require("../worker/mergeSourceMaps");
 
+const nullthrows = require("nullthrows");
+
 const reverseDependencyMapReferences = require("./reverse-dependency-map-references");
 
-const virtualModule = require("../module").virtual;
+const _require = require("metro-transform-plugins"),
+  addParamsToDefineCall = _require.addParamsToDefineCall;
+
+const virtualModule = require("../module").virtual; // flowlint-next-line untyped-import:off
 
-const _require = require("@babel/core"),
-  transformSync = _require.transformSync;
+const _require2 = require("metro-react-native-babel-preset"),
+  passthroughSyntaxPlugins = _require2.passthroughSyntaxPlugins;
 
-// Transformed modules have the form
+const _require3 = require("@babel/core"),
+  transformSync = _require3.transformSync; // Transformed modules have the form
 //   __d(function(require, module, global, exports, dependencyMap) {
 //       /* code */
 //   });
 //
 // This function adds the numeric module ID, and an array with dependencies of
 // the dependencies of the module before the closing parenthesis.
+
 function addModuleIdsToModuleWrapper(module, idForPath) {
   const dependencies = module.dependencies,
     file = module.file;
@@ -80,7 +149,14 @@ function addModuleIdsToModuleWrapper(module, idForPath) {
 
 exports.addModuleIdsToModuleWrapper = addModuleIdsToModuleWrapper;
 
-function inlineModuleIds(module, idForPath) {
+function inlineModuleIds(module, idForPath, _ref) {
+  let _ref$dependencyMapRes = _ref.dependencyMapReservedName,
+    dependencyMapReservedName =
+      _ref$dependencyMapRes === void 0 ? undefined : _ref$dependencyMapRes,
+    globalPrefix = _ref.globalPrefix,
+    _ref$ignoreMissingDep = _ref.ignoreMissingDependencyMapReference,
+    ignoreMissingDependencyMapReference =
+      _ref$ignoreMissingDep === void 0 ? false : _ref$ignoreMissingDep;
   const dependencies = module.dependencies,
     file = module.file;
   const code = file.code,
@@ -92,39 +168,140 @@ function inlineModuleIds(module, idForPath) {
   const fileId = idForPath(file);
   const dependencyIds = dependencies.map(idForPath);
 
-  const _transformSync = transformSync(code, {
+  if (!dependencyIds.length) {
+    // Nothing to inline in this module.
+    return {
+      fileId,
+      moduleCode: code,
+      moduleMap: map
+    };
+  }
+
+  if (dependencyMapReservedName != null) {
+    /**
+     * Fast path for inlining module IDs as a cheap string operation, requiring
+     * neither parsing nor any adjustment to the source map.
+     *
+     * Assumptions:
+     * 1. `dependencyMapReservedName` is a globally reserved string; there are
+     *    no false positives.
+     * 2. The longest module ID in the bundle does not exceed a length of
+     *    `dependencyMapReservedName.length + 3`. (We assert this below.)
+     * 3. False negatives (failing to inline occasionally if an assumption
+     *    isn't met) are rare to nonexistent, but safe if they do occur.
+     *
+     * Syntax definitions:
+     * 1. A dependency map reference is a member expression which, if parsed,
+     *    would have the form:
+     *      MemberExpression
+     *      ├──object: Identifier (name = dependencyMapReservedName)
+     *      ├──property: NumericLiteral (value = some integer)
+     *      └──computed: true
+     * 2. The concrete form of a dependency map reference may contain embedded
+     *    tabs or spaces, but no newlines (which would complicate source maps),
+     *    parens (which would complicate detection) or comments (likewise).
+     * 3. The numeric literal in a dependency map reference is a base-10
+     *    integer printed as a simple sequence of digits.
+     */
+    if (!code.includes(dependencyMapReservedName)) {
+      if (ignoreMissingDependencyMapReference) {
+        return {
+          fileId,
+          moduleCode: code,
+          moduleMap: map
+        };
+      } // If we're here, the module was probably generated by some code that
+      // doesn't make the dependency map name externally configurable, or a
+      // mock that needs to be updated.
+
+      throw new Error(
+        `Module has dependencies but does not use the preconfigured dependency map name '${dependencyMapReservedName}': ${file.path}\n` +
+          "This is an internal error in Metro."
+      );
+    }
+
+    const WS = "[\t ]*";
+    const depMapReferenceRegex = new RegExp(
+      escapeRegex(dependencyMapReservedName) + `${WS}\\[${WS}([0-9]+)${WS}\\]`,
+      "g"
+    );
+    const inlinedCode = code.replace(
+      depMapReferenceRegex,
+      (match, depIndex) => {
+        const idStr = dependencyIds[Number.parseInt(depIndex, 10)].toString();
+
+        if (idStr.length > match.length) {
+          // Stop the build rather than silently emit an incorrect source map.
+          throw new Error(
+            `Module ID doesn't fit in available space; add ${idStr.length -
+              match.length} more characters to 'dependencyMapReservedName'.`
+          );
+        }
+
+        return idStr.padEnd(match.length);
+      }
+    );
+    return {
+      fileId,
+      moduleCode: inlinedCode,
+      moduleMap: map
+    };
+  }
+
+  const ast = nullthrows(
+    transformSync(code, {
       ast: true,
       babelrc: false,
       code: false,
       configFile: false,
-      plugins: [
+      plugins: [].concat(_toConsumableArray(passthroughSyntaxPlugins), [
         [
           reverseDependencyMapReferences,
           {
-            dependencyIds
+            dependencyIds,
+            globalPrefix
           }
         ]
-      ]
-    }),
-    ast = _transformSync.ast;
+      ])
+    }).ast
+  );
 
-  const _generate = generate(ast, path, "", true),
+  const _generate = generate(ast, path, ""),
     generatedCode = _generate.code,
     generatedMap = _generate.map;
 
   return {
-    moduleCode: addParamsToDefineCall(generatedCode, fileId),
+    fileId,
+    moduleCode: generatedCode,
     moduleMap: map && generatedMap && mergeSourceMaps(path, map, generatedMap)
   };
 }
 
+function inlineModuleIdsAndAddParamsToDefineCall(module, idForPath, options) {
+  const _inlineModuleIds = inlineModuleIds(module, idForPath, options),
+    fileId = _inlineModuleIds.fileId,
+    moduleCode = _inlineModuleIds.moduleCode,
+    moduleMap = _inlineModuleIds.moduleMap;
+
+  return {
+    moduleCode: addParamsToDefineCall(moduleCode, fileId),
+    moduleMap
+  };
+}
+
 exports.inlineModuleIds = inlineModuleIds;
+exports.inlineModuleIdsAndAddParamsToDefineCall = inlineModuleIdsAndAddParamsToDefineCall;
 
+function escapeRegex(str) {
+  // From http://stackoverflow.com/questions/14076210/
+  return str.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
+}
 /**
  * 1. Adds the module ids to a file if the file is a module. If it's not (e.g.
  *    a script) it just keeps it as-is.
  * 2. Packs the function map into the file's source map, if one exists.
  */
+
 function getModuleCodeAndMap(module, idForPath, options) {
   const file = module.file;
   let moduleCode, moduleMap;
@@ -136,10 +313,17 @@ function getModuleCodeAndMap(module, idForPath, options) {
     moduleCode = addModuleIdsToModuleWrapper(module, idForPath);
     moduleMap = file.map;
   } else {
-    var _inlineModuleIds = inlineModuleIds(module, idForPath);
+    var _inlineModuleIdsAndAd = inlineModuleIdsAndAddParamsToDefineCall(
+      module,
+      idForPath,
+      {
+        dependencyMapReservedName: options.dependencyMapReservedName,
+        globalPrefix: options.globalPrefix
+      }
+    );
 
-    moduleCode = _inlineModuleIds.moduleCode;
-    moduleMap = _inlineModuleIds.moduleMap;
+    moduleCode = _inlineModuleIdsAndAd.moduleCode;
+    moduleMap = _inlineModuleIdsAndAd.moduleMap;
   }
 
   if (moduleMap && moduleMap.sources) {
@@ -149,9 +333,13 @@ function getModuleCodeAndMap(module, idForPath, options) {
       x_facebook_sources.push([module.file.functionMap]);
     }
 
-    moduleMap = _objectSpread({}, moduleMap, {
-      x_facebook_sources
-    });
+    moduleMap = _objectSpread(
+      _objectSpread({}, moduleMap),
+      {},
+      {
+        x_facebook_sources
+      }
+    );
   }
 
   return {
@@ -180,8 +368,8 @@ exports.concat = function* concat() {
 exports.createIdForPathFn = () => {
   const seen = new Map();
   let next = 0;
-  return _ref => {
-    let path = _ref.path;
+  return _ref2 => {
+    let path = _ref2.path;
     let id = seen.get(path);
 
     if (id == null) {
@@ -216,8 +404,11 @@ exports.partition = (modules, preloadedModules) => {
   return [startup, deferred];
 }; // Transforms a new Module object into an old one, so that it can be passed
 // around code.
+// NOTE: Used only for RAM bundle serialization.
 
-exports.toModuleTransport = (module, idsForPath) => {
+function toModuleTransport(module, idsForPath, _ref3) {
+  let dependencyMapReservedName = _ref3.dependencyMapReservedName,
+    globalPrefix = _ref3.globalPrefix;
   const dependencies = module.dependencies,
     file = module.file;
 
@@ -225,7 +416,9 @@ exports.toModuleTransport = (module, idsForPath) => {
       module,
       x => idsForPath(x).moduleId,
       {
-        enableIDInlining: true
+        dependencyMapReservedName,
+        enableIDInlining: true,
+        globalPrefix
       }
     ),
     moduleCode = _getModuleCodeAndMap.moduleCode,
@@ -235,9 +428,11 @@ exports.toModuleTransport = (module, idsForPath) => {
     code: moduleCode,
     dependencies,
     // ID is required but we provide an invalid one for "script"s.
-    id: file.type === "module" ? idsForPath(file).localId : -1,
+    id: file.type === "module" ? nullthrows(idsForPath(file).localId) : -1,
     map: moduleMap,
     name: file.path,
     sourcePath: file.path
   };
-};
+}
+
+exports.toModuleTransport = toModuleTransport;
diff --git a/node_modules/metro/src/ModuleGraph/output/util.js.flow b/node_modules/metro/src/ModuleGraph/output/util.js.flow
index f3bb3a9..87f5d19 100644
--- a/node_modules/metro/src/ModuleGraph/output/util.js.flow
+++ b/node_modules/metro/src/ModuleGraph/output/util.js.flow
@@ -10,15 +10,19 @@
 
 'use strict';
 
-const addParamsToDefineCall = require('../../lib/addParamsToDefineCall');
 const generate = require('../worker/generate');
 const mergeSourceMaps = require('../worker/mergeSourceMaps');
+const nullthrows = require('nullthrows');
 const reverseDependencyMapReferences = require('./reverse-dependency-map-references');
+
+const {addParamsToDefineCall} = require('metro-transform-plugins');
 const virtualModule = require('../module').virtual;
 
+// flowlint-next-line untyped-import:off
+const {passthroughSyntaxPlugins} = require('metro-react-native-babel-preset');
 const {transformSync} = require('@babel/core');
 
-import type {IdsForPathFn, Module} from '../types.flow';
+import type {Dependency, IdsForPathFn, Module} from '../types.flow';
 import type {BasicSourceMap} from 'metro-source-map';
 
 // Transformed modules have the form
@@ -30,7 +34,7 @@ import type {BasicSourceMap} from 'metro-source-map';
 // the dependencies of the module before the closing parenthesis.
 function addModuleIdsToModuleWrapper(
   module: Module,
-  idForPath: ({path: string}) => number,
+  idForPath: ({path: string, ...}) => number,
 ): string {
   const {dependencies, file} = module;
   const {code} = file;
@@ -51,12 +55,24 @@ function addModuleIdsToModuleWrapper(
 
 exports.addModuleIdsToModuleWrapper = addModuleIdsToModuleWrapper;
 
+type InlineModuleIdsOptions = {
+  dependencyMapReservedName: ?string,
+  globalPrefix: string,
+  ignoreMissingDependencyMapReference?: boolean,
+};
+
 function inlineModuleIds(
   module: Module,
-  idForPath: ({path: string}) => number,
+  idForPath: ({path: string, ...}) => number,
+  {
+    dependencyMapReservedName = undefined,
+    globalPrefix,
+    ignoreMissingDependencyMapReference = false,
+  }: InlineModuleIdsOptions,
 ): {
   moduleCode: string,
   moduleMap: ?BasicSourceMap,
+  fileId: number,
 } {
   const {dependencies, file} = module;
   const {code, map, path} = file;
@@ -67,30 +83,123 @@ function inlineModuleIds(
   const fileId = idForPath(file);
   const dependencyIds = dependencies.map(idForPath);
 
-  const {ast} = transformSync(code, {
-    ast: true,
-    babelrc: false,
-    code: false,
-    configFile: false,
-    plugins: [[reverseDependencyMapReferences, {dependencyIds}]],
-  });
-
-  const {code: generatedCode, map: generatedMap} = generate(
-    ast,
-    path,
-    '',
-    true,
+  if (!dependencyIds.length) {
+    // Nothing to inline in this module.
+    return {fileId, moduleCode: code, moduleMap: map};
+  }
+
+  if (dependencyMapReservedName != null) {
+    /**
+     * Fast path for inlining module IDs as a cheap string operation, requiring
+     * neither parsing nor any adjustment to the source map.
+     *
+     * Assumptions:
+     * 1. `dependencyMapReservedName` is a globally reserved string; there are
+     *    no false positives.
+     * 2. The longest module ID in the bundle does not exceed a length of
+     *    `dependencyMapReservedName.length + 3`. (We assert this below.)
+     * 3. False negatives (failing to inline occasionally if an assumption
+     *    isn't met) are rare to nonexistent, but safe if they do occur.
+     *
+     * Syntax definitions:
+     * 1. A dependency map reference is a member expression which, if parsed,
+     *    would have the form:
+     *      MemberExpression
+     *      ├──object: Identifier (name = dependencyMapReservedName)
+     *      ├──property: NumericLiteral (value = some integer)
+     *      └──computed: true
+     * 2. The concrete form of a dependency map reference may contain embedded
+     *    tabs or spaces, but no newlines (which would complicate source maps),
+     *    parens (which would complicate detection) or comments (likewise).
+     * 3. The numeric literal in a dependency map reference is a base-10
+     *    integer printed as a simple sequence of digits.
+     */
+    if (!code.includes(dependencyMapReservedName)) {
+      if (ignoreMissingDependencyMapReference) {
+        return {fileId, moduleCode: code, moduleMap: map};
+      }
+
+      // If we're here, the module was probably generated by some code that
+      // doesn't make the dependency map name externally configurable, or a
+      // mock that needs to be updated.
+      throw new Error(
+        `Module has dependencies but does not use the preconfigured dependency map name '${dependencyMapReservedName}': ${file.path}\n` +
+          'This is an internal error in Metro.',
+      );
+    }
+    const WS = '[\t ]*';
+    const depMapReferenceRegex = new RegExp(
+      escapeRegex(dependencyMapReservedName) + `${WS}\\[${WS}([0-9]+)${WS}\\]`,
+      'g',
+    );
+    const inlinedCode = code.replace(
+      depMapReferenceRegex,
+      (match, depIndex) => {
+        const idStr = dependencyIds[Number.parseInt(depIndex, 10)].toString();
+        if (idStr.length > match.length) {
+          // Stop the build rather than silently emit an incorrect source map.
+          throw new Error(
+            `Module ID doesn't fit in available space; add ${idStr.length -
+              match.length} more characters to 'dependencyMapReservedName'.`,
+          );
+        }
+        return idStr.padEnd(match.length);
+      },
+    );
+    return {
+      fileId,
+      moduleCode: inlinedCode,
+      moduleMap: map,
+    };
+  }
+  const ast = nullthrows(
+    transformSync(code, {
+      ast: true,
+      babelrc: false,
+      code: false,
+      configFile: false,
+      plugins: [
+        ...passthroughSyntaxPlugins,
+        [reverseDependencyMapReferences, {dependencyIds, globalPrefix}],
+      ],
+    }).ast,
   );
 
+  const {code: generatedCode, map: generatedMap} = generate(ast, path, '');
+
   return {
-    moduleCode: addParamsToDefineCall(generatedCode, fileId),
+    fileId,
+    moduleCode: generatedCode,
     moduleMap: map && generatedMap && mergeSourceMaps(path, map, generatedMap),
   };
 }
 
+function inlineModuleIdsAndAddParamsToDefineCall(
+  module: Module,
+  idForPath: ({path: string, ...}) => number,
+  options: InlineModuleIdsOptions,
+): {
+  moduleCode: string,
+  moduleMap: ?BasicSourceMap,
+} {
+  const {fileId, moduleCode, moduleMap} = inlineModuleIds(
+    module,
+    idForPath,
+    options,
+  );
+
+  return {moduleCode: addParamsToDefineCall(moduleCode, fileId), moduleMap};
+}
+
 exports.inlineModuleIds = inlineModuleIds;
+exports.inlineModuleIdsAndAddParamsToDefineCall = inlineModuleIdsAndAddParamsToDefineCall;
+
+function escapeRegex(str: string): string {
+  // From http://stackoverflow.com/questions/14076210/
+  return str.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
+}
 
-type IdForPathFn = ({path: string}) => number;
+type IdForPathFn = ({path: string, ...}) => number;
 
 /**
  * 1. Adds the module ids to a file if the file is a module. If it's not (e.g.
@@ -100,8 +209,15 @@ type IdForPathFn = ({path: string}) => number;
 function getModuleCodeAndMap(
   module: Module,
   idForPath: IdForPathFn,
-  options: $ReadOnly<{enableIDInlining: boolean}>,
-) {
+  options: $ReadOnly<{
+    enableIDInlining: boolean,
+    dependencyMapReservedName: ?string,
+    globalPrefix: string,
+  }>,
+): {|
+  moduleCode: string,
+  moduleMap: ?BasicSourceMap,
+|} {
   const {file} = module;
   let moduleCode, moduleMap;
 
@@ -112,7 +228,14 @@ function getModuleCodeAndMap(
     moduleCode = addModuleIdsToModuleWrapper(module, idForPath);
     moduleMap = file.map;
   } else {
-    ({moduleCode, moduleMap} = inlineModuleIds(module, idForPath));
+    ({moduleCode, moduleMap} = inlineModuleIdsAndAddParamsToDefineCall(
+      module,
+      idForPath,
+      {
+        dependencyMapReservedName: options.dependencyMapReservedName,
+        globalPrefix: options.globalPrefix,
+      },
+    ));
   }
   if (moduleMap && moduleMap.sources) {
     const x_facebook_sources = [];
@@ -137,7 +260,7 @@ exports.concat = function* concat<T>(
 
 // Creates an idempotent function that returns numeric IDs for objects based
 // on their `path` property.
-exports.createIdForPathFn = (): (({path: string}) => number) => {
+exports.createIdForPathFn = (): (({path: string, ...}) => number) => {
   const seen = new Map();
   let next = 0;
   return ({path}) => {
@@ -183,21 +306,42 @@ exports.partition = (
 
 // Transforms a new Module object into an old one, so that it can be passed
 // around code.
-exports.toModuleTransport = (module: Module, idsForPath: IdsForPathFn) => {
+// NOTE: Used only for RAM bundle serialization.
+function toModuleTransport(
+  module: Module,
+  idsForPath: IdsForPathFn,
+  {
+    dependencyMapReservedName,
+    globalPrefix,
+  }: {dependencyMapReservedName: ?string, globalPrefix: string},
+): {
+  code: string,
+  dependencies: Array<Dependency>,
+  id: number,
+  map: ?BasicSourceMap,
+  name: string,
+  sourcePath: string,
+  ...
+} {
   const {dependencies, file} = module;
   const {moduleCode, moduleMap} = getModuleCodeAndMap(
     module,
-    (x: {path: string}) => idsForPath(x).moduleId,
-    {enableIDInlining: true},
+    (x: {path: string, ...}) => idsForPath(x).moduleId,
+    {
+      dependencyMapReservedName,
+      enableIDInlining: true,
+      globalPrefix,
+    },
   );
 
   return {
     code: moduleCode,
     dependencies,
     // ID is required but we provide an invalid one for "script"s.
-    id: file.type === 'module' ? idsForPath(file).localId : -1,
+    id: file.type === 'module' ? nullthrows(idsForPath(file).localId) : -1,
     map: moduleMap,
     name: file.path,
     sourcePath: file.path,
   };
-};
+}
+exports.toModuleTransport = toModuleTransport;
diff --git a/node_modules/metro/src/ModuleGraph/silent-console.js b/node_modules/metro/src/ModuleGraph/silent-console.js
index e36cfac..bfa630f 100644
--- a/node_modules/metro/src/ModuleGraph/silent-console.js
+++ b/node_modules/metro/src/ModuleGraph/silent-console.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/ModuleGraph/silent-console.js.flow b/node_modules/metro/src/ModuleGraph/silent-console.js.flow
index e8bc195..338d907 100644
--- a/node_modules/metro/src/ModuleGraph/silent-console.js.flow
+++ b/node_modules/metro/src/ModuleGraph/silent-console.js.flow
@@ -7,6 +7,7 @@
  * @format
  * @flow strict
  */
+
 'use strict';
 
 const {Console} = require('console');
@@ -16,4 +17,4 @@ const {Writable} = require('stream');
  * found when Flow v0.97 was deployed. To see the error delete this comment and
  * run Flow. */
 const write = (_, __, callback) => callback();
-module.exports = new Console(new Writable({write, writev: write}));
+module.exports = (new Console(new Writable({write, writev: write})): Console);
diff --git a/node_modules/metro/src/ModuleGraph/test-helpers.js b/node_modules/metro/src/ModuleGraph/test-helpers.js
index c6fbf02..34a88e7 100644
--- a/node_modules/metro/src/ModuleGraph/test-helpers.js
+++ b/node_modules/metro/src/ModuleGraph/test-helpers.js
@@ -10,11 +10,83 @@
 
 const generate = require("@babel/generator").default;
 
+const _require = require("jest-snapshot"),
+  toMatchSnapshot = _require.toMatchSnapshot;
+
 const generateOptions = {
   concise: true,
   sourceType: "module"
 };
 
-exports.codeFromAst = ast => generate(ast, generateOptions).code;
+const codeFromAst = ast => generate(ast, generateOptions).code;
+
+const comparableCode = code => code.trim().replace(/\s+/g, " ");
+
+function toEqualComparableCode(received, expected) {
+  const comparableExpected = comparableCode(expected);
+  const pass = received === comparableExpected;
+  const options = {
+    isNot: this.isNot,
+    promise: this.promise
+  };
+  const message = pass
+    ? () =>
+        this.utils.matcherHint(
+          "toEqualComparableCode",
+          undefined,
+          undefined,
+          options
+        ) +
+        "\n\n" +
+        `Expected: not ${this.utils.printExpected(comparableExpected)}\n` +
+        `Received: ${this.utils.printReceived(received)}`
+    : () => {
+        const diffString = this.utils.printDiffOrStringify(
+          comparableExpected,
+          received,
+          "expected",
+          "received",
+          this.expand
+        );
+        return (
+          this.utils.matcherHint(
+            "toEqualComparableCode",
+            undefined,
+            undefined,
+            options
+          ) +
+          "\n\n" +
+          diffString
+        );
+      };
+  return {
+    actual: received,
+    message,
+    pass
+  };
+} // See https://superuser.com/questions/380772/removing-ansi-color-codes-from-text-stream
 
-exports.comparableCode = code => code.trim().replace(/\s+/g, " ");
+const ANSI_PATTERN = /\x1b\[[0-9;]*m/g;
+
+function trimANSICodes(input) {
+  return input.replace(ANSI_PATTERN, "");
+}
+/**
+ * Matches a text that contains ANSI control codes (e.g. [39m[31m[1m^) against a snapshot.
+ * Usage: Call expect.extend({toMatchCodeFrameSnapshot}) to add the matcher in your test
+ */
+
+function toMatchCodeFrameSnapshot(received) {
+  return toMatchSnapshot.call(
+    this,
+    trimANSICodes(received),
+    "toMatchCodeFrameSnapshot"
+  );
+}
+
+module.exports = {
+  codeFromAst,
+  comparableCode,
+  toEqualComparableCode,
+  toMatchCodeFrameSnapshot
+};
diff --git a/node_modules/metro/src/ModuleGraph/types.flow.js.flow b/node_modules/metro/src/ModuleGraph/types.flow.js.flow
index f61b9c2..bcb05c7 100644
--- a/node_modules/metro/src/ModuleGraph/types.flow.js.flow
+++ b/node_modules/metro/src/ModuleGraph/types.flow.js.flow
@@ -7,9 +7,9 @@
  * @flow
  * @format
  */
+
 'use strict';
 
-import type {Ast} from '@babel/core';
 import type {
   MixedSourceMap,
   FBSourceFunctionMap,
@@ -23,10 +23,15 @@ export type Callback<A = void, B = void> = (Error => void) &
   ((null | void, A, B) => void);
 
 export type Dependency = {|
+  // The module name or path used to require the dependency
   id: string,
   +isAsync: boolean,
   +isPrefetchOnly: boolean,
+  +splitCondition: ?{|
+    +mobileConfigName: string,
+  |},
   path: string,
+  +locs: $ReadOnlyArray<BabelSourceLocation>,
 |};
 
 export type File = {|
@@ -47,35 +52,37 @@ export type GraphFn = (
 ) => GraphResult;
 
 export type GraphResult = {|
-  entryModules: Array<Module>,
   modules: Array<Module>,
 |};
 
 export type ModuleIds = {|
   /**
-   * The module ID is global across all bundles and identifies the module
+   * The module ID is global across all segments and identifies the module
    * uniquely. This is useful to cache modules that has been loaded already at
    * the app level.
    */
   +moduleId: number,
   /**
-   * The local ID is local to each bundle. For example bundle zero may have a
-   * module with local ID 1, and bundle one a module with the same local ID.
-   * This is useful so that RAM bundles tables start at zero, but the `moduleId`
+   * The local ID is local to each segment. For example segment zero may have a
+   * module with local ID 1, and segment one a module with the same local ID.
+   * This is useful so that RAM segments tables start at zero, but the `moduleId`
    * will be used otherwise.
+   * Some bundle formats allow a module to be repeated in multiple segments, in which
+   * case this property does not apply and will be omitted.
    */
-  +localId: number,
+  +localId?: number,
 |};
 
 /**
  * Indempotent function that gets us the IDs corresponding to a particular
  * module identified by path.
  */
-export type IdsForPathFn = ({path: string}) => ModuleIds;
+export type IdsForPathFn = ({path: string, ...}) => ModuleIds;
 
 export type LoadResult = {
   file: File,
   dependencies: $ReadOnlyArray<TransformResultDependency>,
+  ...
 };
 
 export type LoadFn = (file: string) => LoadResult;
@@ -91,12 +98,13 @@ export type PostProcessModules = (
 ) => $ReadOnlyArray<Module>;
 
 export type OutputFnArg = {|
+  dependencyMapReservedName?: string,
   filename: string,
+  globalPrefix: string,
   idsForPath: IdsForPathFn,
   modules: Iterable<Module>,
   requireCalls: Iterable<Module>,
   sourceMapPath?: ?string,
-  bundleOrderFile?: ?string,
   enableIDInlining: boolean,
   segmentID: number,
 |};
@@ -119,26 +127,35 @@ export type PackageData = {|
 
 export type ResolveFn = (id: string, source: ?string) => string;
 
-export type TransformerResult = {|
-  ast: ?Ast,
-  code: string,
-  map: ?BasicSourceMap,
-|};
+export type TransformResult = ConcreteTransformResult | LinkedTransformResult;
+
+export type ImportNames = {
+  all: string,
+  default: string,
+};
 
-export type TransformResult = {|
+export type ConcreteTransformResult = {
+  type: 'concrete',
   code: string,
   dependencies: $ReadOnlyArray<TransformResultDependency>,
   dependencyMapName?: string,
   map: ?BasicSourceMap,
   requireName: string,
   soundResources?: ?Array<string>,
-  importNames?: {all: string, default: string},
+  importNames?: ImportNames,
   isESModule?: true,
-|};
+};
 
-export type TransformResults = {[string]: TransformResult};
+export type LinkedTransformResult = $ReadOnly<{
+  type: 'linked',
+  sourceVariantName: string,
+}>;
+
+export type TransformResults = {
+  +[string]: TransformResult,
+};
 
-export type TransformVariants = {+[name: string]: {}};
+export type TransformVariants = {+[name: string]: {...}};
 
 export type TransformedCodeFile = {|
   +file: string,
@@ -219,9 +236,11 @@ export type Base64Content = string;
 export type AssetContents = {
   +data: Base64Content,
   +outputPath: string,
+  ...
 };
 export type AssetContentsByPath = {
   +[moduleFilePath: string]: $ReadOnlyArray<AssetContents>,
+  ...,
 };
 
 export type ResolvedCodeFile = {|
@@ -232,7 +251,7 @@ export type ResolvedCodeFile = {|
    * all the other dependencies. For example, it could be
    * `{'foo': 'bar/foo.js', 'bar': 'node_modules/bar/index.js'}`.
    */
-  +filePathsByDependencyName: {[dependencyName: string]: string},
+  +filePathsByDependencyName: {[dependencyName: string]: string, ...},
 |};
 
 export type LibraryBoundCodeFile = {|
diff --git a/node_modules/metro/src/ModuleGraph/worker/JsFileWrapping.js b/node_modules/metro/src/ModuleGraph/worker/JsFileWrapping.js
index 6ba38c2..9bb17c4 100644
--- a/node_modules/metro/src/ModuleGraph/worker/JsFileWrapping.js
+++ b/node_modules/metro/src/ModuleGraph/worker/JsFileWrapping.js
@@ -8,26 +8,84 @@
  *
  */
 "use strict";
-/* eslint-disable lint/no-unclear-flowtypes */
 
-const t = require("@babel/types");
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
+var _template = _interopRequireDefault(require("@babel/template"));
 
-const template = require("@babel/template").default;
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
+var _traverse = _interopRequireDefault(require("@babel/traverse"));
 
-const traverse = require("@babel/traverse").default;
+var t = _interopRequireWildcard(require("@babel/types"));
+
+var _invariant = _interopRequireDefault(require("invariant"));
+
+function _getRequireWildcardCache() {
+  if (typeof WeakMap !== "function") return null;
+  var cache = new WeakMap();
+
+  _getRequireWildcardCache = function() {
+    return cache;
+  };
+
+  return cache;
+}
+
+function _interopRequireWildcard(obj) {
+  if (obj && obj.__esModule) {
+    return obj;
+  }
+
+  if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
+    return {
+      default: obj
+    };
+  }
+
+  var cache = _getRequireWildcardCache();
+
+  if (cache && cache.has(obj)) {
+    return cache.get(obj);
+  }
+
+  var newObj = {};
+  var hasPropertyDescriptor =
+    Object.defineProperty && Object.getOwnPropertyDescriptor;
+
+  for (var key in obj) {
+    if (Object.prototype.hasOwnProperty.call(obj, key)) {
+      var desc = hasPropertyDescriptor
+        ? Object.getOwnPropertyDescriptor(obj, key)
+        : null;
+
+      if (desc && (desc.get || desc.set)) {
+        Object.defineProperty(newObj, key, desc);
+      } else {
+        newObj[key] = obj[key];
+      }
+    }
+  }
+
+  newObj.default = obj;
+
+  if (cache) {
+    cache.set(obj, newObj);
+  }
+
+  return newObj;
+}
+
+function _interopRequireDefault(obj) {
+  return obj && obj.__esModule
+    ? obj
+    : {
+        default: obj
+      };
+}
 
 const WRAP_NAME = "$$_REQUIRE"; // note: babel will prefix this with _
 // Check first the `global` variable as the global object. This way serializers
 // can create a local variable called global to fake it as a global object
 // without having to pollute the window object on web.
 
-const IIFE_PARAM = template(
+const IIFE_PARAM = _template.default.expression(
   "typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this"
 );
 
@@ -35,7 +93,8 @@ function wrapModule(
   fileAst,
   importDefaultName,
   importAllName,
-  dependencyMapName
+  dependencyMapName,
+  globalPrefix
 ) {
   const params = buildParameters(
     importDefaultName,
@@ -43,7 +102,7 @@ function wrapModule(
     dependencyMapName
   );
   const factory = functionFromProgram(fileAst.program, params);
-  const def = t.callExpression(t.identifier("__d"), [factory]);
+  const def = t.callExpression(t.identifier(`${globalPrefix}__d`), [factory]);
   const ast = t.file(t.program([t.expressionStatement(def)]));
   const requireName = renameRequires(ast);
   return {
@@ -54,27 +113,31 @@ function wrapModule(
 
 function wrapPolyfill(fileAst) {
   const factory = functionFromProgram(fileAst.program, ["global"]);
-  const iife = t.callExpression(factory, [IIFE_PARAM().expression]);
+  const iife = t.callExpression(factory, [IIFE_PARAM()]);
   return t.file(t.program([t.expressionStatement(iife)]));
 }
 
-function wrapJson(source) {
+function jsonToCommonJS(source) {
+  return `module.exports = ${source};`;
+}
+
+function wrapJson(source, globalPrefix) {
   // Unused parameters; remember that's wrapping JSON.
   const moduleFactoryParameters = buildParameters(
-    "_aUnused",
-    "_bUnused",
-    "_cUnused"
+    "_importDefaultUnused",
+    "_importAllUnused",
+    "_dependencyMapUnused"
   );
   return [
-    `__d(function(${moduleFactoryParameters.join(", ")}) {`,
-    `  module.exports = ${source};`,
+    `${globalPrefix}__d(function(${moduleFactoryParameters.join(", ")}) {`,
+    `  ${jsonToCommonJS(source)}`,
     "});"
   ].join("\n");
 }
 
 function functionFromProgram(program, parameters) {
   return t.functionExpression(
-    t.identifier(""),
+    undefined,
     parameters.map(makeIdentifier),
     t.blockStatement(program.body, program.directives)
   );
@@ -94,13 +157,21 @@ function buildParameters(importDefaultName, importAllName, dependencyMapName) {
     "exports",
     dependencyMapName
   ];
-}
+} // Renaming requires should ideally only be done when generating for the target
+// that expects the custom require name in the optimize step.
+// This visitor currently renames all `require` references even if the module
+// contains a custom `require` declaration. This should be fixed by only renaming
+// if the `require` symbol hasn't been redeclared.
 
 function renameRequires(ast) {
   let newRequireName = WRAP_NAME;
-  traverse(ast, {
+  (0, _traverse.default)(ast, {
     Program(path) {
       const body = path.get("body.0.expression.arguments.0.body");
+      (0, _invariant.default)(
+        !Array.isArray(body),
+        "metro: Expected `body` to be a single path."
+      );
       newRequireName = body.scope.generateUid(WRAP_NAME);
       body.scope.rename("require", newRequireName);
     }
@@ -111,6 +182,7 @@ function renameRequires(ast) {
 module.exports = {
   WRAP_NAME,
   wrapJson,
+  jsonToCommonJS,
   wrapModule,
   wrapPolyfill
 };
diff --git a/node_modules/metro/src/ModuleGraph/worker/JsFileWrapping.js.flow b/node_modules/metro/src/ModuleGraph/worker/JsFileWrapping.js.flow
index 45603bf..7fb063f 100644
--- a/node_modules/metro/src/ModuleGraph/worker/JsFileWrapping.js.flow
+++ b/node_modules/metro/src/ModuleGraph/worker/JsFileWrapping.js.flow
@@ -10,40 +10,38 @@
 
 'use strict';
 
-/* eslint-disable lint/no-unclear-flowtypes */
-const t = require('@babel/types');
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
-const template = require('@babel/template').default;
-
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
-const traverse = require('@babel/traverse').default;
+import template from '@babel/template';
+import traverse from '@babel/traverse';
+import * as t from '@babel/types';
+import type {Program, FunctionExpression, Identifier} from '@babel/types';
+import invariant from 'invariant';
 
 const WRAP_NAME = '$$_REQUIRE'; // note: babel will prefix this with _
 
 // Check first the `global` variable as the global object. This way serializers
 // can create a local variable called global to fake it as a global object
 // without having to pollute the window object on web.
-const IIFE_PARAM = template(
+const IIFE_PARAM = template.expression(
   "typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this",
 );
 
 function wrapModule(
-  fileAst: Object,
+  fileAst: BabelNodeFile,
   importDefaultName: string,
   importAllName: string,
   dependencyMapName: string,
-): {ast: Object, requireName: string} {
+  globalPrefix: string,
+): {
+  ast: BabelNodeFile,
+  requireName: string,
+} {
   const params = buildParameters(
     importDefaultName,
     importAllName,
     dependencyMapName,
   );
   const factory = functionFromProgram(fileAst.program, params);
-  const def = t.callExpression(t.identifier('__d'), [factory]);
+  const def = t.callExpression(t.identifier(`${globalPrefix}__d`), [factory]);
   const ast = t.file(t.program([t.expressionStatement(def)]));
 
   const requireName = renameRequires(ast);
@@ -51,40 +49,44 @@ function wrapModule(
   return {ast, requireName};
 }
 
-function wrapPolyfill(fileAst: Object): Object {
+function wrapPolyfill(fileAst: BabelNodeFile): BabelNodeFile {
   const factory = functionFromProgram(fileAst.program, ['global']);
 
-  const iife = t.callExpression(factory, [IIFE_PARAM().expression]);
+  const iife = t.callExpression(factory, [IIFE_PARAM()]);
   return t.file(t.program([t.expressionStatement(iife)]));
 }
 
-function wrapJson(source: string): string {
+function jsonToCommonJS(source: string): string {
+  return `module.exports = ${source};`;
+}
+
+function wrapJson(source: string, globalPrefix: string): string {
   // Unused parameters; remember that's wrapping JSON.
   const moduleFactoryParameters = buildParameters(
-    '_aUnused',
-    '_bUnused',
-    '_cUnused',
+    '_importDefaultUnused',
+    '_importAllUnused',
+    '_dependencyMapUnused',
   );
 
   return [
-    `__d(function(${moduleFactoryParameters.join(', ')}) {`,
-    `  module.exports = ${source};`,
+    `${globalPrefix}__d(function(${moduleFactoryParameters.join(', ')}) {`,
+    `  ${jsonToCommonJS(source)}`,
     '});',
   ].join('\n');
 }
 
 function functionFromProgram(
-  program: Object,
+  program: Program,
   parameters: $ReadOnlyArray<string>,
-): Object {
+): FunctionExpression {
   return t.functionExpression(
-    t.identifier(''),
+    undefined,
     parameters.map(makeIdentifier),
     t.blockStatement(program.body, program.directives),
   );
 }
 
-function makeIdentifier(name: string): Object {
+function makeIdentifier(name: string): Identifier {
   return t.identifier(name);
 }
 
@@ -104,13 +106,23 @@ function buildParameters(
   ];
 }
 
-function renameRequires(ast: Object): string {
+// Renaming requires should ideally only be done when generating for the target
+// that expects the custom require name in the optimize step.
+// This visitor currently renames all `require` references even if the module
+// contains a custom `require` declaration. This should be fixed by only renaming
+// if the `require` symbol hasn't been redeclared.
+function renameRequires(ast: BabelNodeFile): string {
   let newRequireName = WRAP_NAME;
 
   traverse(ast, {
     Program(path) {
       const body = path.get('body.0.expression.arguments.0.body');
 
+      invariant(
+        !Array.isArray(body),
+        'metro: Expected `body` to be a single path.',
+      );
+
       newRequireName = body.scope.generateUid(WRAP_NAME);
       body.scope.rename('require', newRequireName);
     },
@@ -123,6 +135,7 @@ module.exports = {
   WRAP_NAME,
 
   wrapJson,
+  jsonToCommonJS,
   wrapModule,
   wrapPolyfill,
 };
diff --git a/node_modules/metro/src/ModuleGraph/worker/Platforms.js b/node_modules/metro/src/ModuleGraph/worker/Platforms.js
index 788cbfc..4658513 100644
--- a/node_modules/metro/src/ModuleGraph/worker/Platforms.js
+++ b/node_modules/metro/src/ModuleGraph/worker/Platforms.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/ModuleGraph/worker/collectDependencies.js b/node_modules/metro/src/ModuleGraph/worker/collectDependencies.js
index ea16cde..9b120c8 100644
--- a/node_modules/metro/src/ModuleGraph/worker/collectDependencies.js
+++ b/node_modules/metro/src/ModuleGraph/worker/collectDependencies.js
@@ -9,112 +9,151 @@
  */
 "use strict";
 
-function _slicedToArray(arr, i) {
-  return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
-  );
-}
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
 
-function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  return keys;
 }
 
-function _iterableToArrayLimit(arr, i) {
-  var _arr = [];
-  var _n = true;
-  var _d = false;
-  var _e = undefined;
-  try {
-    for (
-      var _i = arr[Symbol.iterator](), _s;
-      !(_n = (_s = _i.next()).done);
-      _n = true
-    ) {
-      _arr.push(_s.value);
-      if (i && _arr.length === i) break;
+function _objectSpread(target) {
+  for (var i = 1; i < arguments.length; i++) {
+    var source = arguments[i] != null ? arguments[i] : {};
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-  } catch (err) {
-    _d = true;
-    _e = err;
-  } finally {
-    try {
-      if (!_n && _i["return"] != null) _i["return"]();
-    } finally {
-      if (_d) throw _e;
+  }
+
+  return target;
+}
+
+function _defineProperty(obj, key, value) {
+  if (key in obj) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+  } else {
+    obj[key] = value;
+  }
+
+  return obj;
+}
+
+function _objectWithoutProperties(source, excluded) {
+  if (source == null) return {};
+
+  var target = _objectWithoutPropertiesLoose(source, excluded);
+
+  var key, i;
+
+  if (Object.getOwnPropertySymbols) {
+    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
+
+    for (i = 0; i < sourceSymbolKeys.length; i++) {
+      key = sourceSymbolKeys[i];
+      if (excluded.indexOf(key) >= 0) continue;
+      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
+      target[key] = source[key];
     }
   }
-  return _arr;
+
+  return target;
 }
 
-function _arrayWithHoles(arr) {
-  if (Array.isArray(arr)) return arr;
+function _objectWithoutPropertiesLoose(source, excluded) {
+  if (source == null) return {};
+  var target = {};
+  var sourceKeys = Object.keys(source);
+  var key, i;
+
+  for (i = 0; i < sourceKeys.length; i++) {
+    key = sourceKeys[i];
+    if (excluded.indexOf(key) >= 0) continue;
+    target[key] = source[key];
+  }
+
+  return target;
 }
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
+const invariant = require("invariant");
+
 const nullthrows = require("nullthrows");
 
 const generate = require("@babel/generator").default;
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
 
 const template = require("@babel/template").default;
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
 
 const traverse = require("@babel/traverse").default;
 
 const types = require("@babel/types");
 
-/**
- * Produces a Babel template that will throw at runtime when the require call
- * is reached. This makes dynamic require errors catchable by libraries that
- * want to use them.
- */
-const dynamicRequireErrorTemplate = template(`
-  (function(line) {
-    throw new Error(
-      'Dynamic require defined at line ' + line + '; not supported by Metro',
-    );
-  })(LINE)
-`);
-/**
- * Produces a Babel template that transforms an "import(...)" call into a
- * "require(...)" call to the asyncRequire specified.
- */
-
-const makeAsyncRequireTemplate = template(`
-  require(ASYNC_REQUIRE_MODULE_PATH)(MODULE_ID, MODULE_NAME)
-`);
-const makeAsyncPrefetchTemplate = template(`
-  require(ASYNC_REQUIRE_MODULE_PATH).prefetch(MODULE_ID, MODULE_NAME)
-`);
+const isImport = types.isImport;
 /**
  * Transform all the calls to `require()` and `import()` in a file into ID-
  * independent code, and return the list of dependencies. For example, a call
@@ -126,17 +165,26 @@ const makeAsyncPrefetchTemplate = template(`
  */
 
 function collectDependencies(ast, options) {
+  var _options$dependencyRe, _options$dependencyTr;
+
   const visited = new WeakSet();
   const state = {
     asyncRequireModulePathStringLiteral: null,
-    dependency: 0,
     dependencyCalls: new Set(),
-    dependencyData: new Map(),
-    dependencyIndexes: new Map(),
+    dependencyRegistry:
+      (_options$dependencyRe = options.dependencyRegistry) !== null &&
+      _options$dependencyRe !== void 0
+        ? _options$dependencyRe
+        : new DefaultModuleDependencyRegistry(),
+    dependencyTransformer:
+      (_options$dependencyTr = options.dependencyTransformer) !== null &&
+      _options$dependencyTr !== void 0
+        ? _options$dependencyTr
+        : DefaultDependencyTransformer,
     dependencyMapIdentifier: null,
     dynamicRequires: options.dynamicRequires,
     keepRequireNames: options.keepRequireNames,
-    disableRequiresTransform: !!options.disableRequiresTransform
+    allowOptionalDependencies: options.allowOptionalDependencies
   };
   const visitor = {
     CallExpression(path, state) {
@@ -144,59 +192,92 @@ function collectDependencies(ast, options) {
         return;
       }
 
-      const callee = path.get("callee");
-      const name = callee.node.name;
+      const callee = path.node.callee;
+      const name = callee.type === "Identifier" ? callee.name : null;
 
-      if (callee.isImport()) {
+      if (isImport(callee)) {
         processImportCall(path, state, {
-          prefetchOnly: false
+          asyncType: "async"
         });
         return;
       }
 
       if (name === "__prefetchImport" && !path.scope.getBinding(name)) {
         processImportCall(path, state, {
-          prefetchOnly: true
+          asyncType: "prefetch"
         });
         return;
       }
 
-      if (state.dependencyCalls.has(name) && !path.scope.getBinding(name)) {
-        visited.add(processRequireCall(path, state).node);
+      if (name === "__jsResource" && !path.scope.getBinding(name)) {
+        processImportCall(path, state, {
+          asyncType: "async",
+          jsResource: true
+        });
+        return;
       }
-    },
 
-    ImportDeclaration(path, state) {
-      const dep = getDependency(state, path.node.source.value, {
-        prefetchOnly: false
-      });
-      dep.data.isAsync = false;
+      if (
+        name === "__conditionallySplitJSResource" &&
+        !path.scope.getBinding(name)
+      ) {
+        const args = path.get("arguments");
+        invariant(Array.isArray(args), "Expected arguments to be an array");
+        processImportCall(path, state, {
+          asyncType: "async",
+          jsResource: true,
+          splitCondition: args[1]
+        });
+        return;
+      }
+
+      if (
+        name != null &&
+        state.dependencyCalls.has(name) &&
+        !path.scope.getBinding(name)
+      ) {
+        processRequireCall(path, state);
+        visited.add(path.node);
+      }
     },
 
+    ImportDeclaration: collectImports,
+    ExportNamedDeclaration: collectImports,
+    ExportAllDeclaration: collectImports,
+
     Program(path, state) {
       state.asyncRequireModulePathStringLiteral = types.stringLiteral(
         options.asyncRequireModulePath
       );
-      state.dependencyMapIdentifier = path.scope.generateUidIdentifier(
-        "dependencyMap"
-      );
+
+      if (options.dependencyMapName != null) {
+        state.dependencyMapIdentifier = types.identifier(
+          options.dependencyMapName
+        );
+      } else {
+        state.dependencyMapIdentifier = path.scope.generateUidIdentifier(
+          "dependencyMap"
+        );
+      }
+
       state.dependencyCalls = new Set(
         ["require"].concat(_toConsumableArray(options.inlineableCalls))
       );
     }
   };
-  traverse(ast, visitor, null, state); // Compute the list of dependencies.
+  traverse(ast, visitor, null, state);
+  const collectedDependencies = state.dependencyRegistry.getDependencies(); // Compute the list of dependencies.
 
-  const dependencies = new Array(state.dependency);
+  const dependencies = new Array(collectedDependencies.length);
 
-  for (const _ref of state.dependencyData) {
-    var _ref2 = _slicedToArray(_ref, 2);
+  for (const _ref of collectedDependencies) {
+    const index = _ref.index,
+      name = _ref.name,
+      dependencyData = _objectWithoutProperties(_ref, ["index", "name"]);
 
-    const name = _ref2[0];
-    const data = _ref2[1];
-    dependencies[nullthrows(state.dependencyIndexes.get(name))] = {
+    dependencies[index] = {
       name,
-      data
+      data: dependencyData
     };
   }
 
@@ -207,6 +288,20 @@ function collectDependencies(ast, options) {
   };
 }
 
+function collectImports(path, state) {
+  if (path.node.source) {
+    registerDependency(
+      state,
+      {
+        name: path.node.source.value,
+        asyncType: null,
+        optional: false
+      },
+      path
+    );
+  }
+}
+
 function processImportCall(path, state, options) {
   const name = getModuleNameFromCallArgs(path);
 
@@ -214,112 +309,134 @@ function processImportCall(path, state, options) {
     throw new InvalidRequireCallError(path);
   }
 
-  const dep = getDependency(state, name, options);
-
-  if (!options.prefetchOnly) {
-    delete dep.data.isPrefetchOnly;
-  }
-
-  if (state.disableRequiresTransform) {
-    return path;
-  }
-
-  const ASYNC_REQUIRE_MODULE_PATH = state.asyncRequireModulePathStringLiteral;
-  const MODULE_ID = types.memberExpression(
-    state.dependencyMapIdentifier,
-    types.numericLiteral(dep.index),
-    true
+  const dep = registerDependency(
+    state,
+    {
+      name,
+      asyncType: options.asyncType,
+      splitCondition: options.splitCondition,
+      optional: isOptionalDependency(name, path, state)
+    },
+    path
   );
-  const MODULE_NAME = types.stringLiteral(name);
+  const transformer = state.dependencyTransformer;
 
-  if (!options.prefetchOnly) {
-    path.replaceWith(
-      makeAsyncRequireTemplate({
-        ASYNC_REQUIRE_MODULE_PATH,
-        MODULE_ID,
-        MODULE_NAME
-      })
-    );
+  if (options.jsResource) {
+    transformer.transformJSResource(path, dep, state);
+  } else if (options.asyncType === "async") {
+    transformer.transformImportCall(path, dep, state);
   } else {
-    path.replaceWith(
-      makeAsyncPrefetchTemplate({
-        ASYNC_REQUIRE_MODULE_PATH,
-        MODULE_ID,
-        MODULE_NAME
-      })
-    );
+    transformer.transformPrefetch(path, dep, state);
   }
-
-  return path;
 }
 
 function processRequireCall(path, state) {
   const name = getModuleNameFromCallArgs(path);
+  const transformer = state.dependencyTransformer;
 
   if (name == null) {
     if (state.dynamicRequires === "reject") {
       throw new InvalidRequireCallError(path);
     }
 
-    path.replaceWith(
-      dynamicRequireErrorTemplate({
-        LINE: "" + path.node.loc.start.line
-      })
-    );
-    return path;
+    transformer.transformIllegalDynamicRequire(path, state);
+    return;
   }
 
-  const dep = getDependency(state, name, {
-    prefetchOnly: false
-  });
-  dep.data.isAsync = false;
-  delete dep.data.isPrefetchOnly;
+  const dep = registerDependency(
+    state,
+    {
+      name,
+      asyncType: null,
+      optional: isOptionalDependency(name, path, state)
+    },
+    path
+  );
+  transformer.transformSyncRequire(path, dep, state);
+}
+
+function getNearestLocFromPath(path) {
+  var _current;
 
-  if (state.disableRequiresTransform) {
-    return path;
+  let current = path;
+
+  while (current && !current.node.loc) {
+    current = current.parentPath;
   }
 
-  const moduleIDExpression = types.memberExpression(
-    state.dependencyMapIdentifier,
-    types.numericLiteral(dep.index),
-    true
-  );
-  path.node.arguments = state.keepRequireNames
-    ? [moduleIDExpression, types.stringLiteral(name)]
-    : [moduleIDExpression];
-  return path;
+  return (_current = current) === null || _current === void 0
+    ? void 0
+    : _current.node.loc;
 }
 
-function getDependency(state, name, options) {
-  let index = state.dependencyIndexes.get(name);
-  let data = state.dependencyData.get(name);
+function registerDependency(state, qualifier, path) {
+  const dependency = state.dependencyRegistry.registerDependency(qualifier);
+  const loc = getNearestLocFromPath(path);
 
-  if (!data) {
-    index = state.dependency++;
-    data = {
-      isAsync: true
-    };
+  if (loc != null) {
+    dependency.locs.push(loc);
+  }
+
+  return dependency;
+}
+
+function isOptionalDependency(name, path, state) {
+  var _state$asyncRequireMo;
+
+  const allowOptionalDependencies = state.allowOptionalDependencies; // The async require module is a 'built-in'. Resolving should never fail -> treat it as non-optional.
 
-    if (options.prefetchOnly) {
-      data.isPrefetchOnly = true;
+  if (
+    name ===
+    ((_state$asyncRequireMo = state.asyncRequireModulePathStringLiteral) ===
+      null || _state$asyncRequireMo === void 0
+      ? void 0
+      : _state$asyncRequireMo.value)
+  ) {
+    return false;
+  }
+
+  const isExcluded = () =>
+    Array.isArray(allowOptionalDependencies.exclude) &&
+    allowOptionalDependencies.exclude.includes(name);
+
+  if (!allowOptionalDependencies || isExcluded()) {
+    return false;
+  } // Valid statement stack for single-level try-block: expressionStatement -> blockStatement -> tryStatement
+
+  let sCount = 0;
+  let p = path;
+
+  while (p && sCount < 3) {
+    if (p.isStatement()) {
+      if (p.node.type === "BlockStatement") {
+        // A single-level should have the tryStatement immediately followed BlockStatement
+        // with the key 'block' to distinguish from the finally block, which has key = 'finalizer'
+        return (
+          p.parentPath != null &&
+          p.parentPath.node.type === "TryStatement" &&
+          p.key === "block"
+        );
+      }
+
+      sCount += 1;
     }
 
-    state.dependencyIndexes.set(name, index);
-    state.dependencyData.set(name, data);
+    p = p.parentPath;
   }
 
-  return {
-    index: nullthrows(index),
-    data: nullthrows(data)
-  };
+  return false;
 }
 
 function getModuleNameFromCallArgs(path) {
-  if (path.get("arguments").length !== 1) {
+  const expectedCount =
+    path.node.callee.name === "__conditionallySplitJSResource" ? 2 : 1;
+  const args = path.get("arguments");
+
+  if (!Array.isArray(args) || args.length !== expectedCount) {
     throw new InvalidRequireCallError(path);
   }
 
-  const result = path.get("arguments.0").evaluate();
+  const result = args[0].evaluate();
 
   if (result.confident && typeof result.value === "string") {
     return result.value;
@@ -331,8 +448,8 @@ function getModuleNameFromCallArgs(path) {
 collectDependencies.getModuleNameFromCallArgs = getModuleNameFromCallArgs;
 
 class InvalidRequireCallError extends Error {
-  constructor(_ref3) {
-    let node = _ref3.node;
+  constructor(_ref2) {
+    let node = _ref2.node;
     const line = node.loc && node.loc.start && node.loc.start.line;
     super(
       `Invalid call at line ${line || "<unknown>"}: ${generate(node).code}`
@@ -341,4 +458,185 @@ class InvalidRequireCallError extends Error {
 }
 
 collectDependencies.InvalidRequireCallError = InvalidRequireCallError;
+/**
+ * Produces a Babel template that will throw at runtime when the require call
+ * is reached. This makes dynamic require errors catchable by libraries that
+ * want to use them.
+ */
+
+const dynamicRequireErrorTemplate = template.statement(`
+  (function(line) {
+    throw new Error(
+      'Dynamic require defined at line ' + line + '; not supported by Metro',
+    );
+  })(LINE)
+`);
+/**
+ * Produces a Babel template that transforms an "import(...)" call into a
+ * "require(...)" call to the asyncRequire specified.
+ */
+
+const makeAsyncRequireTemplate = template.statement(`
+  require(ASYNC_REQUIRE_MODULE_PATH)(MODULE_ID, MODULE_NAME)
+`);
+const makeAsyncPrefetchTemplate = template.statement(`
+  require(ASYNC_REQUIRE_MODULE_PATH).prefetch(MODULE_ID, MODULE_NAME)
+`);
+const makeJSResourceTemplate = template.statement(`
+  require(ASYNC_REQUIRE_MODULE_PATH).resource(MODULE_ID, MODULE_NAME)
+`);
+const DefaultDependencyTransformer = {
+  transformSyncRequire(path, dependency, state) {
+    const moduleIDExpression = createModuleIDExpression(dependency, state);
+    path.node.arguments = state.keepRequireNames
+      ? [moduleIDExpression, types.stringLiteral(dependency.name)]
+      : [moduleIDExpression];
+  },
+
+  transformImportCall(path, dependency, state) {
+    path.replaceWith(
+      makeAsyncRequireTemplate({
+        ASYNC_REQUIRE_MODULE_PATH: nullthrows(
+          state.asyncRequireModulePathStringLiteral
+        ),
+        MODULE_ID: createModuleIDExpression(dependency, state),
+        MODULE_NAME: createModuleNameLiteral(dependency)
+      })
+    );
+  },
+
+  transformJSResource(path, dependency, state) {
+    path.replaceWith(
+      makeJSResourceTemplate({
+        ASYNC_REQUIRE_MODULE_PATH: nullthrows(
+          state.asyncRequireModulePathStringLiteral
+        ),
+        MODULE_ID: createModuleIDExpression(dependency, state),
+        MODULE_NAME: createModuleNameLiteral(dependency)
+      })
+    );
+  },
+
+  transformPrefetch(path, dependency, state) {
+    path.replaceWith(
+      makeAsyncPrefetchTemplate({
+        ASYNC_REQUIRE_MODULE_PATH: nullthrows(
+          state.asyncRequireModulePathStringLiteral
+        ),
+        MODULE_ID: createModuleIDExpression(dependency, state),
+        MODULE_NAME: createModuleNameLiteral(dependency)
+      })
+    );
+  },
+
+  transformIllegalDynamicRequire(path, state) {
+    var _path$node$loc$start$, _path$node$loc;
+
+    path.replaceWith(
+      dynamicRequireErrorTemplate({
+        LINE: types.numericLiteral(
+          (_path$node$loc$start$ =
+            (_path$node$loc = path.node.loc) === null ||
+            _path$node$loc === void 0
+              ? void 0
+              : _path$node$loc.start.line) !== null &&
+            _path$node$loc$start$ !== void 0
+            ? _path$node$loc$start$
+            : 0
+        )
+      })
+    );
+  }
+};
+
+function createModuleIDExpression(dependency, state) {
+  return types.memberExpression(
+    nullthrows(state.dependencyMapIdentifier),
+    types.numericLiteral(dependency.index),
+    true
+  );
+}
+
+function createModuleNameLiteral(dependency) {
+  return types.stringLiteral(dependency.name);
+}
+
+class DefaultModuleDependencyRegistry {
+  constructor() {
+    _defineProperty(this, "_dependencies", new Map());
+  }
+
+  registerDependency(qualifier) {
+    let dependency = this._dependencies.get(qualifier.name);
+
+    if (dependency == null) {
+      const newDependency = {
+        name: qualifier.name,
+        asyncType: qualifier.asyncType,
+        locs: [],
+        index: this._dependencies.size
+      };
+
+      if (qualifier.optional) {
+        newDependency.isOptional = true;
+      }
+
+      dependency = newDependency;
+
+      this._dependencies.set(qualifier.name, dependency);
+    } else {
+      const original = dependency;
+      dependency = collapseDependencies(original, qualifier);
+
+      if (original !== dependency) {
+        this._dependencies.set(qualifier.name, dependency);
+      }
+    }
+
+    return dependency;
+  }
+
+  getDependencies() {
+    return Array.from(this._dependencies.values());
+  }
+}
+
+function collapseDependencies(dependency, qualifier) {
+  let collapsed = dependency; // A previously optionally required dependency was required non-optionaly.
+  // Mark it non optional for the whole module
+
+  if (collapsed.isOptional && !qualifier.optional) {
+    collapsed = _objectSpread(
+      _objectSpread({}, dependency),
+      {},
+      {
+        isOptional: false
+      }
+    );
+  } // A previously asynchronously (or prefetch) required module was required synchronously.
+  // Make the dependency sync.
+
+  if (collapsed.asyncType != null && qualifier.asyncType == null) {
+    collapsed = _objectSpread(
+      _objectSpread({}, dependency),
+      {},
+      {
+        asyncType: null
+      }
+    );
+  } // A prefetched dependency was required async in the module. Mark it as async.
+
+  if (collapsed.asyncType === "prefetch" && qualifier.asyncType === "async") {
+    collapsed = _objectSpread(
+      _objectSpread({}, dependency),
+      {},
+      {
+        asyncType: "async"
+      }
+    );
+  }
+
+  return collapsed;
+}
+
 module.exports = collectDependencies;
diff --git a/node_modules/metro/src/ModuleGraph/worker/collectDependencies.js.flow b/node_modules/metro/src/ModuleGraph/worker/collectDependencies.js.flow
index 1bbb856..2ccbe96 100644
--- a/node_modules/metro/src/ModuleGraph/worker/collectDependencies.js.flow
+++ b/node_modules/metro/src/ModuleGraph/worker/collectDependencies.js.flow
@@ -10,100 +10,122 @@
 
 'use strict';
 
+const invariant = require('invariant');
 const nullthrows = require('nullthrows');
 
 const generate = require('@babel/generator').default;
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
 const template = require('@babel/template').default;
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
 const traverse = require('@babel/traverse').default;
 const types = require('@babel/types');
 
-import type {Ast} from '@babel/core';
+const {isImport} = types;
 
-opaque type Identifier = any;
-opaque type Path = any;
+import type {NodePath} from '@babel/traverse';
+import type {CallExpression, Identifier, StringLiteral} from '@babel/types';
+import type {
+  AllowOptionalDependencies,
+  AsyncDependencyType,
+} from 'metro/src/DeltaBundler/types.flow.js';
 
-type DepOptions = {|
-  +prefetchOnly: boolean,
-|};
+type ImportDependencyOptions = $ReadOnly<{
+  asyncType: AsyncDependencyType,
+  jsResource?: boolean,
+  splitCondition?: NodePath<>,
+}>;
 
-type InternalDependency<D> = {|
-  +data: D,
-  +name: string,
-|};
-
-type InternalDependencyData = {|
-  isAsync: boolean,
-  isPrefetchOnly?: true,
-|};
-
-type InternalDependencyInfo = {|
-  data: InternalDependencyData,
+export type Dependency<TSplitCondition> = $ReadOnly<{
+  data: DependencyData<TSplitCondition>,
+  name: string,
+}>;
+
+type DependencyData<TSplitCondition> = $ReadOnly<{
+  // If null, then the dependency is synchronous.
+  // (ex. `require('foo')`)
+  asyncType: AsyncDependencyType | null,
+  isOptional?: boolean,
+  // If left unspecified, then the dependency is unconditionally split.
+  splitCondition?: TSplitCondition,
+  locs: Array<BabelSourceLocation>,
+}>;
+
+export type MutableInternalDependency<TSplitCondition> = {
+  ...DependencyData<TSplitCondition>,
   index: number,
-|};
+  name: string,
+};
+
+export type InternalDependency<TSplitCondition> = $ReadOnly<
+  MutableInternalDependency<TSplitCondition>,
+>;
 
-type State = {|
-  asyncRequireModulePathStringLiteral: ?Identifier,
-  dependency: number,
+export type State<TSplitCondition> = {
+  asyncRequireModulePathStringLiteral: ?StringLiteral,
   dependencyCalls: Set<string>,
-  dependencyData: Map<string, InternalDependencyData>,
-  dependencyIndexes: Map<string, number>,
+  dependencyRegistry: ModuleDependencyRegistry<TSplitCondition>,
+  dependencyTransformer: DependencyTransformer<TSplitCondition>,
   dynamicRequires: DynamicRequiresBehavior,
   dependencyMapIdentifier: ?Identifier,
   keepRequireNames: boolean,
-  disableRequiresTransform: boolean,
-|};
+  allowOptionalDependencies: AllowOptionalDependencies,
+};
 
-export type Options = {|
-  +asyncRequireModulePath: string,
-  +dynamicRequires: DynamicRequiresBehavior,
-  +inlineableCalls: $ReadOnlyArray<string>,
-  +keepRequireNames: boolean,
-  +disableRequiresTransform?: boolean,
-|};
-
-export type CollectedDependencies = {|
-  +ast: Ast,
-  +dependencyMapName: string,
-  +dependencies: $ReadOnlyArray<Dependency>,
-|};
-
-export type DependencyData = $ReadOnly<InternalDependencyData>;
+export type Options<TSplitCondition = void> = $ReadOnly<{
+  asyncRequireModulePath: string,
+  dependencyMapName?: string,
+  dynamicRequires: DynamicRequiresBehavior,
+  inlineableCalls: $ReadOnlyArray<string>,
+  keepRequireNames: boolean,
+  allowOptionalDependencies: AllowOptionalDependencies,
+  dependencyRegistry?: ModuleDependencyRegistry<TSplitCondition>,
+  dependencyTransformer?: DependencyTransformer<TSplitCondition>,
+}>;
+
+export type CollectedDependencies<+TSplitCondition> = $ReadOnly<{
+  ast: BabelNodeFile,
+  dependencyMapName: string,
+  dependencies: $ReadOnlyArray<Dependency<TSplitCondition>>,
+}>;
+
+// Registry for the dependency of a module.
+// Defines when dependencies should be collapsed.
+// E.g. should a module that's once required optinally and once not
+// be tretaed as the smae or different dependencies.
+export interface ModuleDependencyRegistry<+TSplitCondition> {
+  registerDependency(
+    qualifier: ImportQualifier,
+  ): InternalDependency<TSplitCondition>;
+  getDependencies(): Array<InternalDependency<TSplitCondition>>;
+}
 
-export type Dependency = InternalDependency<DependencyData>;
+export interface DependencyTransformer<-TSplitCondition> {
+  transformSyncRequire(
+    path: NodePath<CallExpression>,
+    dependency: InternalDependency<TSplitCondition>,
+    state: State<TSplitCondition>,
+  ): void;
+  transformImportCall(
+    path: NodePath<>,
+    dependency: InternalDependency<TSplitCondition>,
+    state: State<TSplitCondition>,
+  ): void;
+  transformJSResource(
+    path: NodePath<>,
+    dependency: InternalDependency<TSplitCondition>,
+    state: State<TSplitCondition>,
+  ): void;
+  transformPrefetch(
+    path: NodePath<>,
+    dependency: InternalDependency<TSplitCondition>,
+    state: State<TSplitCondition>,
+  ): void;
+  transformIllegalDynamicRequire(
+    path: NodePath<>,
+    state: State<TSplitCondition>,
+  ): void;
+}
 
 export type DynamicRequiresBehavior = 'throwAtRuntime' | 'reject';
 
-/**
- * Produces a Babel template that will throw at runtime when the require call
- * is reached. This makes dynamic require errors catchable by libraries that
- * want to use them.
- */
-const dynamicRequireErrorTemplate = template(`
-  (function(line) {
-    throw new Error(
-      'Dynamic require defined at line ' + line + '; not supported by Metro',
-    );
-  })(LINE)
-`);
-
-/**
- * Produces a Babel template that transforms an "import(...)" call into a
- * "require(...)" call to the asyncRequire specified.
- */
-const makeAsyncRequireTemplate = template(`
-  require(ASYNC_REQUIRE_MODULE_PATH)(MODULE_ID, MODULE_NAME)
-`);
-
-const makeAsyncPrefetchTemplate = template(`
-  require(ASYNC_REQUIRE_MODULE_PATH).prefetch(MODULE_ID, MODULE_NAME)
-`);
-
 /**
  * Transform all the calls to `require()` and `import()` in a file into ID-
  * independent code, and return the list of dependencies. For example, a call
@@ -113,64 +135,99 @@ const makeAsyncPrefetchTemplate = template(`
  *
  * The second argument is only provided for debugging purposes.
  */
-function collectDependencies(
-  ast: Ast,
-  options: Options,
-): CollectedDependencies {
+function collectDependencies<TSplitCondition = void>(
+  ast: BabelNodeFile,
+  options: Options<TSplitCondition>,
+): CollectedDependencies<TSplitCondition> {
   const visited = new WeakSet();
 
-  const state: State = {
+  const state: State<TSplitCondition> = {
     asyncRequireModulePathStringLiteral: null,
-    dependency: 0,
     dependencyCalls: new Set(),
-    dependencyData: new Map(),
-    dependencyIndexes: new Map(),
+    dependencyRegistry:
+      options.dependencyRegistry ?? new DefaultModuleDependencyRegistry(),
+    dependencyTransformer:
+      options.dependencyTransformer ?? DefaultDependencyTransformer,
     dependencyMapIdentifier: null,
     dynamicRequires: options.dynamicRequires,
     keepRequireNames: options.keepRequireNames,
-    disableRequiresTransform: !!options.disableRequiresTransform,
+    allowOptionalDependencies: options.allowOptionalDependencies,
   };
 
   const visitor = {
-    CallExpression(path: Path, state: State) {
+    CallExpression(path, state): void {
       if (visited.has(path.node)) {
         return;
       }
 
-      const callee = path.get('callee');
-      const name = callee.node.name;
+      const callee = path.node.callee;
+      const name = callee.type === 'Identifier' ? callee.name : null;
 
-      if (callee.isImport()) {
-        processImportCall(path, state, {prefetchOnly: false});
+      if (isImport(callee)) {
+        processImportCall(path, state, {
+          asyncType: 'async',
+        });
         return;
       }
 
       if (name === '__prefetchImport' && !path.scope.getBinding(name)) {
-        processImportCall(path, state, {prefetchOnly: true});
+        processImportCall(path, state, {
+          asyncType: 'prefetch',
+        });
         return;
       }
 
-      if (state.dependencyCalls.has(name) && !path.scope.getBinding(name)) {
-        visited.add(processRequireCall(path, state).node);
+      if (name === '__jsResource' && !path.scope.getBinding(name)) {
+        processImportCall(path, state, {
+          asyncType: 'async',
+          jsResource: true,
+        });
+        return;
       }
-    },
 
-    ImportDeclaration(path: Path, state: State) {
-      const dep = getDependency(state, path.node.source.value, {
-        prefetchOnly: false,
-      });
+      if (
+        name === '__conditionallySplitJSResource' &&
+        !path.scope.getBinding(name)
+      ) {
+        const args = path.get('arguments');
+        invariant(Array.isArray(args), 'Expected arguments to be an array');
+
+        processImportCall(path, state, {
+          asyncType: 'async',
+          jsResource: true,
+          splitCondition: args[1],
+        });
+        return;
+      }
 
-      dep.data.isAsync = false;
+      if (
+        name != null &&
+        state.dependencyCalls.has(name) &&
+        !path.scope.getBinding(name)
+      ) {
+        processRequireCall(path, state);
+        visited.add(path.node);
+      }
     },
 
-    Program(path: Path, state: State) {
+    ImportDeclaration: collectImports,
+    ExportNamedDeclaration: collectImports,
+    ExportAllDeclaration: collectImports,
+
+    Program(path, state) {
       state.asyncRequireModulePathStringLiteral = types.stringLiteral(
         options.asyncRequireModulePath,
       );
 
-      state.dependencyMapIdentifier = path.scope.generateUidIdentifier(
-        'dependencyMap',
-      );
+      if (options.dependencyMapName != null) {
+        state.dependencyMapIdentifier = types.identifier(
+          options.dependencyMapName,
+        );
+      } else {
+        state.dependencyMapIdentifier = path.scope.generateUidIdentifier(
+          'dependencyMap',
+        );
+      }
 
       state.dependencyCalls = new Set(['require', ...options.inlineableCalls]);
     },
@@ -178,11 +235,15 @@ function collectDependencies(
 
   traverse(ast, visitor, null, state);
 
+  const collectedDependencies = state.dependencyRegistry.getDependencies();
   // Compute the list of dependencies.
-  const dependencies = new Array(state.dependency);
+  const dependencies = new Array(collectedDependencies.length);
 
-  for (const [name, data] of state.dependencyData) {
-    dependencies[nullthrows(state.dependencyIndexes.get(name))] = {name, data};
+  for (const {index, name, ...dependencyData} of collectedDependencies) {
+    dependencies[index] = {
+      name,
+      data: dependencyData,
+    };
   }
 
   return {
@@ -192,120 +253,167 @@ function collectDependencies(
   };
 }
 
-function processImportCall(
-  path: Path,
-  state: State,
-  options: DepOptions,
-): Path {
+function collectImports<TSplitCondition>(
+  path: NodePath<>,
+  state: State<TSplitCondition>,
+): void {
+  if (path.node.source) {
+    registerDependency(
+      state,
+      {
+        name: path.node.source.value,
+        asyncType: null,
+        optional: false,
+      },
+      path,
+    );
+  }
+}
+
+function processImportCall<TSplitCondition>(
+  path: NodePath<CallExpression>,
+  state: State<TSplitCondition>,
+  options: ImportDependencyOptions,
+): void {
   const name = getModuleNameFromCallArgs(path);
 
   if (name == null) {
     throw new InvalidRequireCallError(path);
   }
 
-  const dep = getDependency(state, name, options);
-  if (!options.prefetchOnly) {
-    delete dep.data.isPrefetchOnly;
-  }
-  if (state.disableRequiresTransform) {
-    return path;
-  }
-
-  const ASYNC_REQUIRE_MODULE_PATH = state.asyncRequireModulePathStringLiteral;
-  const MODULE_ID = types.memberExpression(
-    state.dependencyMapIdentifier,
-    types.numericLiteral(dep.index),
-    true,
+  const dep = registerDependency(
+    state,
+    {
+      name,
+      asyncType: options.asyncType,
+      splitCondition: options.splitCondition,
+      optional: isOptionalDependency(name, path, state),
+    },
+    path,
   );
-  const MODULE_NAME = types.stringLiteral(name);
 
-  if (!options.prefetchOnly) {
-    path.replaceWith(
-      makeAsyncRequireTemplate({
-        ASYNC_REQUIRE_MODULE_PATH,
-        MODULE_ID,
-        MODULE_NAME,
-      }),
-    );
+  const transformer = state.dependencyTransformer;
+
+  if (options.jsResource) {
+    transformer.transformJSResource(path, dep, state);
+  } else if (options.asyncType === 'async') {
+    transformer.transformImportCall(path, dep, state);
   } else {
-    path.replaceWith(
-      makeAsyncPrefetchTemplate({
-        ASYNC_REQUIRE_MODULE_PATH,
-        MODULE_ID,
-        MODULE_NAME,
-      }),
-    );
+    transformer.transformPrefetch(path, dep, state);
   }
-
-  return path;
 }
 
-function processRequireCall(path: Path, state: State): Path {
+function processRequireCall<TSplitCondition>(
+  path: NodePath<CallExpression>,
+  state: State<TSplitCondition>,
+): void {
   const name = getModuleNameFromCallArgs(path);
 
+  const transformer = state.dependencyTransformer;
+
   if (name == null) {
     if (state.dynamicRequires === 'reject') {
       throw new InvalidRequireCallError(path);
     }
 
-    path.replaceWith(
-      dynamicRequireErrorTemplate({
-        LINE: '' + path.node.loc.start.line,
-      }),
-    );
-    return path;
+    transformer.transformIllegalDynamicRequire(path, state);
+    return;
   }
 
-  const dep = getDependency(state, name, {prefetchOnly: false});
-  dep.data.isAsync = false;
-  delete dep.data.isPrefetchOnly;
+  const dep = registerDependency(
+    state,
+    {
+      name,
+      asyncType: null,
+      optional: isOptionalDependency(name, path, state),
+    },
+    path,
+  );
+
+  transformer.transformSyncRequire(path, dep, state);
+}
 
-  if (state.disableRequiresTransform) {
-    return path;
+function getNearestLocFromPath(path: NodePath<>): ?BabelSourceLocation {
+  let current = path;
+  while (current && !current.node.loc) {
+    current = current.parentPath;
   }
+  return current?.node.loc;
+}
 
-  const moduleIDExpression = types.memberExpression(
-    state.dependencyMapIdentifier,
-    types.numericLiteral(dep.index),
-    true,
-  );
-
-  path.node.arguments = state.keepRequireNames
-    ? [moduleIDExpression, types.stringLiteral(name)]
-    : [moduleIDExpression];
+export type ImportQualifier = $ReadOnly<{
+  name: string,
+  asyncType: AsyncDependencyType | null,
+  splitCondition?: NodePath<>,
+  optional: boolean,
+}>;
+
+function registerDependency<TSplitCondition>(
+  state: State<TSplitCondition>,
+  qualifier: ImportQualifier,
+  path: NodePath<>,
+): InternalDependency<TSplitCondition> {
+  const dependency = state.dependencyRegistry.registerDependency(qualifier);
+
+  const loc = getNearestLocFromPath(path);
+  if (loc != null) {
+    dependency.locs.push(loc);
+  }
 
-  return path;
+  return dependency;
 }
 
-function getDependency(
-  state: State,
+function isOptionalDependency<TSplitCondition>(
   name: string,
-  options: DepOptions,
-): InternalDependencyInfo {
-  let index = state.dependencyIndexes.get(name);
-  let data: ?InternalDependencyData = state.dependencyData.get(name);
+  path: NodePath<>,
+  state: State<TSplitCondition>,
+): boolean {
+  const {allowOptionalDependencies} = state;
+
+  // The async require module is a 'built-in'. Resolving should never fail -> treat it as non-optional.
+  if (name === state.asyncRequireModulePathStringLiteral?.value) {
+    return false;
+  }
 
-  if (!data) {
-    index = state.dependency++;
-    data = {isAsync: true};
+  const isExcluded = () =>
+    Array.isArray(allowOptionalDependencies.exclude) &&
+    allowOptionalDependencies.exclude.includes(name);
 
-    if (options.prefetchOnly) {
-      data.isPrefetchOnly = true;
-    }
+  if (!allowOptionalDependencies || isExcluded()) {
+    return false;
+  }
 
-    state.dependencyIndexes.set(name, index);
-    state.dependencyData.set(name, data);
+  // Valid statement stack for single-level try-block: expressionStatement -> blockStatement -> tryStatement
+  let sCount = 0;
+  let p = path;
+  while (p && sCount < 3) {
+    if (p.isStatement()) {
+      if (p.node.type === 'BlockStatement') {
+        // A single-level should have the tryStatement immediately followed BlockStatement
+        // with the key 'block' to distinguish from the finally block, which has key = 'finalizer'
+        return (
+          p.parentPath != null &&
+          p.parentPath.node.type === 'TryStatement' &&
+          p.key === 'block'
+        );
+      }
+      sCount += 1;
+    }
+    p = p.parentPath;
   }
 
-  return {index: nullthrows(index), data: nullthrows(data)};
+  return false;
 }
 
-function getModuleNameFromCallArgs(path: Path): ?string {
-  if (path.get('arguments').length !== 1) {
+function getModuleNameFromCallArgs(path: NodePath<CallExpression>): ?string {
+  const expectedCount =
+    path.node.callee.name === '__conditionallySplitJSResource' ? 2 : 1;
+  const args = path.get('arguments');
+  if (!Array.isArray(args) || args.length !== expectedCount) {
     throw new InvalidRequireCallError(path);
   }
 
-  const result = path.get('arguments.0').evaluate();
+  const result = args[0].evaluate();
 
   if (result.confident && typeof result.value === 'string') {
     return result.value;
@@ -316,7 +424,7 @@ function getModuleNameFromCallArgs(path: Path): ?string {
 collectDependencies.getModuleNameFromCallArgs = getModuleNameFromCallArgs;
 
 class InvalidRequireCallError extends Error {
-  constructor({node}) {
+  constructor({node}: any) {
     const line = node.loc && node.loc.start && node.loc.start.line;
 
     super(
@@ -327,4 +435,190 @@ class InvalidRequireCallError extends Error {
 
 collectDependencies.InvalidRequireCallError = InvalidRequireCallError;
 
+/**
+ * Produces a Babel template that will throw at runtime when the require call
+ * is reached. This makes dynamic require errors catchable by libraries that
+ * want to use them.
+ */
+const dynamicRequireErrorTemplate = template.statement(`
+  (function(line) {
+    throw new Error(
+      'Dynamic require defined at line ' + line + '; not supported by Metro',
+    );
+  })(LINE)
+`);
+
+/**
+ * Produces a Babel template that transforms an "import(...)" call into a
+ * "require(...)" call to the asyncRequire specified.
+ */
+const makeAsyncRequireTemplate = template.statement(`
+  require(ASYNC_REQUIRE_MODULE_PATH)(MODULE_ID, MODULE_NAME)
+`);
+
+const makeAsyncPrefetchTemplate = template.statement(`
+  require(ASYNC_REQUIRE_MODULE_PATH).prefetch(MODULE_ID, MODULE_NAME)
+`);
+
+const makeJSResourceTemplate = template.statement(`
+  require(ASYNC_REQUIRE_MODULE_PATH).resource(MODULE_ID, MODULE_NAME)
+`);
+
+const DefaultDependencyTransformer: DependencyTransformer<mixed> = {
+  transformSyncRequire(
+    path: NodePath<CallExpression>,
+    dependency: InternalDependency<mixed>,
+    state: State<mixed>,
+  ): void {
+    const moduleIDExpression = createModuleIDExpression(dependency, state);
+    path.node.arguments = state.keepRequireNames
+      ? [moduleIDExpression, types.stringLiteral(dependency.name)]
+      : [moduleIDExpression];
+  },
+
+  transformImportCall(
+    path: NodePath<>,
+    dependency: InternalDependency<mixed>,
+    state: State<mixed>,
+  ): void {
+    path.replaceWith(
+      makeAsyncRequireTemplate({
+        ASYNC_REQUIRE_MODULE_PATH: nullthrows(
+          state.asyncRequireModulePathStringLiteral,
+        ),
+        MODULE_ID: createModuleIDExpression(dependency, state),
+        MODULE_NAME: createModuleNameLiteral(dependency),
+      }),
+    );
+  },
+
+  transformJSResource(
+    path: NodePath<>,
+    dependency: InternalDependency<mixed>,
+    state: State<mixed>,
+  ): void {
+    path.replaceWith(
+      makeJSResourceTemplate({
+        ASYNC_REQUIRE_MODULE_PATH: nullthrows(
+          state.asyncRequireModulePathStringLiteral,
+        ),
+        MODULE_ID: createModuleIDExpression(dependency, state),
+        MODULE_NAME: createModuleNameLiteral(dependency),
+      }),
+    );
+  },
+
+  transformPrefetch(
+    path: NodePath<>,
+    dependency: InternalDependency<mixed>,
+    state: State<mixed>,
+  ): void {
+    path.replaceWith(
+      makeAsyncPrefetchTemplate({
+        ASYNC_REQUIRE_MODULE_PATH: nullthrows(
+          state.asyncRequireModulePathStringLiteral,
+        ),
+        MODULE_ID: createModuleIDExpression(dependency, state),
+        MODULE_NAME: createModuleNameLiteral(dependency),
+      }),
+    );
+  },
+
+  transformIllegalDynamicRequire(path: NodePath<>, state: State<mixed>): void {
+    path.replaceWith(
+      dynamicRequireErrorTemplate({
+        LINE: types.numericLiteral(path.node.loc?.start.line ?? 0),
+      }),
+    );
+  },
+};
+
+function createModuleIDExpression(
+  dependency: InternalDependency<mixed>,
+  state: State<mixed>,
+) {
+  return types.memberExpression(
+    nullthrows(state.dependencyMapIdentifier),
+    types.numericLiteral(dependency.index),
+    true,
+  );
+}
+
+function createModuleNameLiteral(dependency: InternalDependency<mixed>) {
+  return types.stringLiteral(dependency.name);
+}
+
+class DefaultModuleDependencyRegistry<TSplitCondition = void>
+  implements ModuleDependencyRegistry<TSplitCondition> {
+  _dependencies: Map<string, InternalDependency<TSplitCondition>> = new Map();
+
+  registerDependency(
+    qualifier: ImportQualifier,
+  ): InternalDependency<TSplitCondition> {
+    let dependency: ?InternalDependency<TSplitCondition> = this._dependencies.get(
+      qualifier.name,
+    );
+
+    if (dependency == null) {
+      const newDependency: MutableInternalDependency<TSplitCondition> = {
+        name: qualifier.name,
+        asyncType: qualifier.asyncType,
+        locs: [],
+        index: this._dependencies.size,
+      };
+
+      if (qualifier.optional) {
+        newDependency.isOptional = true;
+      }
+
+      dependency = newDependency;
+      this._dependencies.set(qualifier.name, dependency);
+    } else {
+      const original = dependency;
+      dependency = collapseDependencies(original, qualifier);
+      if (original !== dependency) {
+        this._dependencies.set(qualifier.name, dependency);
+      }
+    }
+
+    return dependency;
+  }
+
+  getDependencies(): Array<InternalDependency<TSplitCondition>> {
+    return Array.from(this._dependencies.values());
+  }
+}
+
+function collapseDependencies<TSplitCondition>(
+  dependency: InternalDependency<TSplitCondition>,
+  qualifier: ImportQualifier,
+): InternalDependency<TSplitCondition> {
+  let collapsed = dependency;
+
+  // A previously optionally required dependency was required non-optionaly.
+  // Mark it non optional for the whole module
+  if (collapsed.isOptional && !qualifier.optional) {
+    collapsed = {
+      ...dependency,
+      isOptional: false,
+    };
+  }
+
+  // A previously asynchronously (or prefetch) required module was required synchronously.
+  // Make the dependency sync.
+  if (collapsed.asyncType != null && qualifier.asyncType == null) {
+    collapsed = {...dependency, asyncType: null};
+  }
+
+  // A prefetched dependency was required async in the module. Mark it as async.
+  if (collapsed.asyncType === 'prefetch' && qualifier.asyncType === 'async') {
+    collapsed = {
+      ...dependency,
+      asyncType: 'async',
+    };
+  }
+
+  return collapsed;
+}
+
 module.exports = collectDependencies;
diff --git a/node_modules/metro/src/ModuleGraph/worker/generate.js b/node_modules/metro/src/ModuleGraph/worker/generate.js
index 7973498..a687107 100644
--- a/node_modules/metro/src/ModuleGraph/worker/generate.js
+++ b/node_modules/metro/src/ModuleGraph/worker/generate.js
@@ -5,18 +5,18 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
 const babelGenerate = require("@babel/generator").default;
 
-function generate(ast, filename, sourceCode, compact) {
+function generate(ast, filename, sourceCode) {
   const generated = babelGenerate(
     ast,
     {
       comments: false,
-      compact,
+      compact: true,
       filename,
       sourceFileName: filename,
       sourceMaps: true,
diff --git a/node_modules/metro/src/ModuleGraph/worker/generate.js.flow b/node_modules/metro/src/ModuleGraph/worker/generate.js.flow
index 8964cc7..33c45de 100644
--- a/node_modules/metro/src/ModuleGraph/worker/generate.js.flow
+++ b/node_modules/metro/src/ModuleGraph/worker/generate.js.flow
@@ -12,19 +12,18 @@
 
 const babelGenerate = require('@babel/generator').default;
 
-import type {Ast} from '@babel/core';
+import type {GeneratorResult} from '@babel/generator';
 
 function generate(
-  ast: Ast,
+  ast: BabelNode,
   filename: string,
   sourceCode: string,
-  compact: boolean,
 ): GeneratorResult {
   const generated = babelGenerate(
     ast,
     {
       comments: false,
-      compact,
+      compact: true,
       filename,
       sourceFileName: filename,
       sourceMaps: true,
diff --git a/node_modules/metro/src/ModuleGraph/worker/generateImportNames.js b/node_modules/metro/src/ModuleGraph/worker/generateImportNames.js
index 0882d46..bedb30c 100644
--- a/node_modules/metro/src/ModuleGraph/worker/generateImportNames.js
+++ b/node_modules/metro/src/ModuleGraph/worker/generateImportNames.js
@@ -10,16 +10,13 @@
 "use strict";
 
 const nullthrows = require("nullthrows");
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
 
 const traverse = require("@babel/traverse").default;
-
 /**
  * Select unused names for "metroImportDefault" and "metroImportAll", by
  * calling "generateUid".
  */
+
 function generateImportNames(ast) {
   let importDefault;
   let importAll;
@@ -27,6 +24,7 @@ function generateImportNames(ast) {
     Program(path) {
       importAll = path.scope.generateUid("$$_IMPORT_ALL");
       importDefault = path.scope.generateUid("$$_IMPORT_DEFAULT");
+      path.stop();
     }
   });
   return {
diff --git a/node_modules/metro/src/ModuleGraph/worker/generateImportNames.js.flow b/node_modules/metro/src/ModuleGraph/worker/generateImportNames.js.flow
index 75ceba2..bf61379 100644
--- a/node_modules/metro/src/ModuleGraph/worker/generateImportNames.js.flow
+++ b/node_modules/metro/src/ModuleGraph/worker/generateImportNames.js.flow
@@ -11,20 +11,18 @@
 'use strict';
 
 const nullthrows = require('nullthrows');
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
 const traverse = require('@babel/traverse').default;
 
-import type {Ast} from '@babel/core';
-
 /**
  * Select unused names for "metroImportDefault" and "metroImportAll", by
  * calling "generateUid".
  */
 function generateImportNames(
-  ast: Ast,
-): {importAll: string, importDefault: string} {
+  ast: BabelNode,
+): {
+  importAll: string,
+  importDefault: string,
+} {
   let importDefault;
   let importAll;
 
@@ -32,6 +30,8 @@ function generateImportNames(
     Program(path) {
       importAll = path.scope.generateUid('$$_IMPORT_ALL');
       importDefault = path.scope.generateUid('$$_IMPORT_DEFAULT');
+
+      path.stop();
     },
   });
 
diff --git a/node_modules/metro/src/ModuleGraph/worker/mergeSourceMaps.js b/node_modules/metro/src/ModuleGraph/worker/mergeSourceMaps.js
index 336ef13..3efa12a 100644
--- a/node_modules/metro/src/ModuleGraph/worker/mergeSourceMaps.js
+++ b/node_modules/metro/src/ModuleGraph/worker/mergeSourceMaps.js
@@ -5,26 +5,46 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict-local
+ *
  */
-"use strict"; // eslint-disable-next-line lint/flow-no-fixme
-// $FlowFixMe: too hard to type, and they only have a .ts file.
+"use strict"; // $FlowExpectedError: TODO(t67543266): `source-map` is hard to type.
+
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
 
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -39,6 +59,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -70,9 +91,13 @@ function mergeSourceMaps(file, originalMap, secondMap) {
       name: original.name || mapping.name
     });
   });
-  return _objectSpread({}, merged.toJSON(), {
-    sources: inputMap.sources
-  });
+  return _objectSpread(
+    _objectSpread({}, merged.toJSON()),
+    {},
+    {
+      sources: inputMap.sources
+    }
+  );
 }
 
 module.exports = mergeSourceMaps;
diff --git a/node_modules/metro/src/ModuleGraph/worker/mergeSourceMaps.js.flow b/node_modules/metro/src/ModuleGraph/worker/mergeSourceMaps.js.flow
index 3eda557..66efa7e 100644
--- a/node_modules/metro/src/ModuleGraph/worker/mergeSourceMaps.js.flow
+++ b/node_modules/metro/src/ModuleGraph/worker/mergeSourceMaps.js.flow
@@ -10,8 +10,7 @@
 
 'use strict';
 
-// eslint-disable-next-line lint/flow-no-fixme
-// $FlowFixMe: too hard to type, and they only have a .ts file.
+// $FlowExpectedError: TODO(t67543266): `source-map` is hard to type.
 const sourceMap = require('source-map');
 
 import type {MixedSourceMap, BasicSourceMap} from 'metro-source-map';
diff --git a/node_modules/metro/src/ModuleGraph/worker/optimizeDependencies.js b/node_modules/metro/src/ModuleGraph/worker/optimizeDependencies.js
deleted file mode 100644
index 98ec9d6..0000000
--- a/node_modules/metro/src/ModuleGraph/worker/optimizeDependencies.js
+++ /dev/null
@@ -1,125 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @format
- *  strict-local
- */
-"use strict";
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
-
-const traverse = require("@babel/traverse").default;
-
-const babelGenerate = require("@babel/generator").default;
-
-function optimizeDependencies(
-  ast,
-  dependencies,
-  dependencyMapName,
-  requireNames
-) {
-  const visited = new WeakSet();
-  const context = {
-    oldToNewIndex: new Map(),
-    dependencies: []
-  };
-  const visitor = {
-    CallExpression(path) {
-      const node = path.node;
-
-      if (visited.has(node)) {
-        return;
-      }
-
-      if (isRequireCall(node.callee, requireNames)) {
-        processRequireCall(node);
-        visited.add(node);
-      }
-    },
-
-    MemberExpression(path, state) {
-      const node = path.node;
-
-      if (visited.has(node)) {
-        return;
-      }
-
-      if (isDepMapAccess(node, dependencyMapName)) {
-        processDepMapAccess(context, node, dependencies);
-        visited.add(node);
-      }
-    }
-  };
-  traverse(ast, visitor);
-  return context.dependencies;
-}
-
-function isRequireCall(callee, requireNames) {
-  return callee.type === "Identifier" && requireNames.has(callee.name);
-}
-
-function processRequireCall(node) {
-  if (node.arguments.length != 2) {
-    throw new InvalidRequireCallError(
-      "Post-transform calls to require() expect 2 arguments, the first " +
-        "of which has the shape `_dependencyMapName[123]`, " +
-        `but this was found: \`${babelGenerate(node).code}\``
-    );
-  }
-
-  node.arguments = [node.arguments[0]];
-  return node;
-}
-
-function isDepMapAccess(node, depMapName) {
-  return (
-    node.computed &&
-    node.object.type === "Identifier" &&
-    node.object.name === depMapName &&
-    node.property.type === "NumericLiteral"
-  );
-}
-
-function processDepMapAccess(context, node, deps) {
-  const index = node.property.value;
-  const newIx = translateDependencyIndex(context, deps, index);
-
-  if (newIx !== node.property.value) {
-    node.property.value = newIx;
-  }
-}
-
-function translateDependencyIndex(context, deps, index) {
-  let newIndex = context.oldToNewIndex.get(index);
-
-  if (newIndex != null) {
-    return newIndex;
-  }
-
-  const dep = deps[index];
-
-  if (dep == null) {
-    throw new Error(
-      `${index} is not a known module index. Existing mappings: ${deps
-        .map((n, i) => `${i} => ${n.name}`)
-        .join(", ")}`
-    );
-  }
-
-  newIndex = context.dependencies.push(dep) - 1;
-  context.oldToNewIndex.set(index, newIndex);
-  return newIndex;
-}
-
-class InvalidRequireCallError extends Error {
-  constructor(message) {
-    super(message);
-  }
-}
-
-optimizeDependencies.InvalidRequireCallError = InvalidRequireCallError;
-module.exports = optimizeDependencies;
diff --git a/node_modules/metro/src/ModuleGraph/worker/optimizeDependencies.js.flow b/node_modules/metro/src/ModuleGraph/worker/optimizeDependencies.js.flow
deleted file mode 100644
index a30ec43..0000000
--- a/node_modules/metro/src/ModuleGraph/worker/optimizeDependencies.js.flow
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @format
- * @flow strict-local
- */
-
-'use strict';
-
-/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
- * found when Flow v0.99 was deployed. To see the error, delete this comment
- * and run Flow. */
-const traverse = require('@babel/traverse').default;
-
-const babelGenerate = require('@babel/generator').default;
-
-import type {Ast} from '@babel/core';
-import type {TransformResultDependency} from 'metro/src/DeltaBundler';
-
-type Context = {
-  oldToNewIndex: Map<number, number>,
-  dependencies: Array<TransformResultDependency>,
-};
-
-type Dependencies = $ReadOnlyArray<TransformResultDependency>;
-
-function optimizeDependencies(
-  ast: Ast,
-  dependencies: Dependencies,
-  dependencyMapName: string,
-  requireNames: Set<string>,
-): $ReadOnlyArray<TransformResultDependency> {
-  const visited = new WeakSet();
-  const context = {
-    oldToNewIndex: new Map(),
-    dependencies: [],
-  };
-  const visitor = {
-    CallExpression(path) {
-      const {node} = path;
-
-      if (visited.has(node)) {
-        return;
-      }
-      if (isRequireCall(node.callee, requireNames)) {
-        processRequireCall(node);
-        visited.add(node);
-      }
-    },
-    MemberExpression(path, state) {
-      const {node} = path;
-      if (visited.has(node)) {
-        return;
-      }
-      if (isDepMapAccess(node, dependencyMapName)) {
-        processDepMapAccess(context, node, dependencies);
-        visited.add(node);
-      }
-    },
-  };
-  traverse(ast, visitor);
-  return context.dependencies;
-}
-
-function isRequireCall(callee, requireNames: Set<string>): boolean {
-  return callee.type === 'Identifier' && requireNames.has(callee.name);
-}
-
-function processRequireCall(node) {
-  if (node.arguments.length != 2) {
-    throw new InvalidRequireCallError(
-      'Post-transform calls to require() expect 2 arguments, the first ' +
-        'of which has the shape `_dependencyMapName[123]`, ' +
-        `but this was found: \`${babelGenerate(node).code}\``,
-    );
-  }
-  node.arguments = [node.arguments[0]];
-  return node;
-}
-
-function isDepMapAccess(node, depMapName: string): boolean {
-  return (
-    node.computed &&
-    node.object.type === 'Identifier' &&
-    node.object.name === depMapName &&
-    node.property.type === 'NumericLiteral'
-  );
-}
-
-function processDepMapAccess(context: Context, node, deps: Dependencies): void {
-  const index = node.property.value;
-  const newIx = translateDependencyIndex(context, deps, index);
-  if (newIx !== node.property.value) {
-    node.property.value = newIx;
-  }
-}
-
-function translateDependencyIndex(
-  context: Context,
-  deps: Dependencies,
-  index: number,
-): number {
-  let newIndex = context.oldToNewIndex.get(index);
-  if (newIndex != null) {
-    return newIndex;
-  }
-  const dep = deps[index];
-  if (dep == null) {
-    throw new Error(
-      `${index} is not a known module index. Existing mappings: ${deps
-        .map((n: TransformResultDependency, i: number) => `${i} => ${n.name}`)
-        .join(', ')}`,
-    );
-  }
-  newIndex = context.dependencies.push(dep) - 1;
-  context.oldToNewIndex.set(index, newIndex);
-  return newIndex;
-}
-
-class InvalidRequireCallError extends Error {
-  constructor(message: string) {
-    super(message);
-  }
-}
-optimizeDependencies.InvalidRequireCallError = InvalidRequireCallError;
-
-module.exports = optimizeDependencies;
diff --git a/node_modules/metro/src/Server.js b/node_modules/metro/src/Server.js
index da50aa7..2356879 100644
--- a/node_modules/metro/src/Server.js
+++ b/node_modules/metro/src/Server.js
@@ -11,19 +11,27 @@
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -31,6 +39,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -43,6 +52,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
@@ -50,48 +60,85 @@ function _arrayWithHoles(arr) {
   if (Array.isArray(arr)) return arr;
 }
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
@@ -102,6 +149,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -115,12 +163,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -137,6 +188,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -144,74 +196,72 @@ const IncrementalBundler = require("./IncrementalBundler");
 
 const MultipartResponse = require("./Server/MultipartResponse");
 
+const ResourceNotFoundError = require("./IncrementalBundler/ResourceNotFoundError");
+
+const baseBytecodeBundle = require("./DeltaBundler/Serializers/baseBytecodeBundle");
+
 const baseJSBundle = require("./DeltaBundler/Serializers/baseJSBundle");
 
-const bundleToString = require("./lib/bundle-modules/DeltaClient/bundleToString");
+const bundleToBytecode = require("./lib/bundleToBytecode");
 
-const deltaJSBundle = require("./DeltaBundler/Serializers/deltaJSBundle");
+const bundleToString = require("./lib/bundleToString");
 
-const getAllFiles = require("./DeltaBundler/Serializers/getAllFiles");
+const _require = require("@babel/code-frame"),
+  codeFrameColumns = _require.codeFrameColumns;
 
-const getAssets = require("./DeltaBundler/Serializers/getAssets");
+const debug = require("debug")("Metro:Server");
 
-const getGraphId = require("./lib/getGraphId");
+const formatBundlingError = require("./lib/formatBundlingError");
 
-const getRamBundleInfo = require("./DeltaBundler/Serializers/getRamBundleInfo");
+const fs = require("graceful-fs");
 
-const sourceMapString = require("./DeltaBundler/Serializers/sourceMapString");
+const getAllFiles = require("./DeltaBundler/Serializers/getAllFiles");
 
-const splitBundleOptions = require("./lib/splitBundleOptions");
+const getAssets = require("./DeltaBundler/Serializers/getAssets");
 
-const debug = require("debug")("Metro:Server");
+const getGraphId = require("./lib/getGraphId");
 
-const formatBundlingError = require("./lib/formatBundlingError");
+const getRamBundleInfo = require("./DeltaBundler/Serializers/getRamBundleInfo");
 
 const mime = require("mime-types");
 
 const parseOptionsFromUrl = require("./lib/parseOptionsFromUrl");
 
-const transformHelpers = require("./lib/transformHelpers");
-
 const parsePlatformFilePath = require("./node-haste/lib/parsePlatformFilePath");
 
 const path = require("path");
 
-const serializeDeltaJSBundle = require("./DeltaBundler/Serializers/helpers/serializeDeltaJSBundle");
+const sourceMapString = require("./DeltaBundler/Serializers/sourceMapString");
 
-const symbolicate = require("./Server/symbolicate");
+const splitBundleOptions = require("./lib/splitBundleOptions");
 
-const url = require("url");
+const symbolicate = require("./Server/symbolicate");
 
-const ResourceNotFoundError = require("./IncrementalBundler/ResourceNotFoundError");
+const transformHelpers = require("./lib/transformHelpers");
 
-const RevisionNotFoundError = require("./IncrementalBundler/RevisionNotFoundError");
+const url = require("url");
 
-const _require = require("./Assets"),
-  getAsset = _require.getAsset;
+const _require2 = require("metro-hermes-compiler"),
+  BYTECODE_VERSION = _require2.VERSION;
 
-const _require2 = require("./DeltaBundler/Serializers/getExplodedSourceMap"),
-  getExplodedSourceMap = _require2.getExplodedSourceMap;
+const _require3 = require("./Assets"),
+  getAsset = _require3.getAsset;
 
-const _require3 = require("metro-core"),
-  Logger = _require3.Logger,
-  _require3$Logger = _require3.Logger,
-  createActionStartEntry = _require3$Logger.createActionStartEntry,
-  createActionEndEntry = _require3$Logger.createActionEndEntry,
-  log = _require3$Logger.log;
+const _require4 = require("./DeltaBundler/Serializers/getExplodedSourceMap"),
+  getExplodedSourceMap = _require4.getExplodedSourceMap;
 
-function debounceAndBatch(fn, delay) {
-  let timeout;
-  return () => {
-    clearTimeout(timeout);
-    timeout = setTimeout(fn, delay);
-  };
-}
+const _require5 = require("metro-core"),
+  Logger = _require5.Logger,
+  _require5$Logger = _require5.Logger,
+  createActionStartEntry = _require5$Logger.createActionStartEntry,
+  createActionEndEntry = _require5$Logger.createActionEndEntry,
+  log = _require5$Logger.log;
 
 const DELTA_ID_HEADER = "X-Metro-Delta-ID";
 const FILES_CHANGED_COUNT_HEADER = "X-Metro-Files-Changed-Count";
 
 class Server {
-  constructor(config) {
+  constructor(config, options) {
     var _this = this;
 
     _defineProperty(this, "processRequest", (req, res, next) => {
@@ -220,11 +270,11 @@ class Server {
 
     _defineProperty(
       this,
-      "_processDeltaRequest",
+      "_processBundleRequest",
       this._createRequestProcessor({
         createStartEntry(context) {
           return {
-            action_name: "Requesting delta",
+            action_name: "Requesting bundle",
             bundle_url: context.req.url,
             entry_point: context.entryFile,
             bundler: "delta",
@@ -246,66 +296,44 @@ class Server {
               graphId = _ref2.graphId,
               graphOptions = _ref2.graphOptions,
               onProgress = _ref2.onProgress,
-              revisionId = _ref2.revisionId,
               serializerOptions = _ref2.serializerOptions,
               transformOptions = _ref2.transformOptions;
-            // TODO(T34760593): We should eventually move to a model where this
-            // endpoint is placed at /delta/:revisionId, and requesting an unknown revisionId
-            // throws a 404.
-            // However, this would break existing delta clients, since they expect the
-            // endpoint to rebuild the graph, were it not found in cache.
-            let revPromise;
-
-            if (revisionId != null) {
-              revPromise = _this._bundler.getRevision(revisionId);
-            } // Even if we receive a revisionId, it might have expired.
-
-            if (revPromise == null) {
-              revPromise = _this._bundler.getRevisionByGraphId(graphId);
-            }
-
-            let delta;
-            let revision;
-
-            if (revPromise != null) {
-              const prevRevision = yield revPromise;
 
-              var _ref3 = yield _this._bundler.updateGraph(
-                prevRevision,
-                prevRevision.id !== revisionId
-              );
+            const revPromise = _this._bundler.getRevisionByGraphId(graphId);
 
-              delta = _ref3.delta;
-              revision = _ref3.revision;
-            } else {
-              var _ref4 = yield _this._bundler.initializeGraph(
-                entryFile,
-                transformOptions,
-                {
-                  onProgress,
-                  shallow: graphOptions.shallow
-                }
-              );
+            const _yield = yield revPromise != null
+                ? _this._bundler.updateGraph(yield revPromise, false)
+                : _this._bundler.initializeGraph(entryFile, transformOptions, {
+                    onProgress,
+                    shallow: graphOptions.shallow
+                  }),
+              delta = _yield.delta,
+              revision = _yield.revision;
 
-              delta = _ref4.delta;
-              revision = _ref4.revision;
-            }
+            const serializer =
+              _this._config.serializer.customSerializer ||
+              function() {
+                return bundleToString(baseJSBundle.apply(void 0, arguments))
+                  .code;
+              };
 
-            const bundle = deltaJSBundle(
+            const bundle = yield serializer(
               entryFile,
               revision.prepend,
-              delta,
-              revision.id,
               revision.graph,
               {
-                asyncRequireModulePath:
+                asyncRequireModulePath: yield _this._resolveRelativePath(
                   _this._config.transformer.asyncRequireModulePath,
+                  {
+                    transformOptions
+                  }
+                ),
                 processModuleFilter:
                   _this._config.serializer.processModuleFilter,
                 createModuleId: _this._createModuleId,
-                dev: transformOptions.dev,
                 getRunModuleStatement:
                   _this._config.serializer.getRunModuleStatement,
+                dev: transformOptions.dev,
                 projectRoot: _this._config.projectRoot,
                 modulesOnly: serializerOptions.modulesOnly,
                 runBeforeMainModule: _this._config.serializer.getModulesRunBeforeMainModule(
@@ -317,11 +345,15 @@ class Server {
                 inlineSourceMap: serializerOptions.inlineSourceMap
               }
             );
+            const bundleCode =
+              typeof bundle === "string" ? bundle : bundle.code;
             return {
-              numModifiedFiles:
-                delta.added.size + delta.modified.size + delta.deleted.size,
+              numModifiedFiles: delta.reset
+                ? delta.added.size + revision.prepend.length
+                : delta.added.size + delta.modified.size + delta.deleted.size,
+              lastModifiedDate: revision.date,
               nextRevId: revision.id,
-              bundle
+              bundle: bundleCode
             };
           });
 
@@ -330,25 +362,59 @@ class Server {
           };
         })(),
 
-        finish(_ref5) {
-          let mres = _ref5.mres,
-            result = _ref5.result;
-          const bundle = serializeDeltaJSBundle.toJSON(result.bundle);
-          mres.setHeader(
-            FILES_CHANGED_COUNT_HEADER,
-            String(result.numModifiedFiles)
-          );
-          mres.setHeader(DELTA_ID_HEADER, String(result.nextRevId));
-          mres.setHeader("Content-Type", "application/json");
-          mres.setHeader("Content-Length", String(Buffer.byteLength(bundle)));
-          mres.end(bundle);
-        }
+        finish(_ref3) {
+          let req = _ref3.req,
+            mres = _ref3.mres,
+            result = _ref3.result;
+
+          if (
+            // We avoid parsing the dates since the client should never send a more
+            // recent date than the one returned by the Delta Bundler (if that's the
+            // case it's fine to return the whole bundle).
+            req.headers["if-modified-since"] ===
+            result.lastModifiedDate.toUTCString()
+          ) {
+            debug("Responding with 304");
+            mres.writeHead(304);
+            mres.end();
+          } else {
+            mres.setHeader(
+              FILES_CHANGED_COUNT_HEADER,
+              String(result.numModifiedFiles)
+            );
+            mres.setHeader(DELTA_ID_HEADER, String(result.nextRevId));
+            mres.setHeader("Content-Type", "application/javascript");
+            mres.setHeader(
+              "Last-Modified",
+              result.lastModifiedDate.toUTCString()
+            );
+            mres.setHeader(
+              "Content-Length",
+              String(Buffer.byteLength(result.bundle))
+            );
+            mres.end(result.bundle);
+          }
+        },
+
+        delete: (function() {
+          var _ref4 = _asyncToGenerator(function*(_ref5) {
+            let graphId = _ref5.graphId,
+              res = _ref5.res;
+            yield _this._bundler.endGraph(graphId);
+            res.statusCode = 204;
+            res.end();
+          });
+
+          return function _delete(_x2) {
+            return _ref4.apply(this, arguments);
+          };
+        })()
       })
     );
 
     _defineProperty(
       this,
-      "_processBundleRequest",
+      "_processBytecodeBundleRequest",
       this._createRequestProcessor({
         createStartEntry(context) {
           return {
@@ -379,29 +445,23 @@ class Server {
 
             const revPromise = _this._bundler.getRevisionByGraphId(graphId);
 
-            const _ref8 = yield revPromise != null
+            const _yield2 = yield revPromise != null
                 ? _this._bundler.updateGraph(yield revPromise, false)
                 : _this._bundler.initializeGraph(entryFile, transformOptions, {
                     onProgress,
                     shallow: graphOptions.shallow
                   }),
-              delta = _ref8.delta,
-              revision = _ref8.revision;
+              delta = _yield2.delta,
+              revision = _yield2.revision;
 
-            const serializer =
-              _this._config.serializer.customSerializer ||
-              function() {
-                return bundleToString(baseJSBundle.apply(void 0, arguments))
-                  .code;
-              };
-
-            const bundle = serializer(
-              entryFile,
-              revision.prepend,
-              revision.graph,
-              {
-                asyncRequireModulePath:
+            const bundle = bundleToBytecode(
+              baseBytecodeBundle(entryFile, revision.prepend, revision.graph, {
+                asyncRequireModulePath: yield _this._resolveRelativePath(
                   _this._config.transformer.asyncRequireModulePath,
+                  {
+                    transformOptions
+                  }
+                ),
                 processModuleFilter:
                   _this._config.serializer.processModuleFilter,
                 createModuleId: _this._createModuleId,
@@ -417,7 +477,7 @@ class Server {
                 sourceMapUrl: serializerOptions.sourceMapUrl,
                 sourceUrl: serializerOptions.sourceUrl,
                 inlineSourceMap: serializerOptions.inlineSourceMap
-              }
+              })
             );
             return {
               numModifiedFiles: delta.reset
@@ -425,19 +485,19 @@ class Server {
                 : delta.added.size + delta.modified.size + delta.deleted.size,
               lastModifiedDate: revision.date,
               nextRevId: revision.id,
-              bundle
+              bytecode: bundle.bytecode
             };
           });
 
-          return function build(_x2) {
+          return function build(_x3) {
             return _ref6.apply(this, arguments);
           };
         })(),
 
-        finish(_ref9) {
-          let req = _ref9.req,
-            mres = _ref9.mres,
-            result = _ref9.result;
+        finish(_ref8) {
+          let req = _ref8.req,
+            mres = _ref8.mres,
+            result = _ref8.result;
 
           if (
             // We avoid parsing the dates since the client should never send a more
@@ -455,16 +515,19 @@ class Server {
               String(result.numModifiedFiles)
             );
             mres.setHeader(DELTA_ID_HEADER, String(result.nextRevId));
-            mres.setHeader("Content-Type", "application/javascript");
+            mres.setHeader(
+              "Content-Type",
+              "application/x-metro-bytecode-bundle"
+            );
             mres.setHeader(
               "Last-Modified",
               result.lastModifiedDate.toUTCString()
             );
             mres.setHeader(
               "Content-Length",
-              String(Buffer.byteLength(result.bundle))
+              String(Buffer.byteLength(result.bytecode))
             );
-            mres.end(result.bundle);
+            mres.end(result.bytecode);
           }
         }
       })
@@ -490,19 +553,19 @@ class Server {
         },
 
         build: (function() {
-          var _ref10 = _asyncToGenerator(function*(_ref11) {
-            let entryFile = _ref11.entryFile,
-              graphId = _ref11.graphId,
-              graphOptions = _ref11.graphOptions,
-              onProgress = _ref11.onProgress,
-              serializerOptions = _ref11.serializerOptions,
-              transformOptions = _ref11.transformOptions;
+          var _ref9 = _asyncToGenerator(function*(_ref10) {
+            let entryFile = _ref10.entryFile,
+              graphId = _ref10.graphId,
+              graphOptions = _ref10.graphOptions,
+              onProgress = _ref10.onProgress,
+              serializerOptions = _ref10.serializerOptions,
+              transformOptions = _ref10.transformOptions;
             let revision;
 
             const revPromise = _this._bundler.getRevisionByGraphId(graphId);
 
             if (revPromise == null) {
-              var _ref12 = yield _this._bundler.initializeGraph(
+              var _yield$_this$_bundler = yield _this._bundler.initializeGraph(
                 entryFile,
                 transformOptions,
                 {
@@ -511,9 +574,14 @@ class Server {
                 }
               );
 
-              revision = _ref12.revision;
+              revision = _yield$_this$_bundler.revision;
             } else {
-              revision = yield revPromise;
+              var _yield$_this$_bundler2 = yield _this._bundler.updateGraph(
+                yield revPromise,
+                false
+              );
+
+              revision = _yield$_this$_bundler2.revision;
             }
 
             let _revision = revision,
@@ -525,7 +593,8 @@ class Server {
             }
 
             return sourceMapString(
-              _toConsumableArray(prepend).concat(
+              [].concat(
+                _toConsumableArray(prepend),
                 _toConsumableArray(_this._getSortedModules(graph))
               ),
               {
@@ -536,101 +605,16 @@ class Server {
             );
           });
 
-          return function build(_x3) {
-            return _ref10.apply(this, arguments);
-          };
-        })(),
-
-        finish(_ref13) {
-          let mres = _ref13.mres,
-            result = _ref13.result;
-          mres.setHeader("Content-Type", "application/json");
-          mres.end(result.toString());
-        }
-      })
-    );
-
-    _defineProperty(
-      this,
-      "_processMetadataRequest",
-      this._createRequestProcessor({
-        createStartEntry(context) {
-          return {
-            action_name: "Requesting bundle metadata",
-            bundle_url: context.req.url,
-            entry_point: context.entryFile,
-            bundler: "delta"
-          };
-        },
-
-        createEndEntry(context) {
-          return {
-            bundler: "delta"
-          };
-        },
-
-        build: (function() {
-          var _ref14 = _asyncToGenerator(function*(_ref15) {
-            let entryFile = _ref15.entryFile,
-              transformOptions = _ref15.transformOptions,
-              serializerOptions = _ref15.serializerOptions,
-              onProgress = _ref15.onProgress,
-              revisionId = _ref15.revisionId;
-
-            if (revisionId == null) {
-              throw new Error(
-                "You must provide a `revisionId` query parameter to the metadata endpoint."
-              );
-            }
-
-            let revision;
-
-            const revPromise = _this._bundler.getRevision(revisionId);
-
-            if (revPromise == null) {
-              throw new RevisionNotFoundError(revisionId);
-            } else {
-              revision = yield revPromise;
-            }
-
-            const base = baseJSBundle(
-              entryFile,
-              revision.prepend,
-              revision.graph,
-              {
-                asyncRequireModulePath:
-                  _this._config.transformer.asyncRequireModulePath,
-                processModuleFilter:
-                  _this._config.serializer.processModuleFilter,
-                createModuleId: _this._createModuleId,
-                getRunModuleStatement:
-                  _this._config.serializer.getRunModuleStatement,
-                dev: transformOptions.dev,
-                projectRoot: _this._config.projectRoot,
-                modulesOnly: serializerOptions.modulesOnly,
-                runBeforeMainModule: _this._config.serializer.getModulesRunBeforeMainModule(
-                  path.relative(_this._config.projectRoot, entryFile)
-                ),
-                runModule: serializerOptions.runModule,
-                sourceMapUrl: serializerOptions.sourceMapUrl,
-                sourceUrl: serializerOptions.sourceUrl,
-                inlineSourceMap: serializerOptions.inlineSourceMap
-              }
-            ); // $FlowFixMe the return value of an async function is always a Promise
-
-            return bundleToString(base).metadata;
-          });
-
           return function build(_x4) {
-            return _ref14.apply(this, arguments);
+            return _ref9.apply(this, arguments);
           };
         })(),
 
-        finish(_ref16) {
-          let mres = _ref16.mres,
-            result = _ref16.result;
+        finish(_ref11) {
+          let mres = _ref11.mres,
+            result = _ref11.result;
           mres.setHeader("Content-Type", "application/json");
-          mres.end(JSON.stringify(result));
+          mres.end(result.toString());
         }
       })
     );
@@ -655,22 +639,19 @@ class Server {
         },
 
         build: (function() {
-          var _ref17 = _asyncToGenerator(function*(_ref18) {
-            let entryFile = _ref18.entryFile,
-              transformOptions = _ref18.transformOptions,
-              onProgress = _ref18.onProgress;
-
-            const _ref19 = yield _this._bundler.buildGraph(
-                entryFile,
-                transformOptions,
-                {
-                  onProgress,
-                  shallow: false
-                }
-              ),
-              graph = _ref19.graph;
-
-            return yield getAssets(graph, {
+          var _ref12 = _asyncToGenerator(function*(_ref13) {
+            let entryFile = _ref13.entryFile,
+              transformOptions = _ref13.transformOptions,
+              onProgress = _ref13.onProgress;
+            const dependencies = yield _this._bundler.getDependencies(
+              [entryFile],
+              transformOptions,
+              {
+                onProgress,
+                shallow: false
+              }
+            );
+            return yield getAssets(dependencies, {
               processModuleFilter: _this._config.serializer.processModuleFilter,
               assetPlugins: _this._config.transformer.assetPlugins,
               platform: transformOptions.platform,
@@ -680,13 +661,13 @@ class Server {
           });
 
           return function build(_x5) {
-            return _ref17.apply(this, arguments);
+            return _ref12.apply(this, arguments);
           };
         })(),
 
-        finish(_ref20) {
-          let mres = _ref20.mres,
-            result = _ref20.result;
+        finish(_ref14) {
+          let mres = _ref14.mres,
+            result = _ref14.result;
           mres.setHeader("Content-Type", "application/json");
           mres.end(JSON.stringify(result));
         }
@@ -694,6 +675,7 @@ class Server {
     );
 
     this._config = config;
+    this._serverOptions = options;
 
     if (this._config.resetCache) {
       this._config.cacheStores.forEach(store => store.clear());
@@ -705,7 +687,6 @@ class Server {
 
     this._reporter = config.reporter;
     this._logger = Logger;
-    this._changeWatchers = [];
     this._platforms = new Set(this._config.resolver.platforms);
     this._isEnded = false; // TODO(T34760917): These two properties should eventually be instantiated
     // elsewhere and passed as parameters, since they are also needed by
@@ -713,23 +694,10 @@ class Server {
     // The whole bundling/serializing logic should follow as well.
 
     this._createModuleId = config.serializer.createModuleIdFactory();
-    this._bundler = new IncrementalBundler(config);
-    const debouncedFileChangeHandler = debounceAndBatch(
-      () => this._informChangeWatchers(),
-      50
-    ); // changes to the haste map can affect resolution of files in the bundle
-
-    this._bundler
-      .getBundler()
-      .getDependencyGraph()
-      .then(dependencyGraph => {
-        dependencyGraph.getWatcher().on("change", () => {
-          // Make sure the file watcher event runs through the system before
-          // we rebuild the bundles.
-          debouncedFileChangeHandler();
-        });
-      });
-
+    this._bundler = new IncrementalBundler(config, {
+      hasReducedPerformance: options && options.hasReducedPerformance,
+      watch: options ? options.watch : undefined
+    });
     this._nextBundleBuildID = 1;
   }
 
@@ -760,7 +728,7 @@ class Server {
         serializerOptions = _splitBundleOptions.serializerOptions,
         transformOptions = _splitBundleOptions.transformOptions;
 
-      const _ref21 = yield _this2._bundler.buildGraph(
+      const _yield$_this2$_bundle = yield _this2._bundler.buildGraph(
           entryFile,
           transformOptions,
           {
@@ -768,13 +736,17 @@ class Server {
             shallow: graphOptions.shallow
           }
         ),
-        prepend = _ref21.prepend,
-        graph = _ref21.graph;
+        prepend = _yield$_this2$_bundle.prepend,
+        graph = _yield$_this2$_bundle.graph;
 
       const entryPoint = path.resolve(_this2._config.projectRoot, entryFile);
-      const bundle = baseJSBundle(entryPoint, prepend, graph, {
-        asyncRequireModulePath:
+      const bundleOptions = {
+        asyncRequireModulePath: yield _this2._resolveRelativePath(
           _this2._config.transformer.asyncRequireModulePath,
+          {
+            transformOptions
+          }
+        ),
         processModuleFilter: _this2._config.serializer.processModuleFilter,
         createModuleId: _this2._createModuleId,
         getRunModuleStatement: _this2._config.serializer.getRunModuleStatement,
@@ -788,18 +760,46 @@ class Server {
         sourceMapUrl: serializerOptions.sourceMapUrl,
         sourceUrl: serializerOptions.sourceUrl,
         inlineSourceMap: serializerOptions.inlineSourceMap
-      });
-      return {
-        code: bundleToString(bundle).code,
-        map: sourceMapString(
-          _toConsumableArray(prepend).concat(
+      };
+      let bundleCode = null;
+      let bundleMap = null;
+
+      if (_this2._config.serializer.customSerializer) {
+        const bundle = yield _this2._config.serializer.customSerializer(
+          entryPoint,
+          prepend,
+          graph,
+          bundleOptions
+        );
+
+        if (typeof bundle === "string") {
+          bundleCode = bundle;
+        } else {
+          bundleCode = bundle.code;
+          bundleMap = bundle.map;
+        }
+      } else {
+        bundleCode = bundleToString(
+          baseJSBundle(entryPoint, prepend, graph, bundleOptions)
+        ).code;
+      }
+
+      if (!bundleMap) {
+        bundleMap = sourceMapString(
+          [].concat(
+            _toConsumableArray(prepend),
             _toConsumableArray(_this2._getSortedModules(graph))
           ),
           {
             excludeSource: serializerOptions.excludeSource,
             processModuleFilter: _this2._config.serializer.processModuleFilter
           }
-        )
+        );
+      }
+
+      return {
+        code: bundleCode,
+        map: bundleMap
       };
     })();
   }
@@ -815,7 +815,7 @@ class Server {
         serializerOptions = _splitBundleOptions2.serializerOptions,
         transformOptions = _splitBundleOptions2.transformOptions;
 
-      const _ref22 = yield _this3._bundler.buildGraph(
+      const _yield$_this3$_bundle = yield _this3._bundler.buildGraph(
           entryFile,
           transformOptions,
           {
@@ -823,13 +823,17 @@ class Server {
             shallow: graphOptions.shallow
           }
         ),
-        prepend = _ref22.prepend,
-        graph = _ref22.graph;
+        prepend = _yield$_this3$_bundle.prepend,
+        graph = _yield$_this3$_bundle.graph;
 
       const entryPoint = path.resolve(_this3._config.projectRoot, entryFile);
       return yield getRamBundleInfo(entryPoint, prepend, graph, {
-        asyncRequireModulePath:
+        asyncRequireModulePath: yield _this3._resolveRelativePath(
           _this3._config.transformer.asyncRequireModulePath,
+          {
+            transformOptions
+          }
+        ),
         processModuleFilter: _this3._config.serializer.processModuleFilter,
         createModuleId: _this3._createModuleId,
         dev: transformOptions.dev,
@@ -859,17 +863,15 @@ class Server {
         transformOptions = _splitBundleOptions3.transformOptions,
         onProgress = _splitBundleOptions3.onProgress;
 
-      const _ref23 = yield _this4._bundler.buildGraph(
-          entryFile,
-          transformOptions,
-          {
-            onProgress,
-            shallow: false
-          }
-        ),
-        graph = _ref23.graph;
-
-      return yield getAssets(graph, {
+      const dependencies = yield _this4._bundler.getDependencies(
+        [entryFile],
+        transformOptions,
+        {
+          onProgress,
+          shallow: false
+        }
+      );
+      return yield getAssets(dependencies, {
         processModuleFilter: _this4._config.serializer.processModuleFilter,
         assetPlugins: _this4._config.transformer.assetPlugins,
         platform: transformOptions.platform,
@@ -883,16 +885,26 @@ class Server {
     var _this5 = this;
 
     return _asyncToGenerator(function*() {
+      /* $FlowFixMe(>=0.122.0 site=react_native_fb) This comment suppresses an
+       * error found when Flow v0.122.0 was deployed. To see the error, delete
+       * this comment and run Flow. */
       const _splitBundleOptions4 = splitBundleOptions(
-          _objectSpread({}, Server.DEFAULT_BUNDLE_OPTIONS, options, {
-            bundleType: "bundle"
-          })
+          _objectSpread(
+            _objectSpread(
+              _objectSpread({}, Server.DEFAULT_BUNDLE_OPTIONS),
+              options
+            ),
+            {},
+            {
+              bundleType: "bundle"
+            }
+          )
         ),
         entryFile = _splitBundleOptions4.entryFile,
         transformOptions = _splitBundleOptions4.transformOptions,
         onProgress = _splitBundleOptions4.onProgress;
 
-      const _ref24 = yield _this5._bundler.buildGraph(
+      const _yield$_this5$_bundle = yield _this5._bundler.buildGraph(
           entryFile,
           transformOptions,
           {
@@ -900,8 +912,8 @@ class Server {
             shallow: false
           }
         ),
-        prepend = _ref24.prepend,
-        graph = _ref24.graph;
+        prepend = _yield$_this5$_bundle.prepend,
+        graph = _yield$_this5$_bundle.graph;
 
       const platform =
         transformOptions.platform ||
@@ -913,38 +925,6 @@ class Server {
     })();
   }
 
-  _informChangeWatchers() {
-    const watchers = this._changeWatchers;
-    const headers = {
-      "Content-Type": "application/json; charset=UTF-8"
-    };
-    watchers.forEach(function(w) {
-      w.res.writeHead(205, headers);
-      w.res.end(
-        JSON.stringify({
-          changed: true
-        })
-      );
-    });
-    this._changeWatchers = [];
-  }
-
-  _processOnChangeRequest(req, res) {
-    const watchers = this._changeWatchers;
-    watchers.push({
-      req,
-      res
-    });
-    req.on("close", () => {
-      for (let i = 0; i < watchers.length; i++) {
-        if (watchers[i] && watchers[i].req === req) {
-          watchers.splice(i, 1);
-          break;
-        }
-      }
-    });
-  }
-
   _rangeRequestMiddleware(req, res, data, assetPath) {
     if (req.headers && req.headers.range) {
       const _req$headers$range$re = req.headers.range
@@ -993,7 +973,6 @@ class Server {
           assetPath[1],
           _this6._config.projectRoot,
           _this6._config.watchFolders,
-          /* $FlowFixMe: query may be empty for invalid URLs */
           urlObj.query.platform,
           _this6._config.resolver.assetExts
         ); // Tell clients to cache this for 1 year.
@@ -1015,223 +994,353 @@ class Server {
     })();
   }
 
+  _parseOptions(url) {
+    return parseOptionsFromUrl(
+      url,
+      new Set(this._config.resolver.platforms),
+      BYTECODE_VERSION
+    );
+  }
+
   _processRequest(req, res, next) {
     var _this7 = this;
 
     return _asyncToGenerator(function*() {
+      const originalUrl = req.url;
+      req.url = _this7._config.server.rewriteRequestUrl(req.url);
       const urlObj = url.parse(req.url, true);
       const host = req.headers.host;
-      debug(`Handling request: ${host ? "http://" + host : ""}${req.url}`);
-      /* $FlowFixMe: Could be empty if the URL is invalid. */
-
-      const pathname = urlObj.pathname;
-
-      if (pathname.match(/\.bundle$/)) {
-        yield _this7._processBundleRequest(req, res);
-      } else if (pathname.match(/\.map$/)) {
-        yield _this7._processSourceMapRequest(req, res);
-      } else if (pathname.match(/\.assets$/)) {
-        yield _this7._processAssetsRequest(req, res);
-      } else if (pathname.match(/\.delta$/)) {
-        yield _this7._processDeltaRequest(req, res);
-      } else if (pathname.match(/\.meta/)) {
-        yield _this7._processMetadataRequest(req, res);
-      } else if (pathname.match(/^\/onchange\/?$/)) {
-        _this7._processOnChangeRequest(req, res);
-      } else if (pathname.match(/^\/assets\//)) {
+      debug(
+        `Handling request: ${host ? "http://" + host : ""}${req.url}` +
+          (originalUrl !== req.url ? ` (rewritten from ${originalUrl})` : "")
+      );
+      const formattedUrl = url.format(
+        _objectSpread(
+          _objectSpread({}, urlObj),
+          {},
+          {
+            host,
+            protocol: "http"
+          }
+        )
+      );
+      const pathname = urlObj.pathname || "";
+
+      if (pathname.endsWith(".bundle")) {
+        const options = _this7._parseOptions(formattedUrl);
+
+        if (options.runtimeBytecodeVersion) {
+          yield _this7._processBytecodeBundleRequest(req, res, options);
+        } else {
+          yield _this7._processBundleRequest(req, res, options);
+        }
+
+        if (_this7._serverOptions && _this7._serverOptions.onBundleBuilt) {
+          _this7._serverOptions.onBundleBuilt(pathname);
+        }
+      } else if (pathname.endsWith(".map")) {
+        // Chrome dev tools may need to access the source maps.
+        res.setHeader("Access-Control-Allow-Origin", "devtools://devtools");
+        yield _this7._processSourceMapRequest(
+          req,
+          res,
+          _this7._parseOptions(formattedUrl)
+        );
+      } else if (pathname.endsWith(".assets")) {
+        yield _this7._processAssetsRequest(
+          req,
+          res,
+          _this7._parseOptions(formattedUrl)
+        );
+      } else if (pathname.startsWith("/assets/")) {
         yield _this7._processSingleAssetRequest(req, res);
       } else if (pathname === "/symbolicate") {
-        _this7._symbolicate(req, res);
+        yield _this7._symbolicate(req, res);
       } else {
         next();
       }
     })();
   }
 
-  _createRequestProcessor(_ref25) {
-    let createStartEntry = _ref25.createStartEntry,
-      createEndEntry = _ref25.createEndEntry,
-      build = _ref25.build,
-      finish = _ref25.finish;
-    return (
-      /*#__PURE__*/
-      (function() {
-        var _requestProcessor = _asyncToGenerator(function*(req, res) {
-          const mres = MultipartResponse.wrap(req, res);
-
-          const _parseOptionsFromUrl = parseOptionsFromUrl(
-              url.format(
-                _objectSpread({}, url.parse(req.url), {
-                  protocol: "http",
-                  host: req.headers.host
-                })
-              ),
-              new Set(this._config.resolver.platforms)
-            ),
-            revisionId = _parseOptionsFromUrl.revisionId,
-            bundleOptions = _parseOptionsFromUrl.options;
-
-          const _splitBundleOptions5 = splitBundleOptions(bundleOptions),
-            entryFile = _splitBundleOptions5.entryFile,
-            graphOptions = _splitBundleOptions5.graphOptions,
-            transformOptions = _splitBundleOptions5.transformOptions,
-            serializerOptions = _splitBundleOptions5.serializerOptions;
-          /**
-           * `entryFile` is relative to projectRoot, we need to use resolution function
-           * to find the appropriate file with supported extensions.
-           */
-
-          const resolutionFn = yield transformHelpers.getResolveDependencyFn(
-            this._bundler.getBundler(),
-            transformOptions.platform
-          );
-          const resolvedEntryFilePath = resolutionFn(
-            `${this._config.projectRoot}/.`,
-            entryFile
-          );
-          const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {
-            shallow: graphOptions.shallow,
-            experimentalImportBundleSupport: this._config.transformer
-              .experimentalImportBundleSupport
-          });
-          const buildID = this.getNewBuildID();
-          let onProgress = null;
-
-          if (this._config.reporter) {
-            onProgress = (transformedFileCount, totalFileCount) => {
-              mres.writeChunk(
-                {
-                  "Content-Type": "application/json"
-                },
-                JSON.stringify({
-                  done: transformedFileCount,
-                  total: totalFileCount
-                })
-              );
-
-              this._reporter.update({
-                buildID,
-                type: "bundle_transform_progressed",
-                transformedFileCount,
-                totalFileCount
-              });
-            };
+  _createRequestProcessor(_ref15) {
+    let createStartEntry = _ref15.createStartEntry,
+      createEndEntry = _ref15.createEndEntry,
+      build = _ref15.build,
+      deleteFn = _ref15.delete,
+      finish = _ref15.finish;
+    return /*#__PURE__*/ (function() {
+      var _requestProcessor = _asyncToGenerator(function*(
+        req,
+        res,
+        bundleOptions
+      ) {
+        const _splitBundleOptions5 = splitBundleOptions(bundleOptions),
+          entryFile = _splitBundleOptions5.entryFile,
+          graphOptions = _splitBundleOptions5.graphOptions,
+          transformOptions = _splitBundleOptions5.transformOptions,
+          serializerOptions = _splitBundleOptions5.serializerOptions;
+        /**
+         * `entryFile` is relative to projectRoot, we need to use resolution function
+         * to find the appropriate file with supported extensions.
+         */
+
+        const resolvedEntryFilePath = yield this._resolveRelativePath(
+          entryFile,
+          {
+            transformOptions
           }
-
-          this._reporter.update({
-            buildID,
-            bundleDetails: {
-              entryFile: resolvedEntryFilePath,
-              platform: transformOptions.platform,
-              dev: transformOptions.dev,
-              minify: transformOptions.minify,
-              bundleType: bundleOptions.bundleType
-            },
-            type: "bundle_build_started"
-          });
-
-          const startContext = {
-            buildID,
-            bundleOptions,
-            entryFile: resolvedEntryFilePath,
+        );
+        const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {
+          shallow: graphOptions.shallow,
+          experimentalImportBundleSupport: this._config.transformer
+            .experimentalImportBundleSupport
+        }); // For resources that support deletion, handle the DELETE method.
+
+        if (deleteFn && req.method === "DELETE") {
+          const deleteContext = {
             graphId,
-            graphOptions,
-            mres,
-            onProgress,
             req,
-            revisionId,
-            serializerOptions,
-            transformOptions
+            res
           };
-          const logEntry = log(
-            createActionStartEntry(createStartEntry(startContext))
-          );
-          let result;
 
           try {
-            result = yield build(startContext);
+            yield deleteFn(deleteContext);
           } catch (error) {
             const formattedError = formatBundlingError(error);
             const status = error instanceof ResourceNotFoundError ? 404 : 500;
-            mres.writeHead(status, {
+            res.writeHead(status, {
               "Content-Type": "application/json; charset=UTF-8"
             });
-            mres.end(JSON.stringify(formattedError));
+            res.end(JSON.stringify(formattedError));
+          }
 
-            this._reporter.update({
-              error,
-              type: "bundling_error"
-            });
+          return;
+        }
 
-            log({
-              action_name: "bundling_error",
-              error_type: formattedError.type,
-              log_entry_label: "bundling_error",
-              bundle_id: graphId,
-              build_id: buildID,
-              stack: formattedError.message
-            });
+        const mres = MultipartResponse.wrap(req, res);
+        const buildID = this.getNewBuildID();
+        let onProgress = null;
+        let lastProgress = -1;
+
+        if (this._config.reporter) {
+          onProgress = (transformedFileCount, totalFileCount) => {
+            const currentProgress = parseInt(
+              (transformedFileCount / totalFileCount) * 100,
+              10
+            ); // We want to throttle the updates so that we only show meaningful
+            // UI updates slow enough for the client to actually handle them. For
+            // that, we check the percentage, and only send percentages that are
+            // actually different and that have increased from the last one we sent.
+
+            if (currentProgress > lastProgress || totalFileCount < 10) {
+              mres.writeChunk(
+                {
+                  "Content-Type": "application/json"
+                },
+                JSON.stringify({
+                  done: transformedFileCount,
+                  total: totalFileCount
+                })
+              ); // The `uncork` called internally in Node via `promise.nextTick()` may not fire
+              // until all of the Promises are resolved because the microtask queue we're
+              // in could be starving the event loop. This can cause a bug where the progress
+              // is not actually sent in the response until after bundling is complete. This
+              // would defeat the purpose of sending progress, so we `uncork` the stream now
+              // which will force the response to flush to the client immediately.
+
+              if (res.socket != null && res.socket.uncork != null) {
+                res.socket.uncork();
+              }
+
+              lastProgress = currentProgress;
+            }
 
             this._reporter.update({
               buildID,
-              type: "bundle_build_failed",
-              bundleOptions
+              type: "bundle_transform_progressed",
+              transformedFileCount,
+              totalFileCount
             });
+          };
+        }
 
-            return;
-          }
+        this._reporter.update({
+          buildID,
+          bundleDetails: {
+            bundleType: bundleOptions.bundleType,
+            dev: transformOptions.dev,
+            entryFile: resolvedEntryFilePath,
+            minify: transformOptions.minify,
+            platform: transformOptions.platform,
+            runtimeBytecodeVersion: transformOptions.runtimeBytecodeVersion
+          },
+          type: "bundle_build_started"
+        });
 
-          const endContext = _objectSpread({}, startContext, {
-            result
+        const startContext = {
+          buildID,
+          bundleOptions,
+          entryFile: resolvedEntryFilePath,
+          graphId,
+          graphOptions,
+          mres,
+          onProgress,
+          req,
+          serializerOptions,
+          transformOptions
+        };
+        const logEntry = log(
+          createActionStartEntry(createStartEntry(startContext))
+        );
+        let result;
+
+        try {
+          result = yield build(startContext);
+        } catch (error) {
+          const formattedError = formatBundlingError(error);
+          const status = error instanceof ResourceNotFoundError ? 404 : 500;
+          mres.writeHead(status, {
+            "Content-Type": "application/json; charset=UTF-8"
           });
-
-          finish(endContext);
+          mres.end(JSON.stringify(formattedError));
 
           this._reporter.update({
             buildID,
-            type: "bundle_build_done"
+            type: "bundle_build_failed",
+            bundleOptions
           });
 
-          log(
-            createActionEndEntry(
-              _objectSpread({}, logEntry, createEndEntry(endContext))
-            )
-          );
-        });
+          this._reporter.update({
+            error,
+            type: "bundling_error"
+          });
 
-        function requestProcessor(_x6, _x7) {
-          return _requestProcessor.apply(this, arguments);
+          log({
+            action_name: "bundling_error",
+            error_type: formattedError.type,
+            log_entry_label: "bundling_error",
+            bundle_id: graphId,
+            build_id: buildID,
+            stack: formattedError.message
+          });
+          return;
         }
 
-        return requestProcessor;
-      })()
-    );
-  }
+        const endContext = _objectSpread(
+          _objectSpread({}, startContext),
+          {},
+          {
+            result
+          }
+        );
+
+        finish(endContext);
+
+        this._reporter.update({
+          buildID,
+          type: "bundle_build_done"
+        });
+
+        log(
+          /* $FlowFixMe(>=0.122.0 site=react_native_fb) This comment suppresses
+           * an error found when Flow v0.122.0 was deployed. To see the error,
+           * delete this comment and run Flow. */
+          createActionEndEntry(
+            _objectSpread(
+              _objectSpread({}, logEntry),
+              createEndEntry(endContext)
+            )
+          )
+        );
+      });
 
-  // This function ensures that modules in source maps are sorted in the same
+      function requestProcessor(_x6, _x7, _x8) {
+        return _requestProcessor.apply(this, arguments);
+      }
+
+      return requestProcessor;
+    })();
+  } // This function ensures that modules in source maps are sorted in the same
   // order as in a plain JS bundle.
+
   _getSortedModules(graph) {
-    return _toConsumableArray(graph.dependencies.values()).sort(
+    const modules = _toConsumableArray(graph.dependencies.values()); // Assign IDs to modules in a consistent order
+
+    for (const module of modules) {
+      this._createModuleId(module.path);
+    } // Sort by IDs
+
+    return modules.sort(
       (a, b) => this._createModuleId(a.path) - this._createModuleId(b.path)
     );
   }
 
   _symbolicate(req, res) {
-    const symbolicatingLogEntry = log(createActionStartEntry("Symbolicating"));
-    debug("Start symbolication");
-    /* $FlowFixMe: where is `rowBody` defined? Is it added by
-     * the `connect` framework? */
+    var _this8 = this;
 
-    Promise.resolve(req.rawBody)
-      .then(body => {
-        const stack = JSON.parse(body).stack; // In case of multiple bundles / HMR, some stack frames can have
-        // different URLs from others
+    return _asyncToGenerator(function*() {
+      const getCodeFrame = (urls, symbolicatedStack) => {
+        for (let i = 0; i < symbolicatedStack.length; i++) {
+          const _symbolicatedStack$i = symbolicatedStack[i],
+            collapse = _symbolicatedStack$i.collapse,
+            column = _symbolicatedStack$i.column,
+            file = _symbolicatedStack$i.file,
+            lineNumber = _symbolicatedStack$i.lineNumber;
+
+          if (collapse || lineNumber == null || urls.has(file)) {
+            continue;
+          }
+
+          return {
+            content: codeFrameColumns(
+              fs.readFileSync(file, "utf8"),
+              {
+                // Metro returns 0 based columns but codeFrameColumns expects 1-based columns
+                start: {
+                  column: column + 1,
+                  line: lineNumber
+                }
+              },
+              {
+                forceColor: true
+              }
+            ),
+            location: {
+              row: lineNumber,
+              column
+            },
+            fileName: file
+          };
+        }
+
+        return null;
+      };
+
+      try {
+        const symbolicatingLogEntry = log(
+          createActionStartEntry("Symbolicating")
+        );
+        debug("Start symbolication");
+        /* $FlowFixMe: where is `rawBody` defined? Is it added by the `connect` framework? */
+
+        const body = yield req.rawBody;
+        const stack = JSON.parse(body).stack.map(frame => {
+          if (frame.file && frame.file.includes("://")) {
+            return _objectSpread(
+              _objectSpread({}, frame),
+              {},
+              {
+                file: _this8._config.server.rewriteRequestUrl(frame.file)
+              }
+            );
+          }
+
+          return frame;
+        }); // In case of multiple bundles / HMR, some stack frames can have different URLs from others
 
         const urls = new Set();
         stack.forEach(frame => {
-          const sourceUrl = frame.file; // Skip `/debuggerWorker.js` which drives remote debugging because it
-          // does not need to symbolication.
-          // Skip anything except http(s), because there is no support for that yet
+          const sourceUrl = frame.file; // Skip `/debuggerWorker.js` which does not need symbolication.
 
           if (
             sourceUrl != null &&
@@ -1242,50 +1351,47 @@ class Server {
             urls.add(sourceUrl);
           }
         });
-        const mapPromises = Array.from(urls.values()).map(
-          this._explodedSourceMapForURL,
-          this
-        );
         debug("Getting source maps for symbolication");
-        return Promise.all(mapPromises).then(maps => {
-          debug("Performing fast symbolication");
-          const urlsToMaps = zip(urls.values(), maps);
-          return symbolicate(stack, urlsToMaps, this._config);
+        const sourceMaps = yield Promise.all(
+          Array.from(urls.values()).map(_this8._explodedSourceMapForURL, _this8)
+        );
+        debug("Performing fast symbolication");
+        const symbolicatedStack = yield symbolicate(
+          stack,
+          zip(urls.values(), sourceMaps),
+          _this8._config
+        );
+        debug("Symbolication done");
+        res.end(
+          JSON.stringify({
+            codeFrame: getCodeFrame(urls, symbolicatedStack),
+            stack: symbolicatedStack
+          })
+        );
+        process.nextTick(() => {
+          log(createActionEndEntry(symbolicatingLogEntry));
         });
-      })
-      .then(
-        stack => {
-          debug("Symbolication done");
-          res.end(
-            JSON.stringify({
-              stack
-            })
-          );
-          process.nextTick(() => {
-            log(createActionEndEntry(symbolicatingLogEntry));
-          });
-        },
-        error => {
-          console.error(error.stack || error);
-          res.statusCode = 500;
-          res.end(
-            JSON.stringify({
-              error: error.message
-            })
-          );
-        }
-      );
+      } catch (error) {
+        console.error(error.stack || error);
+        res.statusCode = 500;
+        res.end(
+          JSON.stringify({
+            error: error.message
+          })
+        );
+      }
+    })();
   }
 
   _explodedSourceMapForURL(reqUrl) {
-    var _this8 = this;
+    var _this9 = this;
 
     return _asyncToGenerator(function*() {
-      const _parseOptionsFromUrl2 = parseOptionsFromUrl(
-          reqUrl,
-          new Set(_this8._config.resolver.platforms)
-        ),
-        options = _parseOptionsFromUrl2.options;
+      const options = parseOptionsFromUrl(
+        reqUrl,
+        new Set(_this9._config.resolver.platforms),
+        BYTECODE_VERSION
+      );
 
       const _splitBundleOptions6 = splitBundleOptions(options),
         entryFile = _splitBundleOptions6.entryFile,
@@ -1298,25 +1404,23 @@ class Server {
        * to find the appropriate file with supported extensions.
        */
 
-      const resolutionFn = yield transformHelpers.getResolveDependencyFn(
-        _this8._bundler.getBundler(),
-        transformOptions.platform
-      );
-      const resolvedEntryFilePath = resolutionFn(
-        `${_this8._config.projectRoot}/.`,
-        entryFile
+      const resolvedEntryFilePath = yield _this9._resolveRelativePath(
+        entryFile,
+        {
+          transformOptions
+        }
       );
       const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {
         shallow: graphOptions.shallow,
         experimentalImportBundleSupport:
-          _this8._config.transformer.experimentalImportBundleSupport
+          _this9._config.transformer.experimentalImportBundleSupport
       });
       let revision;
 
-      const revPromise = _this8._bundler.getRevisionByGraphId(graphId);
+      const revPromise = _this9._bundler.getRevisionByGraphId(graphId);
 
       if (revPromise == null) {
-        var _ref26 = yield _this8._bundler.initializeGraph(
+        var _yield$_this9$_bundle = yield _this9._bundler.initializeGraph(
           resolvedEntryFilePath,
           transformOptions,
           {
@@ -1325,9 +1429,14 @@ class Server {
           }
         );
 
-        revision = _ref26.revision;
+        revision = _yield$_this9$_bundle.revision;
       } else {
-        revision = yield revPromise;
+        var _yield$_this9$_bundle2 = yield _this9._bundler.updateGraph(
+          yield revPromise,
+          false
+        );
+
+        revision = _yield$_this9$_bundle2.revision;
       }
 
       let _revision2 = revision,
@@ -1339,16 +1448,30 @@ class Server {
       }
 
       return getExplodedSourceMap(
-        _toConsumableArray(prepend).concat(
-          _toConsumableArray(_this8._getSortedModules(graph))
+        [].concat(
+          _toConsumableArray(prepend),
+          _toConsumableArray(_this9._getSortedModules(graph))
         ),
         {
-          processModuleFilter: _this8._config.serializer.processModuleFilter
+          processModuleFilter: _this9._config.serializer.processModuleFilter
         }
       );
     })();
   }
 
+  _resolveRelativePath(filePath, _ref16) {
+    var _this10 = this;
+
+    let transformOptions = _ref16.transformOptions;
+    return _asyncToGenerator(function*() {
+      const resolutionFn = yield transformHelpers.getResolveDependencyFn(
+        _this10._bundler.getBundler(),
+        transformOptions.platform
+      );
+      return resolutionFn(`${_this10._config.projectRoot}/.`, filePath);
+    })();
+  }
+
   getNewBuildID() {
     return (this._nextBundleBuildID++).toString(36);
   }
@@ -1360,32 +1483,34 @@ class Server {
   getWatchFolders() {
     return this._config.watchFolders;
   }
-
-  getVisualizerConfig() {
-    return this._config.visualizer;
-  }
 }
 
 _defineProperty(Server, "DEFAULT_GRAPH_OPTIONS", {
   customTransformOptions: Object.create(null),
   dev: true,
   hot: false,
-  minify: false
+  minify: false,
+  runtimeBytecodeVersion: null,
+  unstable_transformProfile: "default"
 });
 
 _defineProperty(
   Server,
   "DEFAULT_BUNDLE_OPTIONS",
-  _objectSpread({}, Server.DEFAULT_GRAPH_OPTIONS, {
-    excludeSource: false,
-    inlineSourceMap: false,
-    modulesOnly: false,
-    onProgress: null,
-    runModule: true,
-    shallow: false,
-    sourceMapUrl: null,
-    sourceUrl: null
-  })
+  _objectSpread(
+    _objectSpread({}, Server.DEFAULT_GRAPH_OPTIONS),
+    {},
+    {
+      excludeSource: false,
+      inlineSourceMap: false,
+      modulesOnly: false,
+      onProgress: null,
+      runModule: true,
+      shallow: false,
+      sourceMapUrl: null,
+      sourceUrl: null
+    }
+  )
 );
 
 function* zip(xs, ys) {
diff --git a/node_modules/metro/src/Server.js.flow b/node_modules/metro/src/Server.js.flow
index 46a1f38..0fe3bc5 100644
--- a/node_modules/metro/src/Server.js.flow
+++ b/node_modules/metro/src/Server.js.flow
@@ -11,75 +11,71 @@
 'use strict';
 const IncrementalBundler = require('./IncrementalBundler');
 const MultipartResponse = require('./Server/MultipartResponse');
+const ResourceNotFoundError = require('./IncrementalBundler/ResourceNotFoundError');
 
+const baseBytecodeBundle = require('./DeltaBundler/Serializers/baseBytecodeBundle');
 const baseJSBundle = require('./DeltaBundler/Serializers/baseJSBundle');
-const bundleToString = require('./lib/bundle-modules/DeltaClient/bundleToString');
-const deltaJSBundle = require('./DeltaBundler/Serializers/deltaJSBundle');
+const bundleToBytecode = require('./lib/bundleToBytecode');
+const bundleToString = require('./lib/bundleToString');
+
+const {codeFrameColumns} = require('@babel/code-frame');
+const debug = require('debug')('Metro:Server');
+const formatBundlingError = require('./lib/formatBundlingError');
+const fs = require('graceful-fs');
 const getAllFiles = require('./DeltaBundler/Serializers/getAllFiles');
 const getAssets = require('./DeltaBundler/Serializers/getAssets');
 const getGraphId = require('./lib/getGraphId');
 const getRamBundleInfo = require('./DeltaBundler/Serializers/getRamBundleInfo');
-const sourceMapString = require('./DeltaBundler/Serializers/sourceMapString');
-const splitBundleOptions = require('./lib/splitBundleOptions');
-const debug = require('debug')('Metro:Server');
-const formatBundlingError = require('./lib/formatBundlingError');
 const mime = require('mime-types');
 const parseOptionsFromUrl = require('./lib/parseOptionsFromUrl');
-const transformHelpers = require('./lib/transformHelpers');
 const parsePlatformFilePath = require('./node-haste/lib/parsePlatformFilePath');
 const path = require('path');
-const serializeDeltaJSBundle = require('./DeltaBundler/Serializers/helpers/serializeDeltaJSBundle');
+const sourceMapString = require('./DeltaBundler/Serializers/sourceMapString');
+const splitBundleOptions = require('./lib/splitBundleOptions');
 const symbolicate = require('./Server/symbolicate');
+const transformHelpers = require('./lib/transformHelpers');
 const url = require('url');
-const ResourceNotFoundError = require('./IncrementalBundler/ResourceNotFoundError');
-const RevisionNotFoundError = require('./IncrementalBundler/RevisionNotFoundError');
 
+const {VERSION: BYTECODE_VERSION} = require('metro-hermes-compiler');
 const {getAsset} = require('./Assets');
 const {
   getExplodedSourceMap,
 } = require('./DeltaBundler/Serializers/getExplodedSourceMap');
+const {
+  Logger,
+  Logger: {createActionStartEntry, createActionEndEntry, log},
+} = require('metro-core');
 
+import type {AssetData} from './Assets';
 import type {ExplodedSourceMap} from './DeltaBundler/Serializers/getExplodedSourceMap';
-import type {IncomingMessage, ServerResponse} from 'http';
-import type {Reporter} from './lib/reporting';
-import type {GraphId} from './lib/getGraphId';
 import type {RamBundleInfo} from './DeltaBundler/Serializers/getRamBundleInfo';
+import type {Graph, Module} from './DeltaBundler/types.flow';
+import type {MixedOutput, TransformResult} from './DeltaBundler/types.flow';
+import type {RevisionId} from './IncrementalBundler';
+import type {GraphId} from './lib/getGraphId';
+import type {Reporter} from './lib/reporting';
 import type {
   BundleOptions,
   GraphOptions,
   SplitBundleOptions,
 } from './shared/types.flow';
-import type {
-  ConfigT,
-  VisualizerConfigT,
-} from 'metro-config/src/configTypes.flow';
-import type {AssetData} from './Assets';
-import type {RevisionId} from './IncrementalBundler';
-import type {Graph, Module} from './DeltaBundler/types.flow';
+import type {IncomingMessage, ServerResponse} from 'http';
 import type {CacheStore} from 'metro-cache';
-import type {BundleVariant} from './lib/bundle-modules/types.flow';
-import type DependencyGraph from './node-haste/DependencyGraph';
-import type {MixedOutput, TransformResult} from './DeltaBundler/types.flow';
-import type {StackFrameOutput} from './Server/symbolicate';
-
-const {
-  Logger,
-  Logger: {createActionStartEntry, createActionEndEntry, log},
-} = require('metro-core');
-
+import type {ConfigT} from 'metro-config/src/configTypes.flow';
 import type {
   ActionLogEntryData,
   ActionStartLogEntry,
   LogEntry,
 } from 'metro-core/src/Logger';
 
-export type SegmentLoadData = {[number]: [Array<number>, ?number]};
+export type SegmentLoadData = {[number]: [Array<number>, ?number], ...};
 export type BundleMetadata = {
   hash: string,
   otaBuildNumber: ?string,
   mobileConfigs: Array<string>,
   segmentHashes: Array<string>,
   segmentLoadData: SegmentLoadData,
+  ...
 };
 
 type ProcessStartContext = {|
@@ -87,44 +83,47 @@ type ProcessStartContext = {|
   +bundleOptions: BundleOptions,
   +graphId: GraphId,
   +graphOptions: GraphOptions,
+  // $FlowFixMe[value-as-type]
   +mres: MultipartResponse,
   +req: IncomingMessage,
-  +revisionId: ?RevisionId,
+  +revisionId?: ?RevisionId,
   ...SplitBundleOptions,
 |};
 
+type ProcessDeleteContext = {|
+  +graphId: GraphId,
+  +req: IncomingMessage,
+  +res: ServerResponse,
+|};
+
 type ProcessEndContext<T> = {|
   ...ProcessStartContext,
   +result: T,
 |};
 
-function debounceAndBatch(fn: () => void, delay: number): () => void {
-  let timeout;
-  return () => {
-    clearTimeout(timeout);
-    timeout = setTimeout(fn, delay);
-  };
-}
+export type ServerOptions = $ReadOnly<{|
+  hasReducedPerformance?: boolean,
+  onBundleBuilt?: (bundlePath: string) => void,
+  watch?: boolean,
+|}>;
 
 const DELTA_ID_HEADER = 'X-Metro-Delta-ID';
 const FILES_CHANGED_COUNT_HEADER = 'X-Metro-Files-Changed-Count';
 
 class Server {
+  _bundler: IncrementalBundler;
   _config: ConfigT;
-  _changeWatchers: Array<{
-    req: IncomingMessage,
-    res: ServerResponse,
-  }>;
   _createModuleId: (path: string) => number;
-  _reporter: Reporter;
+  _isEnded: boolean;
   _logger: typeof Logger;
-  _platforms: Set<string>;
   _nextBundleBuildID: number;
-  _bundler: IncrementalBundler;
-  _isEnded: boolean;
+  _platforms: Set<string>;
+  _reporter: Reporter;
+  _serverOptions: ServerOptions | void;
 
-  constructor(config: ConfigT) {
+  constructor(config: ConfigT, options?: ServerOptions) {
     this._config = config;
+    this._serverOptions = options;
 
     if (this._config.resetCache) {
       this._config.cacheStores.forEach((store: CacheStore<TransformResult<>>) =>
@@ -135,7 +134,6 @@ class Server {
 
     this._reporter = config.reporter;
     this._logger = Logger;
-    this._changeWatchers = [];
     this._platforms = new Set(this._config.resolver.platforms);
     this._isEnded = false;
 
@@ -144,25 +142,10 @@ class Server {
     // the HmrServer.
     // The whole bundling/serializing logic should follow as well.
     this._createModuleId = config.serializer.createModuleIdFactory();
-    this._bundler = new IncrementalBundler(config);
-
-    const debouncedFileChangeHandler = debounceAndBatch(
-      () => this._informChangeWatchers(),
-      50,
-    );
-
-    // changes to the haste map can affect resolution of files in the bundle
-    this._bundler
-      .getBundler()
-      .getDependencyGraph()
-      .then((dependencyGraph: DependencyGraph) => {
-        dependencyGraph.getWatcher().on('change', () => {
-          // Make sure the file watcher event runs through the system before
-          // we rebuild the bundles.
-          debouncedFileChangeHandler();
-        });
-      });
-
+    this._bundler = new IncrementalBundler(config, {
+      hasReducedPerformance: options && options.hasReducedPerformance,
+      watch: options ? options.watch : undefined,
+    });
     this._nextBundleBuildID = 1;
   }
 
@@ -181,7 +164,13 @@ class Server {
     return this._createModuleId;
   }
 
-  async build(options: BundleOptions): Promise<{code: string, map: string}> {
+  async build(
+    options: BundleOptions,
+  ): Promise<{
+    code: string,
+    map: string,
+    ...
+  }> {
     const {
       entryFile,
       graphOptions,
@@ -201,8 +190,11 @@ class Server {
 
     const entryPoint = path.resolve(this._config.projectRoot, entryFile);
 
-    const bundle = baseJSBundle(entryPoint, prepend, graph, {
-      asyncRequireModulePath: this._config.transformer.asyncRequireModulePath,
+    const bundleOptions = {
+      asyncRequireModulePath: await this._resolveRelativePath(
+        this._config.transformer.asyncRequireModulePath,
+        {transformOptions},
+      ),
       processModuleFilter: this._config.serializer.processModuleFilter,
       createModuleId: this._createModuleId,
       getRunModuleStatement: this._config.serializer.getRunModuleStatement,
@@ -216,14 +208,39 @@ class Server {
       sourceMapUrl: serializerOptions.sourceMapUrl,
       sourceUrl: serializerOptions.sourceUrl,
       inlineSourceMap: serializerOptions.inlineSourceMap,
-    });
-
+    };
+    let bundleCode = null;
+    let bundleMap = null;
+    if (this._config.serializer.customSerializer) {
+      const bundle = await this._config.serializer.customSerializer(
+        entryPoint,
+        prepend,
+        graph,
+        bundleOptions,
+      );
+      if (typeof bundle === 'string') {
+        bundleCode = bundle;
+      } else {
+        bundleCode = bundle.code;
+        bundleMap = bundle.map;
+      }
+    } else {
+      bundleCode = bundleToString(
+        baseJSBundle(entryPoint, prepend, graph, bundleOptions),
+      ).code;
+    }
+    if (!bundleMap) {
+      bundleMap = sourceMapString(
+        [...prepend, ...this._getSortedModules(graph)],
+        {
+          excludeSource: serializerOptions.excludeSource,
+          processModuleFilter: this._config.serializer.processModuleFilter,
+        },
+      );
+    }
     return {
-      code: bundleToString(bundle).code,
-      map: sourceMapString([...prepend, ...this._getSortedModules(graph)], {
-        excludeSource: serializerOptions.excludeSource,
-        processModuleFilter: this._config.serializer.processModuleFilter,
-      }),
+      code: bundleCode,
+      map: bundleMap,
     };
   }
 
@@ -245,7 +262,10 @@ class Server {
     const entryPoint = path.resolve(this._config.projectRoot, entryFile);
 
     return await getRamBundleInfo(entryPoint, prepend, graph, {
-      asyncRequireModulePath: this._config.transformer.asyncRequireModulePath,
+      asyncRequireModulePath: await this._resolveRelativePath(
+        this._config.transformer.asyncRequireModulePath,
+        {transformOptions},
+      ),
       processModuleFilter: this._config.serializer.processModuleFilter,
       createModuleId: this._createModuleId,
       dev: transformOptions.dev,
@@ -270,13 +290,13 @@ class Server {
       options,
     );
 
-    const {graph} = await this._bundler.buildGraph(
-      entryFile,
+    const dependencies = await this._bundler.getDependencies(
+      [entryFile],
       transformOptions,
       {onProgress, shallow: false},
     );
 
-    return await getAssets(graph, {
+    return await getAssets(dependencies, {
       processModuleFilter: this._config.serializer.processModuleFilter,
       assetPlugins: this._config.transformer.assetPlugins,
       platform: transformOptions.platform,
@@ -290,7 +310,11 @@ class Server {
     +entryFile: string,
     +minify: boolean,
     +platform: string,
+    ...
   }): Promise<Array<string>> {
+    /* $FlowFixMe(>=0.122.0 site=react_native_fb) This comment suppresses an
+     * error found when Flow v0.122.0 was deployed. To see the error, delete
+     * this comment and run Flow. */
     const {entryFile, transformOptions, onProgress} = splitBundleOptions({
       ...Server.DEFAULT_BUNDLE_OPTIONS,
       ...options,
@@ -313,38 +337,6 @@ class Server {
     });
   }
 
-  _informChangeWatchers() {
-    const watchers = this._changeWatchers;
-    const headers = {
-      'Content-Type': 'application/json; charset=UTF-8',
-    };
-
-    watchers.forEach(function(w: {req: IncomingMessage, res: ServerResponse}) {
-      w.res.writeHead(205, headers);
-      w.res.end(JSON.stringify({changed: true}));
-    });
-
-    this._changeWatchers = [];
-  }
-
-  _processOnChangeRequest(req: IncomingMessage, res: ServerResponse) {
-    const watchers = this._changeWatchers;
-
-    watchers.push({
-      req,
-      res,
-    });
-
-    req.on('close', () => {
-      for (let i = 0; i < watchers.length; i++) {
-        if (watchers[i] && watchers[i].req === req) {
-          watchers.splice(i, 1);
-          break;
-        }
-      }
-    });
-  }
-
   _rangeRequestMiddleware(
     req: IncomingMessage,
     res: ServerResponse,
@@ -393,7 +385,6 @@ class Server {
         assetPath[1],
         this._config.projectRoot,
         this._config.watchFolders,
-        /* $FlowFixMe: query may be empty for invalid URLs */
         urlObj.query.platform,
         this._config.resolver.assetExts,
       );
@@ -413,7 +404,11 @@ class Server {
     }
   }
 
-  processRequest = (
+  processRequest: (
+    IncomingMessage,
+    ServerResponse,
+    (e: ?Error) => mixed,
+  ) => void = (
     req: IncomingMessage,
     res: ServerResponse,
     next: (?Error) => mixed,
@@ -421,33 +416,63 @@ class Server {
     this._processRequest(req, res, next).catch(next);
   };
 
+  _parseOptions(url: string): BundleOptions {
+    return parseOptionsFromUrl(
+      url,
+      new Set(this._config.resolver.platforms),
+      BYTECODE_VERSION,
+    );
+  }
+
   async _processRequest(
     req: IncomingMessage,
     res: ServerResponse,
     next: (?Error) => mixed,
   ) {
+    const originalUrl = req.url;
+    req.url = this._config.server.rewriteRequestUrl(req.url);
+
     const urlObj = url.parse(req.url, true);
     const {host} = req.headers;
-    debug(`Handling request: ${host ? 'http://' + host : ''}${req.url}`);
-    /* $FlowFixMe: Could be empty if the URL is invalid. */
-    const pathname: string = urlObj.pathname;
-
-    if (pathname.match(/\.bundle$/)) {
-      await this._processBundleRequest(req, res);
-    } else if (pathname.match(/\.map$/)) {
-      await this._processSourceMapRequest(req, res);
-    } else if (pathname.match(/\.assets$/)) {
-      await this._processAssetsRequest(req, res);
-    } else if (pathname.match(/\.delta$/)) {
-      await this._processDeltaRequest(req, res);
-    } else if (pathname.match(/\.meta/)) {
-      await this._processMetadataRequest(req, res);
-    } else if (pathname.match(/^\/onchange\/?$/)) {
-      this._processOnChangeRequest(req, res);
-    } else if (pathname.match(/^\/assets\//)) {
+    debug(
+      `Handling request: ${host ? 'http://' + host : ''}${req.url}` +
+        (originalUrl !== req.url ? ` (rewritten from ${originalUrl})` : ''),
+    );
+    const formattedUrl = url.format({
+      ...urlObj,
+      host,
+      protocol: 'http',
+    });
+    const pathname = urlObj.pathname || '';
+    if (pathname.endsWith('.bundle')) {
+      const options = this._parseOptions(formattedUrl);
+      if (options.runtimeBytecodeVersion) {
+        await this._processBytecodeBundleRequest(req, res, options);
+      } else {
+        await this._processBundleRequest(req, res, options);
+      }
+
+      if (this._serverOptions && this._serverOptions.onBundleBuilt) {
+        this._serverOptions.onBundleBuilt(pathname);
+      }
+    } else if (pathname.endsWith('.map')) {
+      // Chrome dev tools may need to access the source maps.
+      res.setHeader('Access-Control-Allow-Origin', 'devtools://devtools');
+      await this._processSourceMapRequest(
+        req,
+        res,
+        this._parseOptions(formattedUrl),
+      );
+    } else if (pathname.endsWith('.assets')) {
+      await this._processAssetsRequest(
+        req,
+        res,
+        this._parseOptions(formattedUrl),
+      );
+    } else if (pathname.startsWith('/assets/')) {
       await this._processSingleAssetRequest(req, res);
     } else if (pathname === '/symbolicate') {
-      this._symbolicate(req, res);
+      await this._symbolicate(req, res);
     } else {
       next();
     }
@@ -457,6 +482,7 @@ class Server {
     createStartEntry,
     createEndEntry,
     build,
+    delete: deleteFn,
     finish,
   }: {|
     +createStartEntry: (context: ProcessStartContext) => ActionLogEntryData,
@@ -464,21 +490,14 @@ class Server {
       context: ProcessEndContext<T>,
     ) => $Rest<ActionStartLogEntry, LogEntry>,
     +build: (context: ProcessStartContext) => Promise<T>,
+    +delete?: (context: ProcessDeleteContext) => Promise<void>,
     +finish: (context: ProcessEndContext<T>) => void,
   |}) {
     return async function requestProcessor(
       req: IncomingMessage,
       res: ServerResponse,
+      bundleOptions: BundleOptions,
     ): Promise<void> {
-      const mres = MultipartResponse.wrap(req, res);
-      const {revisionId, options: bundleOptions} = parseOptionsFromUrl(
-        url.format({
-          ...url.parse(req.url),
-          protocol: 'http',
-          host: req.headers.host,
-        }),
-        new Set(this._config.resolver.platforms),
-      );
       const {
         entryFile,
         graphOptions,
@@ -490,29 +509,74 @@ class Server {
        * `entryFile` is relative to projectRoot, we need to use resolution function
        * to find the appropriate file with supported extensions.
        */
-      const resolutionFn = await transformHelpers.getResolveDependencyFn(
-        this._bundler.getBundler(),
-        transformOptions.platform,
-      );
-      const resolvedEntryFilePath = resolutionFn(
-        `${this._config.projectRoot}/.`,
-        entryFile,
-      );
+      const resolvedEntryFilePath = await this._resolveRelativePath(entryFile, {
+        transformOptions,
+      });
       const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {
         shallow: graphOptions.shallow,
         experimentalImportBundleSupport: this._config.transformer
           .experimentalImportBundleSupport,
       });
+
+      // For resources that support deletion, handle the DELETE method.
+      if (deleteFn && req.method === 'DELETE') {
+        const deleteContext = {
+          graphId,
+          req,
+          res,
+        };
+        try {
+          await deleteFn(deleteContext);
+        } catch (error) {
+          const formattedError = formatBundlingError(error);
+
+          const status = error instanceof ResourceNotFoundError ? 404 : 500;
+          res.writeHead(status, {
+            'Content-Type': 'application/json; charset=UTF-8',
+          });
+          res.end(JSON.stringify(formattedError));
+        }
+        return;
+      }
+
+      const mres = MultipartResponse.wrap(req, res);
       const buildID = this.getNewBuildID();
 
       let onProgress = null;
+      let lastProgress = -1;
       if (this._config.reporter) {
         onProgress = (transformedFileCount: number, totalFileCount: number) => {
-          mres.writeChunk(
-            {'Content-Type': 'application/json'},
-            JSON.stringify({done: transformedFileCount, total: totalFileCount}),
+          const currentProgress = parseInt(
+            (transformedFileCount / totalFileCount) * 100,
+            10,
           );
 
+          // We want to throttle the updates so that we only show meaningful
+          // UI updates slow enough for the client to actually handle them. For
+          // that, we check the percentage, and only send percentages that are
+          // actually different and that have increased from the last one we sent.
+          if (currentProgress > lastProgress || totalFileCount < 10) {
+            mres.writeChunk(
+              {'Content-Type': 'application/json'},
+              JSON.stringify({
+                done: transformedFileCount,
+                total: totalFileCount,
+              }),
+            );
+
+            // The `uncork` called internally in Node via `promise.nextTick()` may not fire
+            // until all of the Promises are resolved because the microtask queue we're
+            // in could be starving the event loop. This can cause a bug where the progress
+            // is not actually sent in the response until after bundling is complete. This
+            // would defeat the purpose of sending progress, so we `uncork` the stream now
+            // which will force the response to flush to the client immediately.
+            if (res.socket != null && res.socket.uncork != null) {
+              res.socket.uncork();
+            }
+
+            lastProgress = currentProgress;
+          }
+
           this._reporter.update({
             buildID,
             type: 'bundle_transform_progressed',
@@ -525,11 +589,12 @@ class Server {
       this._reporter.update({
         buildID,
         bundleDetails: {
-          entryFile: resolvedEntryFilePath,
-          platform: transformOptions.platform,
+          bundleType: bundleOptions.bundleType,
           dev: transformOptions.dev,
+          entryFile: resolvedEntryFilePath,
           minify: transformOptions.minify,
-          bundleType: bundleOptions.bundleType,
+          platform: transformOptions.platform,
+          runtimeBytecodeVersion: transformOptions.runtimeBytecodeVersion,
         },
         type: 'bundle_build_started',
       });
@@ -543,7 +608,6 @@ class Server {
         mres,
         onProgress,
         req,
-        revisionId,
         serializerOptions,
         transformOptions,
       };
@@ -562,6 +626,13 @@ class Server {
           'Content-Type': 'application/json; charset=UTF-8',
         });
         mres.end(JSON.stringify(formattedError));
+
+        this._reporter.update({
+          buildID,
+          type: 'bundle_build_failed',
+          bundleOptions,
+        });
+
         this._reporter.update({error, type: 'bundling_error'});
 
         log({
@@ -573,12 +644,6 @@ class Server {
           stack: formattedError.message,
         });
 
-        this._reporter.update({
-          buildID,
-          type: 'bundle_build_failed',
-          bundleOptions,
-        });
-
         return;
       }
 
@@ -594,6 +659,9 @@ class Server {
       });
 
       log(
+        /* $FlowFixMe(>=0.122.0 site=react_native_fb) This comment suppresses
+         * an error found when Flow v0.122.0 was deployed. To see the error,
+         * delete this comment and run Flow. */
         createActionEndEntry({
           ...logEntry,
           ...createEndEntry(endContext),
@@ -602,10 +670,10 @@ class Server {
     };
   }
 
-  _processDeltaRequest = this._createRequestProcessor({
+  _processBundleRequest = this._createRequestProcessor({
     createStartEntry(context: ProcessStartContext) {
       return {
-        action_name: 'Requesting delta',
+        action_name: 'Requesting bundle',
         bundle_url: context.req.url,
         entry_point: context.entryFile,
         bundler: 'delta',
@@ -616,7 +684,8 @@ class Server {
     },
     createEndEntry(
       context: ProcessEndContext<{|
-        bundle: BundleVariant,
+        bundle: string,
+        lastModifiedDate: Date,
         nextRevId: RevisionId,
         numModifiedFiles: number,
       |}>,
@@ -630,54 +699,35 @@ class Server {
       graphId,
       graphOptions,
       onProgress,
-      revisionId,
       serializerOptions,
       transformOptions,
     }) => {
-      // TODO(T34760593): We should eventually move to a model where this
-      // endpoint is placed at /delta/:revisionId, and requesting an unknown revisionId
-      // throws a 404.
-      // However, this would break existing delta clients, since they expect the
-      // endpoint to rebuild the graph, were it not found in cache.
-      let revPromise;
-      if (revisionId != null) {
-        revPromise = this._bundler.getRevision(revisionId);
-      }
-      // Even if we receive a revisionId, it might have expired.
-      if (revPromise == null) {
-        revPromise = this._bundler.getRevisionByGraphId(graphId);
-      }
+      const revPromise = this._bundler.getRevisionByGraphId(graphId);
 
-      let delta;
-      let revision;
-      if (revPromise != null) {
-        const prevRevision = await revPromise;
+      const {delta, revision} = await (revPromise != null
+        ? this._bundler.updateGraph(await revPromise, false)
+        : this._bundler.initializeGraph(entryFile, transformOptions, {
+            onProgress,
+            shallow: graphOptions.shallow,
+          }));
 
-        ({delta, revision} = await this._bundler.updateGraph(
-          prevRevision,
-          prevRevision.id !== revisionId,
-        ));
-      } else {
-        ({delta, revision} = await this._bundler.initializeGraph(
-          entryFile,
-          transformOptions,
-          {onProgress, shallow: graphOptions.shallow},
-        ));
-      }
+      const serializer =
+        this._config.serializer.customSerializer ||
+        ((...args) => bundleToString(baseJSBundle(...args)).code);
 
-      const bundle = deltaJSBundle(
+      const bundle = await serializer(
         entryFile,
         revision.prepend,
-        delta,
-        revision.id,
         revision.graph,
         {
-          asyncRequireModulePath: this._config.transformer
-            .asyncRequireModulePath,
+          asyncRequireModulePath: await this._resolveRelativePath(
+            this._config.transformer.asyncRequireModulePath,
+            {transformOptions},
+          ),
           processModuleFilter: this._config.serializer.processModuleFilter,
           createModuleId: this._createModuleId,
-          dev: transformOptions.dev,
           getRunModuleStatement: this._config.serializer.getRunModuleStatement,
+          dev: transformOptions.dev,
           projectRoot: this._config.projectRoot,
           modulesOnly: serializerOptions.modulesOnly,
           runBeforeMainModule: this._config.serializer.getModulesRunBeforeMainModule(
@@ -690,27 +740,51 @@ class Server {
         },
       );
 
+      const bundleCode = typeof bundle === 'string' ? bundle : bundle.code;
+
       return {
-        numModifiedFiles:
-          delta.added.size + delta.modified.size + delta.deleted.size,
+        numModifiedFiles: delta.reset
+          ? delta.added.size + revision.prepend.length
+          : delta.added.size + delta.modified.size + delta.deleted.size,
+        lastModifiedDate: revision.date,
         nextRevId: revision.id,
-        bundle,
+        bundle: bundleCode,
       };
     },
-    finish({mres, result}) {
-      const bundle = serializeDeltaJSBundle.toJSON(result.bundle);
-      mres.setHeader(
-        FILES_CHANGED_COUNT_HEADER,
-        String(result.numModifiedFiles),
-      );
-      mres.setHeader(DELTA_ID_HEADER, String(result.nextRevId));
-      mres.setHeader('Content-Type', 'application/json');
-      mres.setHeader('Content-Length', String(Buffer.byteLength(bundle)));
-      mres.end(bundle);
+    finish({req, mres, result}) {
+      if (
+        // We avoid parsing the dates since the client should never send a more
+        // recent date than the one returned by the Delta Bundler (if that's the
+        // case it's fine to return the whole bundle).
+        req.headers['if-modified-since'] ===
+        result.lastModifiedDate.toUTCString()
+      ) {
+        debug('Responding with 304');
+        mres.writeHead(304);
+        mres.end();
+      } else {
+        mres.setHeader(
+          FILES_CHANGED_COUNT_HEADER,
+          String(result.numModifiedFiles),
+        );
+        mres.setHeader(DELTA_ID_HEADER, String(result.nextRevId));
+        mres.setHeader('Content-Type', 'application/javascript');
+        mres.setHeader('Last-Modified', result.lastModifiedDate.toUTCString());
+        mres.setHeader(
+          'Content-Length',
+          String(Buffer.byteLength(result.bundle)),
+        );
+        mres.end(result.bundle);
+      }
+    },
+    delete: async ({graphId, res}) => {
+      await this._bundler.endGraph(graphId);
+      res.statusCode = 204;
+      res.end();
     },
   });
 
-  _processBundleRequest = this._createRequestProcessor({
+  _processBytecodeBundleRequest = this._createRequestProcessor({
     createStartEntry(context: ProcessStartContext) {
       return {
         action_name: 'Requesting bundle',
@@ -724,7 +798,7 @@ class Server {
     },
     createEndEntry(
       context: ProcessEndContext<{|
-        bundle: string,
+        bytecode: Buffer,
         lastModifiedDate: Date,
         nextRevId: RevisionId,
         numModifiedFiles: number,
@@ -751,26 +825,27 @@ class Server {
             shallow: graphOptions.shallow,
           }));
 
-      const serializer =
-        this._config.serializer.customSerializer ||
-        ((...args) => bundleToString(baseJSBundle(...args)).code);
-
-      const bundle = serializer(entryFile, revision.prepend, revision.graph, {
-        asyncRequireModulePath: this._config.transformer.asyncRequireModulePath,
-        processModuleFilter: this._config.serializer.processModuleFilter,
-        createModuleId: this._createModuleId,
-        getRunModuleStatement: this._config.serializer.getRunModuleStatement,
-        dev: transformOptions.dev,
-        projectRoot: this._config.projectRoot,
-        modulesOnly: serializerOptions.modulesOnly,
-        runBeforeMainModule: this._config.serializer.getModulesRunBeforeMainModule(
-          path.relative(this._config.projectRoot, entryFile),
-        ),
-        runModule: serializerOptions.runModule,
-        sourceMapUrl: serializerOptions.sourceMapUrl,
-        sourceUrl: serializerOptions.sourceUrl,
-        inlineSourceMap: serializerOptions.inlineSourceMap,
-      });
+      const bundle = bundleToBytecode(
+        baseBytecodeBundle(entryFile, revision.prepend, revision.graph, {
+          asyncRequireModulePath: await this._resolveRelativePath(
+            this._config.transformer.asyncRequireModulePath,
+            {transformOptions},
+          ),
+          processModuleFilter: this._config.serializer.processModuleFilter,
+          createModuleId: this._createModuleId,
+          getRunModuleStatement: this._config.serializer.getRunModuleStatement,
+          dev: transformOptions.dev,
+          projectRoot: this._config.projectRoot,
+          modulesOnly: serializerOptions.modulesOnly,
+          runBeforeMainModule: this._config.serializer.getModulesRunBeforeMainModule(
+            path.relative(this._config.projectRoot, entryFile),
+          ),
+          runModule: serializerOptions.runModule,
+          sourceMapUrl: serializerOptions.sourceMapUrl,
+          sourceUrl: serializerOptions.sourceUrl,
+          inlineSourceMap: serializerOptions.inlineSourceMap,
+        }),
+      );
 
       return {
         numModifiedFiles: delta.reset
@@ -778,7 +853,7 @@ class Server {
           : delta.added.size + delta.modified.size + delta.deleted.size,
         lastModifiedDate: revision.date,
         nextRevId: revision.id,
-        bundle,
+        bytecode: bundle.bytecode,
       };
     },
     finish({req, mres, result}) {
@@ -798,13 +873,13 @@ class Server {
           String(result.numModifiedFiles),
         );
         mres.setHeader(DELTA_ID_HEADER, String(result.nextRevId));
-        mres.setHeader('Content-Type', 'application/javascript');
+        mres.setHeader('Content-Type', 'application/x-metro-bytecode-bundle');
         mres.setHeader('Last-Modified', result.lastModifiedDate.toUTCString());
         mres.setHeader(
           'Content-Length',
-          String(Buffer.byteLength(result.bundle)),
+          String(Buffer.byteLength(result.bytecode)),
         );
-        mres.end(result.bundle);
+        mres.end(result.bytecode);
       }
     },
   });
@@ -812,7 +887,13 @@ class Server {
   // This function ensures that modules in source maps are sorted in the same
   // order as in a plain JS bundle.
   _getSortedModules(graph: Graph<>): $ReadOnlyArray<Module<>> {
-    return [...graph.dependencies.values()].sort(
+    const modules = [...graph.dependencies.values()];
+    // Assign IDs to modules in a consistent order
+    for (const module of modules) {
+      this._createModuleId(module.path);
+    }
+    // Sort by IDs
+    return modules.sort(
       (a: Module<MixedOutput>, b: Module<MixedOutput>) =>
         this._createModuleId(a.path) - this._createModuleId(b.path),
     );
@@ -849,7 +930,7 @@ class Server {
           {onProgress, shallow: graphOptions.shallow},
         ));
       } else {
-        revision = await revPromise;
+        ({revision} = await this._bundler.updateGraph(await revPromise, false));
       }
 
       let {prepend, graph} = revision;
@@ -868,67 +949,6 @@ class Server {
     },
   });
 
-  _processMetadataRequest = this._createRequestProcessor({
-    createStartEntry(context: ProcessStartContext) {
-      return {
-        action_name: 'Requesting bundle metadata',
-        bundle_url: context.req.url,
-        entry_point: context.entryFile,
-        bundler: 'delta',
-      };
-    },
-    createEndEntry(context: ProcessEndContext<BundleMetadata>) {
-      return {
-        bundler: 'delta',
-      };
-    },
-    build: async ({
-      entryFile,
-      transformOptions,
-      serializerOptions,
-      onProgress,
-      revisionId,
-    }) => {
-      if (revisionId == null) {
-        throw new Error(
-          'You must provide a `revisionId` query parameter to the metadata endpoint.',
-        );
-      }
-
-      let revision;
-      const revPromise = this._bundler.getRevision(revisionId);
-      if (revPromise == null) {
-        throw new RevisionNotFoundError(revisionId);
-      } else {
-        revision = await revPromise;
-      }
-
-      const base = baseJSBundle(entryFile, revision.prepend, revision.graph, {
-        asyncRequireModulePath: this._config.transformer.asyncRequireModulePath,
-        processModuleFilter: this._config.serializer.processModuleFilter,
-        createModuleId: this._createModuleId,
-        getRunModuleStatement: this._config.serializer.getRunModuleStatement,
-        dev: transformOptions.dev,
-        projectRoot: this._config.projectRoot,
-        modulesOnly: serializerOptions.modulesOnly,
-        runBeforeMainModule: this._config.serializer.getModulesRunBeforeMainModule(
-          path.relative(this._config.projectRoot, entryFile),
-        ),
-        runModule: serializerOptions.runModule,
-        sourceMapUrl: serializerOptions.sourceMapUrl,
-        sourceUrl: serializerOptions.sourceUrl,
-        inlineSourceMap: serializerOptions.inlineSourceMap,
-      });
-
-      // $FlowFixMe the return value of an async function is always a Promise
-      return bundleToString(base).metadata;
-    },
-    finish({mres, result}) {
-      mres.setHeader('Content-Type', 'application/json');
-      mres.end(JSON.stringify(result));
-    },
-  });
-
   _processAssetsRequest = this._createRequestProcessor({
     createStartEntry(context: ProcessStartContext) {
       return {
@@ -944,13 +964,13 @@ class Server {
       };
     },
     build: async ({entryFile, transformOptions, onProgress}) => {
-      const {graph} = await this._bundler.buildGraph(
-        entryFile,
+      const dependencies = await this._bundler.getDependencies(
+        [entryFile],
         transformOptions,
         {onProgress, shallow: false},
       );
 
-      return await getAssets(graph, {
+      return await getAssets(dependencies, {
         processModuleFilter: this._config.serializer.processModuleFilter,
         assetPlugins: this._config.transformer.assetPlugins,
         platform: transformOptions.platform,
@@ -964,67 +984,100 @@ class Server {
     },
   });
 
-  _symbolicate(req: IncomingMessage, res: ServerResponse) {
-    const symbolicatingLogEntry = log(createActionStartEntry('Symbolicating'));
-
-    debug('Start symbolication');
-
-    /* $FlowFixMe: where is `rowBody` defined? Is it added by
-     * the `connect` framework? */
-    Promise.resolve(req.rawBody)
-      .then((body: string) => {
-        const stack = JSON.parse(body).stack;
-
-        // In case of multiple bundles / HMR, some stack frames can have
-        // different URLs from others
-        const urls = new Set();
-        stack.forEach(frame => {
-          const sourceUrl = frame.file;
-          // Skip `/debuggerWorker.js` which drives remote debugging because it
-          // does not need to symbolication.
-          // Skip anything except http(s), because there is no support for that yet
-          if (
-            sourceUrl != null &&
-            !urls.has(sourceUrl) &&
-            !sourceUrl.endsWith('/debuggerWorker.js') &&
-            sourceUrl.startsWith('http')
-          ) {
-            urls.add(sourceUrl);
-          }
-        });
+  async _symbolicate(req: IncomingMessage, res: ServerResponse) {
+    const getCodeFrame = (urls, symbolicatedStack) => {
+      for (let i = 0; i < symbolicatedStack.length; i++) {
+        const {collapse, column, file, lineNumber} = symbolicatedStack[i];
+        if (collapse || lineNumber == null || urls.has(file)) {
+          continue;
+        }
 
-        const mapPromises = Array.from(urls.values()).map(
-          this._explodedSourceMapForURL,
-          this,
-        );
+        return {
+          content: codeFrameColumns(
+            fs.readFileSync(file, 'utf8'),
+            {
+              // Metro returns 0 based columns but codeFrameColumns expects 1-based columns
+              start: {column: column + 1, line: lineNumber},
+            },
+            {forceColor: true},
+          ),
+          location: {
+            row: lineNumber,
+            column,
+          },
+          fileName: file,
+        };
+      }
 
-        debug('Getting source maps for symbolication');
-        return Promise.all(mapPromises).then(maps => {
-          debug('Performing fast symbolication');
-          const urlsToMaps = zip(urls.values(), maps);
-          return symbolicate(stack, urlsToMaps, this._config);
-        });
-      })
-      .then(
-        (stack: $ReadOnlyArray<StackFrameOutput>) => {
-          debug('Symbolication done');
-          res.end(JSON.stringify({stack}));
-          process.nextTick(() => {
-            log(createActionEndEntry(symbolicatingLogEntry));
-          });
-        },
-        error => {
-          console.error(error.stack || error);
-          res.statusCode = 500;
-          res.end(JSON.stringify({error: error.message}));
-        },
+      return null;
+    };
+
+    try {
+      const symbolicatingLogEntry = log(
+        createActionStartEntry('Symbolicating'),
       );
+      debug('Start symbolication');
+      /* $FlowFixMe: where is `rawBody` defined? Is it added by the `connect` framework? */
+      const body = await req.rawBody;
+      const stack = JSON.parse(body).stack.map(frame => {
+        if (frame.file && frame.file.includes('://')) {
+          return {
+            ...frame,
+            file: this._config.server.rewriteRequestUrl(frame.file),
+          };
+        }
+        return frame;
+      });
+      // In case of multiple bundles / HMR, some stack frames can have different URLs from others
+      const urls = new Set();
+
+      stack.forEach(frame => {
+        const sourceUrl = frame.file;
+        // Skip `/debuggerWorker.js` which does not need symbolication.
+        if (
+          sourceUrl != null &&
+          !urls.has(sourceUrl) &&
+          !sourceUrl.endsWith('/debuggerWorker.js') &&
+          sourceUrl.startsWith('http')
+        ) {
+          urls.add(sourceUrl);
+        }
+      });
+
+      debug('Getting source maps for symbolication');
+      const sourceMaps = await Promise.all(
+        Array.from(urls.values()).map(this._explodedSourceMapForURL, this),
+      );
+
+      debug('Performing fast symbolication');
+      const symbolicatedStack = await await symbolicate(
+        stack,
+        zip(urls.values(), sourceMaps),
+        this._config,
+      );
+
+      debug('Symbolication done');
+      res.end(
+        JSON.stringify({
+          codeFrame: getCodeFrame(urls, symbolicatedStack),
+          stack: symbolicatedStack,
+        }),
+      );
+      process.nextTick(() => {
+        log(createActionEndEntry(symbolicatingLogEntry));
+      });
+    } catch (error) {
+      console.error(error.stack || error);
+      res.statusCode = 500;
+      res.end(JSON.stringify({error: error.message}));
+    }
   }
 
   async _explodedSourceMapForURL(reqUrl: string): Promise<ExplodedSourceMap> {
-    const {options} = parseOptionsFromUrl(
+    const options = parseOptionsFromUrl(
       reqUrl,
       new Set(this._config.resolver.platforms),
+      BYTECODE_VERSION,
     );
 
     const {
@@ -1039,14 +1092,9 @@ class Server {
      * `entryFile` is relative to projectRoot, we need to use resolution function
      * to find the appropriate file with supported extensions.
      */
-    const resolutionFn = await transformHelpers.getResolveDependencyFn(
-      this._bundler.getBundler(),
-      transformOptions.platform,
-    );
-    const resolvedEntryFilePath = resolutionFn(
-      `${this._config.projectRoot}/.`,
-      entryFile,
-    );
+    const resolvedEntryFilePath = await this._resolveRelativePath(entryFile, {
+      transformOptions,
+    });
 
     const graphId = getGraphId(resolvedEntryFilePath, transformOptions, {
       shallow: graphOptions.shallow,
@@ -1062,7 +1110,7 @@ class Server {
         {onProgress, shallow: graphOptions.shallow},
       ));
     } else {
-      revision = await revPromise;
+      ({revision} = await this._bundler.updateGraph(await revPromise, false));
     }
 
     let {prepend, graph} = revision;
@@ -1078,6 +1126,14 @@ class Server {
     );
   }
 
+  async _resolveRelativePath(filePath, {transformOptions}) {
+    const resolutionFn = await transformHelpers.getResolveDependencyFn(
+      this._bundler.getBundler(),
+      transformOptions.platform,
+    );
+    return resolutionFn(`${this._config.projectRoot}/.`, filePath);
+  }
+
   getNewBuildID(): string {
     return (this._nextBundleBuildID++).toString(36);
   }
@@ -1090,18 +1146,33 @@ class Server {
     return this._config.watchFolders;
   }
 
-  getVisualizerConfig(): $ReadOnly<VisualizerConfigT> {
-    return this._config.visualizer;
-  }
-
-  static DEFAULT_GRAPH_OPTIONS = {
+  static DEFAULT_GRAPH_OPTIONS: {|
+    customTransformOptions: any,
+    dev: boolean,
+    hot: boolean,
+    minify: boolean,
+    runtimeBytecodeVersion: ?number,
+    unstable_transformProfile: 'default',
+  |} = {
     customTransformOptions: Object.create(null),
     dev: true,
     hot: false,
     minify: false,
+    runtimeBytecodeVersion: null,
+    unstable_transformProfile: 'default',
   };
 
-  static DEFAULT_BUNDLE_OPTIONS = {
+  static DEFAULT_BUNDLE_OPTIONS: {|
+    ...typeof Server.DEFAULT_GRAPH_OPTIONS,
+    excludeSource: false,
+    inlineSourceMap: false,
+    modulesOnly: false,
+    onProgress: null,
+    runModule: true,
+    shallow: false,
+    sourceMapUrl: null,
+    sourceUrl: null,
+  |} = {
     ...Server.DEFAULT_GRAPH_OPTIONS,
     excludeSource: false,
     inlineSourceMap: false,
diff --git a/node_modules/metro/src/Server/MultipartResponse.js b/node_modules/metro/src/Server/MultipartResponse.js
index 1137ffe..c61b7b6 100644
--- a/node_modules/metro/src/Server/MultipartResponse.js
+++ b/node_modules/metro/src/Server/MultipartResponse.js
@@ -8,12 +8,18 @@
  */
 "use strict";
 
+const accepts = require("accepts");
+
 const CRLF = "\r\n";
 const BOUNDARY = "3beqjf3apnqeu3h5jqorms4i";
 
 class MultipartResponse {
   static wrap(req, res) {
-    if (acceptsMultipartResponse(req)) {
+    if (
+      accepts(req)
+        .types()
+        .includes("multipart/mixed")
+    ) {
       return new MultipartResponse(res);
     } // Ugly hack, ideally wrap function should always return a proxy
     // object with the same interface
@@ -37,22 +43,23 @@ class MultipartResponse {
   writeChunk(headers, data) {
     let isLast =
       arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
-    let chunk = `${CRLF}--${BOUNDARY}${CRLF}`;
+
+    if (this.res.finished) {
+      return;
+    }
+
+    this.res.write(`${CRLF}--${BOUNDARY}${CRLF}`);
 
     if (headers) {
-      chunk += MultipartResponse.serializeHeaders(headers) + CRLF + CRLF;
+      this.res.write(MultipartResponse.serializeHeaders(headers) + CRLF + CRLF);
     }
 
     if (data) {
-      chunk += data;
+      this.res.write(data);
     }
 
     if (isLast) {
-      chunk += `${CRLF}--${BOUNDARY}--${CRLF}`;
-    }
-
-    if (!this.res.finished) {
-      this.res.write(chunk);
+      this.res.write(`${CRLF}--${BOUNDARY}--${CRLF}`);
     }
   }
 
@@ -86,8 +93,4 @@ class MultipartResponse {
   }
 }
 
-function acceptsMultipartResponse(req) {
-  return req.headers && req.headers.accept === "multipart/mixed";
-}
-
 module.exports = MultipartResponse;
diff --git a/node_modules/metro/src/Server/symbolicate.js b/node_modules/metro/src/Server/symbolicate.js
index 4ad4961..a998db0 100644
--- a/node_modules/metro/src/Server/symbolicate.js
+++ b/node_modules/metro/src/Server/symbolicate.js
@@ -4,26 +4,47 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,24 +59,51 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -63,6 +111,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -75,6 +124,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
@@ -90,6 +140,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -103,12 +154,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -269,12 +323,16 @@ function _symbolicate() {
         _findFunctionName !== void 0
           ? _findFunctionName
           : frame.methodName;
-      return _objectSpread({}, frame, {
-        methodName,
-        file: module.path,
-        lineNumber: originalPos.line1Based,
-        column: originalPos.column0Based
-      });
+      return _objectSpread(
+        _objectSpread({}, frame),
+        {},
+        {
+          methodName,
+          file: module.path,
+          lineNumber: originalPos.line1Based,
+          column: originalPos.column0Based
+        }
+      );
     }
 
     function customizeFrame(_x4) {
@@ -286,8 +344,8 @@ function _symbolicate() {
         const customizations =
           (yield config.symbolicator.customizeFrame(frame)) || {};
         return _objectSpread(
+          _objectSpread({}, frame),
           {},
-          frame,
           {
             collapse: false
           },
diff --git a/node_modules/metro/src/Server/symbolicate.js.flow b/node_modules/metro/src/Server/symbolicate.js.flow
index 72ed18f..008f41b 100644
--- a/node_modules/metro/src/Server/symbolicate.js.flow
+++ b/node_modules/metro/src/Server/symbolicate.js.flow
@@ -7,6 +7,7 @@
  * @flow strict-local
  * @format
  */
+
 'use strict';
 
 const {greatestLowerBound} = require('metro-source-map/src/Consumer/search');
@@ -22,10 +23,12 @@ export type StackFrameInput = {
   +lineNumber: ?number,
   +column: ?number,
   +methodName: ?string,
+  ...
 };
 export type StackFrameOutput = $ReadOnly<{
   ...StackFrameInput,
   +collapse: boolean,
+  ...
 }>;
 type ExplodedSourceMapModule = $ElementType<ExplodedSourceMap, number>;
 type Position = {|+line1Based: number, column0Based: number|};
diff --git a/node_modules/metro/src/assetTransformer.js b/node_modules/metro/src/assetTransformer.js
deleted file mode 100644
index 6ec7483..0000000
--- a/node_modules/metro/src/assetTransformer.js
+++ /dev/null
@@ -1,88 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
-  try {
-    var info = gen[key](arg);
-    var value = info.value;
-  } catch (error) {
-    reject(error);
-    return;
-  }
-  if (info.done) {
-    resolve(value);
-  } else {
-    Promise.resolve(value).then(_next, _throw);
-  }
-}
-
-function _asyncToGenerator(fn) {
-  return function() {
-    var self = this,
-      args = arguments;
-    return new Promise(function(resolve, reject) {
-      var gen = fn.apply(self, args);
-      function _next(value) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
-      }
-      function _throw(err) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
-      }
-      _next(undefined);
-    });
-  };
-}
-
-const path = require("path");
-
-const _require = require("./Assets"),
-  getAssetData = _require.getAssetData;
-
-const _require2 = require("./Bundler/util"),
-  generateAssetCodeFileAst = _require2.generateAssetCodeFileAst;
-
-function transform(_x, _x2, _x3) {
-  return _transform.apply(this, arguments);
-}
-
-function _transform() {
-  _transform = _asyncToGenerator(function*(
-    _ref,
-    assetRegistryPath,
-    assetDataPlugins
-  ) {
-    let filename = _ref.filename,
-      options = _ref.options,
-      src = _ref.src;
-    options = options || {
-      platform: "",
-      projectRoot: "",
-      inlineRequires: false,
-      minify: false
-    };
-    const absolutePath = path.resolve(options.projectRoot, filename);
-    const data = yield getAssetData(
-      absolutePath,
-      filename,
-      assetDataPlugins,
-      options.platform,
-      options.publicPath
-    );
-    return {
-      ast: generateAssetCodeFileAst(assetRegistryPath, data)
-    };
-  });
-  return _transform.apply(this, arguments);
-}
-
-module.exports = {
-  transform
-};
diff --git a/node_modules/metro/src/assetTransformer.js.flow b/node_modules/metro/src/assetTransformer.js.flow
deleted file mode 100644
index 52b4ff5..0000000
--- a/node_modules/metro/src/assetTransformer.js.flow
+++ /dev/null
@@ -1,49 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-'use strict';
-
-const path = require('path');
-
-const {getAssetData} = require('./Assets');
-const {generateAssetCodeFileAst} = require('./Bundler/util');
-
-import type {Ast} from '@babel/core';
-import type {BabelTransformerArgs} from 'metro-babel-transformer';
-
-async function transform(
-  {filename, options, src}: BabelTransformerArgs,
-  assetRegistryPath: string,
-  assetDataPlugins: $ReadOnlyArray<string>,
-): Promise<{ast: Ast}> {
-  options = options || {
-    platform: '',
-    projectRoot: '',
-    inlineRequires: false,
-    minify: false,
-  };
-
-  const absolutePath = path.resolve(options.projectRoot, filename);
-
-  const data = await getAssetData(
-    absolutePath,
-    filename,
-    assetDataPlugins,
-    options.platform,
-    options.publicPath,
-  );
-
-  return {
-    ast: generateAssetCodeFileAst(assetRegistryPath, data),
-  };
-}
-
-module.exports = {
-  transform,
-};
diff --git a/node_modules/metro/src/cli-utils.js b/node_modules/metro/src/cli-utils.js
index daa6dfc..4ee8543 100644
--- a/node_modules/metro/src/cli-utils.js
+++ b/node_modules/metro/src/cli-utils.js
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -43,24 +47,20 @@ function _asyncToGenerator(fn) {
 
 const fs = require("fs-extra");
 
-exports.watchFile =
-  /*#__PURE__*/
-  (function() {
-    var _ref = _asyncToGenerator(function*(filename, callback) {
-      fs.watchFile(filename, () => {
-        callback();
-      });
-      yield callback();
+exports.watchFile = /*#__PURE__*/ (function() {
+  var _ref = _asyncToGenerator(function*(filename, callback) {
+    fs.watchFile(filename, () => {
+      callback();
     });
+    yield callback();
+  });
 
-    return function(_x, _x2) {
-      return _ref.apply(this, arguments);
-    };
-  })();
+  return function(_x, _x2) {
+    return _ref.apply(this, arguments);
+  };
+})();
 
-exports.makeAsyncCommand = (
-  command // eslint-disable-next-line lint/no-unclear-flowtypes
-) => argv => {
+exports.makeAsyncCommand = command => argv => {
   Promise.resolve(command(argv)).catch(error => {
     console.error(error.stack);
     process.exitCode = 1;
diff --git a/node_modules/metro/src/cli-utils.js.flow b/node_modules/metro/src/cli-utils.js.flow
index 3a77f4a..e5db558 100644
--- a/node_modules/metro/src/cli-utils.js.flow
+++ b/node_modules/metro/src/cli-utils.js.flow
@@ -12,6 +12,8 @@
 
 const fs = require('fs-extra');
 
+import type {YargArguments} from 'metro-config/src/configTypes.flow';
+
 exports.watchFile = async function(
   filename: string,
   callback: () => *,
@@ -23,10 +25,9 @@ exports.watchFile = async function(
   await callback();
 };
 
-exports.makeAsyncCommand = (command: (argv: any) => Promise<*>) => (
-  // eslint-disable-next-line lint/no-unclear-flowtypes
-  argv: any,
-) => {
+exports.makeAsyncCommand = (
+  command: (argv: YargArguments) => Promise<*>,
+): ((argv: YargArguments) => void) => (argv: YargArguments) => {
   Promise.resolve(command(argv)).catch(error => {
     console.error(error.stack);
     process.exitCode = 1;
diff --git a/node_modules/metro/src/cli.js b/node_modules/metro/src/cli.js
index aa886eb..ee16287 100755
--- a/node_modules/metro/src/cli.js
+++ b/node_modules/metro/src/cli.js
@@ -6,12 +6,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
-"use strict"; //flowlint untyped-import:off
+"use strict"; // flowlint-next-line untyped-import:off
 
-const yargs = require("yargs"); //flowlint untyped-import:error
+const yargs = require("yargs");
 
 const _require = require("./index"),
   attachMetroCli = _require.attachMetroCli;
diff --git a/node_modules/metro/src/cli.js.flow b/node_modules/metro/src/cli.js.flow
index 719b0cd..8c859e4 100644
--- a/node_modules/metro/src/cli.js.flow
+++ b/node_modules/metro/src/cli.js.flow
@@ -1,5 +1,4 @@
 #!/usr/bin/env node
-
 /**
  * Copyright (c) Facebook, Inc. and its affiliates.
  *
@@ -12,11 +11,9 @@
 
 'use strict';
 
-//flowlint untyped-import:off
+// flowlint-next-line untyped-import:off
 const yargs = require('yargs');
 
-//flowlint untyped-import:error
-
 const {attachMetroCli} = require('./index');
 
 attachMetroCli(yargs.demandCommand(1)).argv;
diff --git a/node_modules/metro/src/commands/build.js b/node_modules/metro/src/commands/build.js
index 9c8d77b..29dcad8 100644
--- a/node_modules/metro/src/commands/build.js
+++ b/node_modules/metro/src/commands/build.js
@@ -9,21 +9,42 @@
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,6 +59,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -49,6 +71,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -62,12 +85,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -93,6 +119,7 @@ module.exports = () => ({
   command: "build <entry>",
   description:
     "Generates a JavaScript bundle containing the specified entrypoint and its descendants",
+  // $FlowFixMe[value-as-type]
   builder: yargs => {
     yargs.option("project-roots", {
       alias: "P",
@@ -137,50 +164,55 @@ module.exports = () => ({
       alias: "c",
       type: "string"
     }); // Deprecated
-    // $FlowFixMe Errors found when flow-typing `yargs`
 
     yargs.option("reset-cache", {
-      type: "boolean",
-      describe: null
+      type: "boolean"
     });
   },
-  // eslint-disable-next-line lint/no-unclear-flowtypes
   handler: makeAsyncCommand(
-    /*#__PURE__*/
-    (function() {
+    /*#__PURE__*/ (function() {
       var _ref = _asyncToGenerator(function*(argv) {
-        const config = yield loadConfig(argv);
+        const config = yield loadConfig(argv); // $FlowExpectedError YargArguments and RunBuildOptions are used interchangeable but their types are not yet compatible
+
+        const options = argv;
         yield MetroApi.runBuild(
           config,
-          _objectSpread({}, argv, {
-            onBegin: () => {
-              updateReporter.update({
-                buildID: "$",
-                type: "bundle_build_started",
-                bundleDetails: {
-                  entryFile: argv.entry,
-                  platform: argv.platform,
-                  dev: !!argv.dev,
-                  minify: !!argv.optimize,
-                  bundleType: "Bundle"
-                }
-              });
-            },
-            onProgress: (transformedFileCount, totalFileCount) => {
-              updateReporter.update({
-                buildID: "$",
-                type: "bundle_transform_progressed_throttled",
-                transformedFileCount,
-                totalFileCount
-              });
-            },
-            onComplete: () => {
-              updateReporter.update({
-                buildID: "$",
-                type: "bundle_build_done"
-              });
+          _objectSpread(
+            _objectSpread({}, options),
+            {},
+            {
+              onBegin: () => {
+                updateReporter.update({
+                  buildID: "$",
+                  type: "bundle_build_started",
+                  bundleDetails: {
+                    bundleType: "Bundle",
+                    dev: !!options.dev,
+                    entryFile: options.entry,
+                    minify: !!options.minify,
+                    platform: options.platform,
+                    // Bytecode bundles in Metro are not meant for production use. Instead,
+                    // the Hermes Bytecode Compiler should be invoked on the resulting JS bundle from Metro.
+                    runtimeBytecodeVersion: null
+                  }
+                });
+              },
+              onProgress: (transformedFileCount, totalFileCount) => {
+                updateReporter.update({
+                  buildID: "$",
+                  type: "bundle_transform_progressed_throttled",
+                  transformedFileCount,
+                  totalFileCount
+                });
+              },
+              onComplete: () => {
+                updateReporter.update({
+                  buildID: "$",
+                  type: "bundle_build_done"
+                });
+              }
             }
-          })
+          )
         );
       });
 
diff --git a/node_modules/metro/src/commands/build.js.flow b/node_modules/metro/src/commands/build.js.flow
index 43f2e39..8c2e4fe 100644
--- a/node_modules/metro/src/commands/build.js.flow
+++ b/node_modules/metro/src/commands/build.js.flow
@@ -17,17 +17,26 @@ const {makeAsyncCommand} = require('../cli-utils');
 const {loadConfig} = require('metro-config');
 const {Terminal} = require('metro-core');
 
+import type {RunBuildOptions} from '../index';
+import type {YargArguments} from 'metro-config/src/configTypes.flow';
 import typeof Yargs from 'yargs';
 
 const term = new Terminal(process.stdout);
 const updateReporter = new TerminalReporter(term);
 
-module.exports = () => ({
+module.exports = (): ({|
+  // $FlowFixMe[value-as-type]
+  builder: (yargs: Yargs) => void,
+  command: string,
+  description: string,
+  handler: (argv: YargArguments) => void,
+|}) => ({
   command: 'build <entry>',
 
   description:
     'Generates a JavaScript bundle containing the specified entrypoint and its descendants',
 
+  // $FlowFixMe[value-as-type]
   builder: (yargs: Yargs): void => {
     yargs.option('project-roots', {
       alias: 'P',
@@ -52,26 +61,29 @@ module.exports = () => ({
     yargs.option('config', {alias: 'c', type: 'string'});
 
     // Deprecated
-    // $FlowFixMe Errors found when flow-typing `yargs`
-    yargs.option('reset-cache', {type: 'boolean', describe: null});
+    yargs.option('reset-cache', {type: 'boolean'});
   },
 
-  // eslint-disable-next-line lint/no-unclear-flowtypes
-  handler: makeAsyncCommand(async (argv: any) => {
+  handler: makeAsyncCommand(async (argv: YargArguments) => {
     const config = await loadConfig(argv);
+    // $FlowExpectedError YargArguments and RunBuildOptions are used interchangeable but their types are not yet compatible
+    const options = (argv: RunBuildOptions);
 
     await MetroApi.runBuild(config, {
-      ...argv,
+      ...options,
       onBegin: (): void => {
         updateReporter.update({
           buildID: '$',
           type: 'bundle_build_started',
           bundleDetails: {
-            entryFile: argv.entry,
-            platform: argv.platform,
-            dev: !!argv.dev,
-            minify: !!argv.optimize,
             bundleType: 'Bundle',
+            dev: !!options.dev,
+            entryFile: options.entry,
+            minify: !!options.minify,
+            platform: options.platform,
+            // Bytecode bundles in Metro are not meant for production use. Instead,
+            // the Hermes Bytecode Compiler should be invoked on the resulting JS bundle from Metro.
+            runtimeBytecodeVersion: null,
           },
         });
       },
diff --git a/node_modules/metro/src/commands/dependencies.js b/node_modules/metro/src/commands/dependencies.js
index 525ff93..bb78de6 100644
--- a/node_modules/metro/src/commands/dependencies.js
+++ b/node_modules/metro/src/commands/dependencies.js
@@ -16,6 +16,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -29,31 +30,33 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
 }
 
+const Server = require("../Server");
+
 const denodeify = require("denodeify");
 
 const fs = require("fs");
 
 const path = require("path");
 
-const _require = require("metro-config"),
-  loadConfig = _require.loadConfig;
-
-const _require2 = require("../legacy"),
-  getOrderedDependencyPaths = _require2.getOrderedDependencyPaths;
+const _require = require("../cli-utils"),
+  makeAsyncCommand = _require.makeAsyncCommand;
 
-const _require3 = require("../cli-utils"),
-  makeAsyncCommand = _require3.makeAsyncCommand;
+const _require2 = require("metro-config"),
+  loadConfig = _require2.loadConfig;
 
 function dependencies(_x, _x2) {
   return _dependencies.apply(this, arguments);
@@ -85,7 +88,8 @@ function _dependencies() {
     const outStream = writeToFile
       ? fs.createWriteStream(args.output)
       : process.stdout;
-    const deps = yield getOrderedDependencyPaths(config, options);
+    const server = new Server(config);
+    const deps = yield server.getOrderedDependencyPaths(options);
     deps.forEach(modulePath => {
       // Temporary hack to disable listing dependencies not under this directory.
       // Long term, we need either
@@ -99,6 +103,7 @@ function _dependencies() {
         outStream.write(modulePath + "\n");
       }
     });
+    server.end();
     return writeToFile
       ? denodeify(outStream.end).bind(outStream)()
       : Promise.resolve();
@@ -146,8 +151,7 @@ module.exports = () => ({
     });
   },
   handler: makeAsyncCommand(
-    /*#__PURE__*/
-    (function() {
+    /*#__PURE__*/ (function() {
       var _ref = _asyncToGenerator(function*(argv) {
         const config = yield loadConfig(argv);
         yield dependencies(argv, config);
diff --git a/node_modules/metro/src/commands/serve.js b/node_modules/metro/src/commands/serve.js
index f25d8b7..04ff1e3 100644
--- a/node_modules/metro/src/commands/serve.js
+++ b/node_modules/metro/src/commands/serve.js
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -56,8 +60,8 @@ const _require3 = require("util"),
 
 module.exports = () => ({
   command: "serve",
-  description:
-    "Starts a Metro server on the given port, building bundles on the fly",
+  description: "Starts Metro on the given port, building bundles on the fly",
+  // $FlowFixMe[value-as-type]
   builder: yargs => {
     yargs.option("project-roots", {
       alias: "P",
@@ -79,13 +83,21 @@ module.exports = () => ({
       type: "number"
     });
     yargs.option("secure", {
-      type: "boolean"
+      type: "boolean",
+      describe: "(deprecated)"
     });
     yargs.option("secure-key", {
-      type: "string"
+      type: "string",
+      describe: "(deprecated)"
     });
     yargs.option("secure-cert", {
-      type: "string"
+      type: "string",
+      describe: "(deprecated)"
+    });
+    yargs.option("secure-server-options", {
+      alias: "s",
+      type: "string",
+      describe: "Use dot notation for object path"
     });
     yargs.option("hmr-enabled", {
       alias: "hmr",
@@ -95,17 +107,18 @@ module.exports = () => ({
       alias: "c",
       type: "string"
     }); // Deprecated
-    // $FlowFixMe Errors found when flow-typing `yargs`
 
     yargs.option("reset-cache", {
-      type: "boolean",
-      describe: null
-    });
+      type: "boolean"
+    }); // Examples
+
+    yargs.example(
+      "secure-server-options",
+      '-s.cert="$(cat path/to/cert)" -s.key="$(cat path/to/key")'
+    );
   },
-  // eslint-disable-next-line lint/no-unclear-flowtypes
   handler: makeAsyncCommand(
-    /*#__PURE__*/
-    (function() {
+    /*#__PURE__*/ (function() {
       var _ref = _asyncToGenerator(function*(argv) {
         let server = null;
         let restarting = false;
@@ -128,7 +141,8 @@ module.exports = () => ({
               yield promisify(server.close).call(server);
             }
 
-            const config = yield loadConfig(argv);
+            const config = yield loadConfig(argv); // $FlowExpectedError YargArguments and RunBuildOptions are used interchangeable but their types are not yet compatible
+
             server = yield MetroApi.runServer(config, argv);
             restarting = false;
           });
diff --git a/node_modules/metro/src/commands/serve.js.flow b/node_modules/metro/src/commands/serve.js.flow
index 11b355f..8ee5d2c 100644
--- a/node_modules/metro/src/commands/serve.js.flow
+++ b/node_modules/metro/src/commands/serve.js.flow
@@ -16,14 +16,22 @@ const {watchFile, makeAsyncCommand} = require('../cli-utils');
 const {loadConfig, resolveConfig} = require('metro-config');
 const {promisify} = require('util');
 
+import type {RunServerOptions} from '../index';
+import type {YargArguments} from 'metro-config/src/configTypes.flow';
 import typeof Yargs from 'yargs';
 
-module.exports = () => ({
+module.exports = (): ({|
+  // $FlowFixMe[value-as-type]
+  builder: (yargs: Yargs) => void,
+  command: $TEMPORARY$string<'serve'>,
+  description: string,
+  handler: (argv: YargArguments) => void,
+|}) => ({
   command: 'serve',
 
-  description:
-    'Starts a Metro server on the given port, building bundles on the fly',
+  description: 'Starts Metro on the given port, building bundles on the fly',
 
+  // $FlowFixMe[value-as-type]
   builder: (yargs: Yargs): void => {
     yargs.option('project-roots', {
       alias: 'P',
@@ -36,21 +44,30 @@ module.exports = () => ({
 
     yargs.option('max-workers', {alias: 'j', type: 'number'});
 
-    yargs.option('secure', {type: 'boolean'});
-    yargs.option('secure-key', {type: 'string'});
-    yargs.option('secure-cert', {type: 'string'});
+    yargs.option('secure', {type: 'boolean', describe: '(deprecated)'});
+    yargs.option('secure-key', {type: 'string', describe: '(deprecated)'});
+    yargs.option('secure-cert', {type: 'string', describe: '(deprecated)'});
+    yargs.option('secure-server-options', {
+      alias: 's',
+      type: 'string',
+      describe: 'Use dot notation for object path',
+    });
 
     yargs.option('hmr-enabled', {alias: 'hmr', type: 'boolean'});
 
     yargs.option('config', {alias: 'c', type: 'string'});
 
     // Deprecated
-    // $FlowFixMe Errors found when flow-typing `yargs`
-    yargs.option('reset-cache', {type: 'boolean', describe: null});
+    yargs.option('reset-cache', {type: 'boolean'});
+
+    // Examples
+    yargs.example(
+      'secure-server-options',
+      '-s.cert="$(cat path/to/cert)" -s.key="$(cat path/to/key")',
+    );
   },
 
-  // eslint-disable-next-line lint/no-unclear-flowtypes
-  handler: makeAsyncCommand(async (argv: any) => {
+  handler: makeAsyncCommand(async (argv: YargArguments) => {
     let server = null;
     let restarting = false;
 
@@ -69,7 +86,8 @@ module.exports = () => ({
 
       const config = await loadConfig(argv);
 
-      server = await MetroApi.runServer(config, argv);
+      // $FlowExpectedError YargArguments and RunBuildOptions are used interchangeable but their types are not yet compatible
+      server = await MetroApi.runServer(config, (argv: RunServerOptions));
 
       restarting = false;
     }
diff --git a/node_modules/metro/src/index.js b/node_modules/metro/src/index.js
index e9ff476..9fda26f 100644
--- a/node_modules/metro/src/index.js
+++ b/node_modules/metro/src/index.js
@@ -9,21 +9,42 @@
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,6 +59,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -49,6 +71,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -62,12 +85,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -81,6 +107,10 @@ const MetroServer = require("./Server");
 
 const attachWebsocketServer = require("./lib/attachWebsocketServer");
 
+const chalk = require("chalk");
+
+const fs = require("fs");
+
 const http = require("http");
 
 const https = require("https");
@@ -93,16 +123,13 @@ const makeServeCommand = require("./commands/serve");
 
 const outputBundle = require("./shared/output/bundle");
 
-const _require = require("fs-extra"),
-  readFile = _require.readFile;
-
-const _require2 = require("metro-config"),
-  loadConfig = _require2.loadConfig,
-  mergeConfig = _require2.mergeConfig,
-  getDefaultConfig = _require2.getDefaultConfig;
+const _require = require("metro-config"),
+  loadConfig = _require.loadConfig,
+  mergeConfig = _require.mergeConfig,
+  getDefaultConfig = _require.getDefaultConfig;
 
-const _require3 = require("metro-inspector-proxy"),
-  InspectorProxy = _require3.InspectorProxy;
+const _require2 = require("metro-inspector-proxy"),
+  InspectorProxy = _require2.InspectorProxy;
 
 function getConfig(_x) {
   return _getConfig.apply(this, arguments);
@@ -116,21 +143,21 @@ function _getConfig() {
   return _getConfig.apply(this, arguments);
 }
 
-function runMetro(_x2) {
+function runMetro(_x2, _x3) {
   return _runMetro.apply(this, arguments);
 }
 
 function _runMetro() {
-  _runMetro = _asyncToGenerator(function*(config) {
+  _runMetro = _asyncToGenerator(function*(config, options) {
     const mergedConfig = yield getConfig(config);
     mergedConfig.reporter.update({
-      type: "initialize_started",
+      hasReducedPerformance: options
+        ? Boolean(options.hasReducedPerformance)
+        : false,
       port: mergedConfig.server.port,
-      // FIXME: We need to change that to watchFolders. It will be a
-      // breaking since it affects custom reporter API.
-      projectRoots: mergedConfig.watchFolders
+      type: "initialize_started"
     });
-    return new MetroServer(mergedConfig);
+    return new MetroServer(mergedConfig, options);
   });
   return _runMetro.apply(this, arguments);
 }
@@ -138,279 +165,279 @@ function _runMetro() {
 exports.runMetro = runMetro;
 exports.loadConfig = loadConfig;
 
-exports.createConnectMiddleware =
-  /*#__PURE__*/
-  (function() {
-    var _ref = _asyncToGenerator(function*(config) {
-      const metroServer = yield runMetro(config);
-      let enhancedMiddleware = metroServer.processRequest; // Enhance the resulting middleware using the config options
-
-      if (config.server.enhanceMiddleware) {
-        enhancedMiddleware = config.server.enhanceMiddleware(
-          enhancedMiddleware,
-          metroServer
-        );
-      }
+exports.createConnectMiddleware = /*#__PURE__*/ (function() {
+  var _ref = _asyncToGenerator(function*(config, options) {
+    const metroServer = yield runMetro(config, options);
+    let enhancedMiddleware = metroServer.processRequest; // Enhance the resulting middleware using the config options
 
-      return {
-        attachHmrServer(httpServer) {
-          attachWebsocketServer({
-            httpServer,
-            path: "/hot",
-            websocketServer: new MetroHmrServer(
-              metroServer.getBundler(),
-              metroServer.getCreateModuleId(),
-              config
-            )
-          });
-        },
-
-        metroServer,
-        middleware: enhancedMiddleware,
-
-        end() {
-          metroServer.end();
-        }
-      };
-    });
+    if (config.server.enhanceMiddleware) {
+      enhancedMiddleware = config.server.enhanceMiddleware(
+        enhancedMiddleware,
+        metroServer
+      );
+    }
+
+    return {
+      attachHmrServer(httpServer) {
+        attachWebsocketServer({
+          httpServer,
+          path: "/hot",
+          websocketServer: new MetroHmrServer(
+            metroServer.getBundler(),
+            metroServer.getCreateModuleId(),
+            config
+          )
+        });
+      },
 
-    return function(_x3) {
-      return _ref.apply(this, arguments);
+      metroServer,
+      middleware: enhancedMiddleware,
+
+      end() {
+        metroServer.end();
+      }
     };
-  })();
-
-exports.runServer =
-  /*#__PURE__*/
-  (function() {
-    var _ref2 = _asyncToGenerator(function*(config, _ref3) {
-      let host = _ref3.host,
-        onReady = _ref3.onReady,
-        onError = _ref3.onError,
-        _ref3$secure = _ref3.secure,
-        secure = _ref3$secure === void 0 ? false : _ref3$secure,
-        secureKey = _ref3.secureKey,
-        secureCert = _ref3.secureCert,
-        _ref3$hmrEnabled = _ref3.hmrEnabled,
-        hmrEnabled = _ref3$hmrEnabled === void 0 ? false : _ref3$hmrEnabled;
-
-      // Lazy require
-      const connect = require("connect");
-
-      const serverApp = connect();
-
-      const _ref4 = yield exports.createConnectMiddleware(config),
-        attachHmrServer = _ref4.attachHmrServer,
-        middleware = _ref4.middleware,
-        metroServer = _ref4.metroServer,
-        end = _ref4.end;
-
-      serverApp.use(middleware);
-
-      if (config.server.enableVisualizer) {
-        let initializeVisualizerMiddleware;
-
-        try {
-          // eslint-disable-next-line import/no-extraneous-dependencies
-          var _require4 = require("metro-visualizer");
-
-          initializeVisualizerMiddleware =
-            _require4.initializeVisualizerMiddleware;
-        } catch (e) {
-          console.warn(
-            "'config.server.enableVisualizer' is enabled but the 'metro-visualizer' package was not found - have you installed it?"
-          );
-        }
+  });
 
-        if (initializeVisualizerMiddleware) {
-          serverApp.use(
-            "/visualizer",
-            initializeVisualizerMiddleware(metroServer)
-          );
+  return function(_x4, _x5) {
+    return _ref.apply(this, arguments);
+  };
+})();
+
+exports.runServer = /*#__PURE__*/ (function() {
+  var _ref2 = _asyncToGenerator(function*(config, _ref3) {
+    let _ref3$hasReducedPerfo = _ref3.hasReducedPerformance,
+      hasReducedPerformance =
+        _ref3$hasReducedPerfo === void 0 ? false : _ref3$hasReducedPerfo,
+      host = _ref3.host,
+      onError = _ref3.onError,
+      onReady = _ref3.onReady,
+      secureServerOptions = _ref3.secureServerOptions,
+      secure = _ref3.secure,
+      secureCert = _ref3.secureCert,
+      secureKey = _ref3.secureKey;
+
+    if (secure != null || secureCert != null || secureKey != null) {
+      // eslint-disable-next-line no-console
+      console.warn(
+        chalk.inverse.yellow.bold(" DEPRECATED "),
+        "The `secure`, `secureCert`, and `secureKey` options are now deprecated. " +
+          "Please use the `secureServerOptions` object instead to pass options to " +
+          "Metro's https development server."
+      );
+    } // Lazy require
+
+    const connect = require("connect");
+
+    const serverApp = connect();
+
+    const _yield$exports$create = yield exports.createConnectMiddleware(
+        config,
+        {
+          hasReducedPerformance
         }
-      }
+      ),
+      attachHmrServer = _yield$exports$create.attachHmrServer,
+      middleware = _yield$exports$create.middleware,
+      end = _yield$exports$create.end;
 
-      let inspectorProxy = null;
+    serverApp.use(middleware);
+    let inspectorProxy = null;
 
-      if (config.server.runInspectorProxy) {
-        inspectorProxy = new InspectorProxy();
-      }
+    if (config.server.runInspectorProxy) {
+      inspectorProxy = new InspectorProxy(config.projectRoot);
+    }
 
-      let httpServer;
+    let httpServer;
 
-      if (secure) {
-        httpServer = https.createServer(
+    if (secure || secureServerOptions != null) {
+      let options = secureServerOptions;
+
+      if (typeof secureKey === "string" && typeof secureCert === "string") {
+        options = Object.assign(
           {
-            key: yield readFile(secureKey),
-            cert: yield readFile(secureCert)
+            key: fs.readFileSync(secureKey),
+            cert: fs.readFileSync(secureCert)
           },
-          serverApp
+          secureServerOptions
         );
-      } else {
-        httpServer = http.createServer(serverApp);
       }
 
-      httpServer.on("error", error => {
-        onError && onError(error);
-        end();
-      });
-      return new Promise((resolve, reject) => {
-        httpServer.listen(config.server.port, host, () => {
-          onReady && onReady(httpServer);
+      httpServer = https.createServer(options, serverApp);
+    } else {
+      httpServer = http.createServer(serverApp);
+    }
 
-          if (hmrEnabled) {
-            attachHmrServer(httpServer);
-          }
+    httpServer.on("error", error => {
+      if (onError) {
+        onError(error);
+      }
 
-          if (inspectorProxy) {
-            inspectorProxy.addWebSocketListener(httpServer); // TODO(hypuk): Refactor inspectorProxy.processRequest into separate request handlers
-            // so that we could provide routes (/json/list and /json/version) here.
-            // Currently this causes Metro to give warning about T31407894.
+      end();
+    });
+    return new Promise((resolve, reject) => {
+      httpServer.listen(config.server.port, host, () => {
+        if (onReady) {
+          onReady(httpServer);
+        }
 
-            serverApp.use(inspectorProxy.processRequest.bind(inspectorProxy));
-          }
+        attachHmrServer(httpServer);
 
-          resolve(httpServer);
-        }); // Disable any kind of automatic timeout behavior for incoming
-        // requests in case it takes the packager more than the default
-        // timeout of 120 seconds to respond to a request.
+        if (inspectorProxy) {
+          inspectorProxy.addWebSocketListener(httpServer); // TODO(hypuk): Refactor inspectorProxy.processRequest into separate request handlers
+          // so that we could provide routes (/json/list and /json/version) here.
+          // Currently this causes Metro to give warning about T31407894.
 
-        httpServer.timeout = 0;
-        httpServer.on("error", error => {
-          end();
-          reject(error);
-        });
-        httpServer.on("close", () => {
-          end();
-        });
+          serverApp.use(inspectorProxy.processRequest.bind(inspectorProxy));
+        }
+
+        resolve(httpServer);
+      }); // Disable any kind of automatic timeout behavior for incoming
+      // requests in case it takes the packager more than the default
+      // timeout of 120 seconds to respond to a request.
+
+      httpServer.timeout = 0;
+      httpServer.on("error", error => {
+        end();
+        reject(error);
+      });
+      httpServer.on("close", () => {
+        end();
       });
     });
+  });
 
-    return function(_x4, _x5) {
-      return _ref2.apply(this, arguments);
-    };
-  })();
-
-exports.runBuild =
-  /*#__PURE__*/
-  (function() {
-    var _ref5 = _asyncToGenerator(function*(config, _ref6) {
-      let _ref6$dev = _ref6.dev,
-        dev = _ref6$dev === void 0 ? false : _ref6$dev,
-        entry = _ref6.entry,
-        onBegin = _ref6.onBegin,
-        onComplete = _ref6.onComplete,
-        onProgress = _ref6.onProgress,
-        _ref6$minify = _ref6.minify,
-        minify = _ref6$minify === void 0 ? true : _ref6$minify,
-        _ref6$output = _ref6.output,
-        output = _ref6$output === void 0 ? outputBundle : _ref6$output,
-        out = _ref6.out,
-        _ref6$platform = _ref6.platform,
-        platform = _ref6$platform === void 0 ? "web" : _ref6$platform,
-        _ref6$sourceMap = _ref6.sourceMap,
-        sourceMap = _ref6$sourceMap === void 0 ? false : _ref6$sourceMap,
-        sourceMapUrl = _ref6.sourceMapUrl;
-      const metroServer = yield runMetro(config);
-
-      try {
-        const requestOptions = {
-          dev,
-          entryFile: entry,
-          inlineSourceMap: sourceMap && !sourceMapUrl,
-          minify,
-          platform,
-          sourceMapUrl: sourceMap === false ? undefined : sourceMapUrl,
-          createModuleIdFactory: config.serializer.createModuleIdFactory,
-          onProgress
-        };
-
-        if (onBegin) {
-          onBegin();
-        }
+  return function(_x6, _x7) {
+    return _ref2.apply(this, arguments);
+  };
+})();
+
+exports.runBuild = /*#__PURE__*/ (function() {
+  var _ref4 = _asyncToGenerator(function*(config, _ref5) {
+    let _ref5$dev = _ref5.dev,
+      dev = _ref5$dev === void 0 ? false : _ref5$dev,
+      entry = _ref5.entry,
+      onBegin = _ref5.onBegin,
+      onComplete = _ref5.onComplete,
+      onProgress = _ref5.onProgress,
+      _ref5$minify = _ref5.minify,
+      minify = _ref5$minify === void 0 ? true : _ref5$minify,
+      _ref5$output = _ref5.output,
+      output = _ref5$output === void 0 ? outputBundle : _ref5$output,
+      out = _ref5.out,
+      _ref5$platform = _ref5.platform,
+      platform = _ref5$platform === void 0 ? "web" : _ref5$platform,
+      _ref5$sourceMap = _ref5.sourceMap,
+      sourceMap = _ref5$sourceMap === void 0 ? false : _ref5$sourceMap,
+      sourceMapUrl = _ref5.sourceMapUrl;
+    const metroServer = yield runMetro(config, {
+      watch: false
+    });
 
-        const metroBundle = yield output.build(metroServer, requestOptions);
+    try {
+      const requestOptions = {
+        dev,
+        entryFile: entry,
+        inlineSourceMap: sourceMap && !sourceMapUrl,
+        minify,
+        platform,
+        sourceMapUrl: sourceMap === false ? undefined : sourceMapUrl,
+        createModuleIdFactory: config.serializer.createModuleIdFactory,
+        onProgress
+      };
 
-        if (onComplete) {
-          onComplete();
-        }
+      if (onBegin) {
+        onBegin();
+      }
 
-        if (out) {
-          const bundleOutput = out.replace(/(\.js)?$/, ".js");
-          const sourcemapOutput =
-            sourceMap === false ? undefined : out.replace(/(\.js)?$/, ".map");
-          const outputOptions = {
-            bundleOutput,
-            sourcemapOutput,
-            dev,
-            platform
-          }; // eslint-disable-next-line no-console
+      const metroBundle = yield output.build(metroServer, requestOptions);
 
-          yield output.save(metroBundle, outputOptions, console.log);
-        }
+      if (onComplete) {
+        onComplete();
+      }
 
-        return metroBundle;
-      } finally {
-        yield metroServer.end();
+      if (out) {
+        const bundleOutput = out.replace(/(\.js)?$/, ".js");
+        const sourcemapOutput =
+          sourceMap === false ? undefined : out.replace(/(\.js)?$/, ".map");
+        const outputOptions = {
+          bundleOutput,
+          sourcemapOutput,
+          dev,
+          platform
+        }; // eslint-disable-next-line no-console
+
+        yield output.save(metroBundle, outputOptions, console.log);
       }
-    });
 
-    return function(_x6, _x7) {
-      return _ref5.apply(this, arguments);
-    };
-  })();
-
-exports.buildGraph =
-  /*#__PURE__*/
-  (function() {
-    var _ref7 = _asyncToGenerator(function*(config, _ref8) {
-      let _ref8$customTransform = _ref8.customTransformOptions,
-        customTransformOptions =
-          _ref8$customTransform === void 0
-            ? Object.create(null)
-            : _ref8$customTransform,
-        _ref8$dev = _ref8.dev,
-        dev = _ref8$dev === void 0 ? false : _ref8$dev,
-        entries = _ref8.entries,
-        _ref8$minify = _ref8.minify,
-        minify = _ref8$minify === void 0 ? false : _ref8$minify,
-        onProgress = _ref8.onProgress,
-        _ref8$platform = _ref8.platform,
-        platform = _ref8$platform === void 0 ? "web" : _ref8$platform,
-        _ref8$type = _ref8.type,
-        type = _ref8$type === void 0 ? "module" : _ref8$type;
-      const mergedConfig = yield getConfig(config);
-      const bundler = new IncrementalBundler(mergedConfig);
-
-      try {
-        return yield bundler.buildGraphForEntries(
-          entries,
-          _objectSpread({}, MetroServer.DEFAULT_GRAPH_OPTIONS, {
+      return metroBundle;
+    } finally {
+      yield metroServer.end();
+    }
+  });
+
+  return function(_x8, _x9) {
+    return _ref4.apply(this, arguments);
+  };
+})();
+
+exports.buildGraph = /*#__PURE__*/ (function() {
+  var _ref6 = _asyncToGenerator(function*(config, _ref7) {
+    let _ref7$customTransform = _ref7.customTransformOptions,
+      customTransformOptions =
+        _ref7$customTransform === void 0
+          ? Object.create(null)
+          : _ref7$customTransform,
+      _ref7$dev = _ref7.dev,
+      dev = _ref7$dev === void 0 ? false : _ref7$dev,
+      entries = _ref7.entries,
+      _ref7$minify = _ref7.minify,
+      minify = _ref7$minify === void 0 ? false : _ref7$minify,
+      onProgress = _ref7.onProgress,
+      _ref7$platform = _ref7.platform,
+      platform = _ref7$platform === void 0 ? "web" : _ref7$platform,
+      _ref7$type = _ref7.type,
+      type = _ref7$type === void 0 ? "module" : _ref7$type;
+    const mergedConfig = yield getConfig(config);
+    const bundler = new IncrementalBundler(mergedConfig);
+
+    try {
+      return yield bundler.buildGraphForEntries(
+        entries,
+        _objectSpread(
+          _objectSpread({}, MetroServer.DEFAULT_GRAPH_OPTIONS),
+          {},
+          {
             customTransformOptions,
             dev,
             minify,
             platform,
             type
-          })
-        );
-      } finally {
-        bundler.end();
-      }
-    });
+          }
+        )
+      );
+    } finally {
+      bundler.end();
+    }
+  });
 
-    return function(_x8, _x9) {
-      return _ref7.apply(this, arguments);
-    };
-  })();
+  return function(_x10, _x11) {
+    return _ref6.apply(this, arguments);
+  };
+})();
 
-exports.attachMetroCli = function(yargs) {
-  let _ref9 =
+exports.attachMetroCli = function(
+  // $FlowFixMe[value-as-type]
+  yargs
+) {
+  let _ref8 =
       arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
-    _ref9$build = _ref9.build,
-    build = _ref9$build === void 0 ? {} : _ref9$build,
-    _ref9$serve = _ref9.serve,
-    serve = _ref9$serve === void 0 ? {} : _ref9$serve,
-    _ref9$dependencies = _ref9.dependencies,
-    dependencies = _ref9$dependencies === void 0 ? {} : _ref9$dependencies;
+    _ref8$build = _ref8.build,
+    build = _ref8$build === void 0 ? {} : _ref8$build,
+    _ref8$serve = _ref8.serve,
+    serve = _ref8$serve === void 0 ? {} : _ref8$serve,
+    _ref8$dependencies = _ref8.dependencies,
+    dependencies = _ref8$dependencies === void 0 ? {} : _ref8$dependencies;
 
   if (build) {
     const _makeBuildCommand = makeBuildCommand(),
@@ -443,6 +470,4 @@ exports.attachMetroCli = function(yargs) {
   }
 
   return yargs;
-}; // The symbols below belong to the legacy API and should not be relied upon
-
-Object.assign(exports, require("./legacy"));
+};
diff --git a/node_modules/metro/src/index.js.flow b/node_modules/metro/src/index.js.flow
index 889e321..eeb1099 100644
--- a/node_modules/metro/src/index.js.flow
+++ b/node_modules/metro/src/index.js.flow
@@ -15,6 +15,8 @@ const MetroHmrServer = require('./HmrServer');
 const MetroServer = require('./Server');
 
 const attachWebsocketServer = require('./lib/attachWebsocketServer');
+const chalk = require('chalk');
+const fs = require('fs');
 const http = require('http');
 const https = require('https');
 const makeBuildCommand = require('./commands/build');
@@ -22,12 +24,11 @@ const makeDependenciesCommand = require('./commands/dependencies');
 const makeServeCommand = require('./commands/serve');
 const outputBundle = require('./shared/output/bundle');
 
-const {readFile} = require('fs-extra');
 const {loadConfig, mergeConfig, getDefaultConfig} = require('metro-config');
 const {InspectorProxy} = require('metro-inspector-proxy');
 
 import type {Graph} from './DeltaBundler';
-import type {CustomTransformOptions} from './JSTransformer/worker';
+import type {ServerOptions} from './Server';
 import type {RequestOptions, OutputOptions} from './shared/types.flow.js';
 import type {Server as HttpServer} from 'http';
 import type {Server as HttpsServer} from 'https';
@@ -36,6 +37,7 @@ import type {
   InputConfigT,
   Middleware,
 } from 'metro-config/src/configTypes.flow';
+import type {CustomTransformOptions} from 'metro-transform-worker';
 import typeof Yargs from 'yargs';
 
 type MetroMiddleWare = {|
@@ -45,23 +47,84 @@ type MetroMiddleWare = {|
   middleware: Middleware,
 |};
 
+export type RunServerOptions = {|
+  hasReducedPerformance?: boolean,
+  host?: string,
+  onError?: (Error & {|code?: string|}) => void,
+  onReady?: (server: HttpServer | HttpsServer) => void,
+  runInspectorProxy?: boolean,
+  secureServerOptions?: Object,
+  secure?: boolean, // deprecated
+  secureCert?: string, // deprecated
+  secureKey?: string, // deprecated
+|};
+
+type BuildGraphOptions = {|
+  entries: $ReadOnlyArray<string>,
+  customTransformOptions?: CustomTransformOptions,
+  dev?: boolean,
+  minify?: boolean,
+  onProgress?: (transformedFileCount: number, totalFileCount: number) => void,
+  platform?: string,
+  type?: 'module' | 'script',
+|};
+
+export type RunBuildOptions = {|
+  entry: string,
+  dev?: boolean,
+  out?: string,
+  onBegin?: () => void,
+  onComplete?: () => void,
+  onProgress?: (transformedFileCount: number, totalFileCount: number) => void,
+  minify?: boolean,
+  output?: {
+    build: (
+      MetroServer,
+      RequestOptions,
+    ) => Promise<{
+      code: string,
+      map: string,
+      ...
+    }>,
+    save: (
+      {
+        code: string,
+        map: string,
+        ...
+      },
+      OutputOptions,
+      (...args: Array<string>) => void,
+    ) => Promise<mixed>,
+    ...
+  },
+  platform?: string,
+  sourceMap?: boolean,
+  sourceMapUrl?: string,
+|};
+
+type BuildCommandOptions = {||} | null;
+type ServeCommandOptions = {||} | null;
+
 async function getConfig(config: InputConfigT): Promise<ConfigT> {
   const defaultConfig = await getDefaultConfig(config.projectRoot);
   return mergeConfig(defaultConfig, config);
 }
 
-async function runMetro(config: InputConfigT): Promise<MetroServer> {
+async function runMetro(
+  config: InputConfigT,
+  options?: ServerOptions,
+): Promise<MetroServer> {
   const mergedConfig = await getConfig(config);
 
   mergedConfig.reporter.update({
-    type: 'initialize_started',
+    hasReducedPerformance: options
+      ? Boolean(options.hasReducedPerformance)
+      : false,
     port: mergedConfig.server.port,
-    // FIXME: We need to change that to watchFolders. It will be a
-    // breaking since it affects custom reporter API.
-    projectRoots: mergedConfig.watchFolders,
+    type: 'initialize_started',
   });
 
-  return new MetroServer(mergedConfig);
+  return new MetroServer(mergedConfig, options);
 }
 
 exports.runMetro = runMetro;
@@ -69,8 +132,9 @@ exports.loadConfig = loadConfig;
 
 exports.createConnectMiddleware = async function(
   config: ConfigT,
+  options?: ServerOptions,
 ): Promise<MetroMiddleWare> {
-  const metroServer = await runMetro(config);
+  const metroServer = await runMetro(config, options);
 
   let enhancedMiddleware = metroServer.processRequest;
 
@@ -102,29 +166,28 @@ exports.createConnectMiddleware = async function(
   };
 };
 
-type RunServerOptions = {|
-  host?: string,
-  onReady?: (server: HttpServer | HttpsServer) => void,
-  onError?: (Error & {|code?: string|}) => void,
-  secure?: boolean,
-  secureKey?: string,
-  secureCert?: string,
-  hmrEnabled?: boolean,
-  runInspectorProxy?: boolean,
-|};
-
 exports.runServer = async (
   config: ConfigT,
   {
+    hasReducedPerformance = false,
     host,
-    onReady,
     onError,
-    secure = false,
-    secureKey,
-    secureCert,
-    hmrEnabled = false,
+    onReady,
+    secureServerOptions,
+    secure, //deprecated
+    secureCert, // deprecated
+    secureKey, // deprecated
   }: RunServerOptions,
 ): Promise<HttpServer | HttpsServer> => {
+  if (secure != null || secureCert != null || secureKey != null) {
+    // eslint-disable-next-line no-console
+    console.warn(
+      chalk.inverse.yellow.bold(' DEPRECATED '),
+      'The `secure`, `secureCert`, and `secureKey` options are now deprecated. ' +
+        'Please use the `secureServerOptions` object instead to pass options to ' +
+        "Metro's https development server.",
+    );
+  }
   // Lazy require
   const connect = require('connect');
 
@@ -133,48 +196,40 @@ exports.runServer = async (
   const {
     attachHmrServer,
     middleware,
-    metroServer,
     end,
-  } = await exports.createConnectMiddleware(config);
+  } = await exports.createConnectMiddleware(config, {
+    hasReducedPerformance,
+  });
 
   serverApp.use(middleware);
 
-  if (config.server.enableVisualizer) {
-    let initializeVisualizerMiddleware;
-    try {
-      // eslint-disable-next-line import/no-extraneous-dependencies
-      ({initializeVisualizerMiddleware} = require('metro-visualizer'));
-    } catch (e) {
-      console.warn(
-        "'config.server.enableVisualizer' is enabled but the 'metro-visualizer' package was not found - have you installed it?",
-      );
-    }
-    if (initializeVisualizerMiddleware) {
-      serverApp.use('/visualizer', initializeVisualizerMiddleware(metroServer));
-    }
-  }
-
   let inspectorProxy: ?InspectorProxy = null;
   if (config.server.runInspectorProxy) {
-    inspectorProxy = new InspectorProxy();
+    inspectorProxy = new InspectorProxy(config.projectRoot);
   }
 
   let httpServer;
 
-  if (secure) {
-    httpServer = https.createServer(
-      {
-        key: await readFile(secureKey),
-        cert: await readFile(secureCert),
-      },
-      serverApp,
-    );
+  if (secure || secureServerOptions != null) {
+    let options = secureServerOptions;
+    if (typeof secureKey === 'string' && typeof secureCert === 'string') {
+      options = Object.assign(
+        {
+          key: fs.readFileSync(secureKey),
+          cert: fs.readFileSync(secureCert),
+        },
+        secureServerOptions,
+      );
+    }
+    httpServer = https.createServer(options, serverApp);
   } else {
     httpServer = http.createServer(serverApp);
   }
 
   httpServer.on('error', error => {
-    onError && onError(error);
+    if (onError) {
+      onError(error);
+    }
     end();
   });
 
@@ -184,11 +239,11 @@ exports.runServer = async (
       reject: mixed => mixed,
     ) => {
       httpServer.listen(config.server.port, host, () => {
-        onReady && onReady(httpServer);
-        if (hmrEnabled) {
-          attachHmrServer(httpServer);
+        if (onReady) {
+          onReady(httpServer);
         }
 
+        attachHmrServer(httpServer);
         if (inspectorProxy) {
           inspectorProxy.addWebSocketListener(httpServer);
 
@@ -218,40 +273,6 @@ exports.runServer = async (
   );
 };
 
-type BuildGraphOptions = {|
-  entries: $ReadOnlyArray<string>,
-  customTransformOptions?: CustomTransformOptions,
-  dev?: boolean,
-  minify?: boolean,
-  onProgress?: (transformedFileCount: number, totalFileCount: number) => void,
-  platform?: string,
-  type?: 'module' | 'script',
-|};
-
-type RunBuildOptions = {|
-  entry: string,
-  dev?: boolean,
-  out?: string,
-  onBegin?: () => void,
-  onComplete?: () => void,
-  onProgress?: (transformedFileCount: number, totalFileCount: number) => void,
-  minify?: boolean,
-  output?: {
-    build: (
-      MetroServer,
-      RequestOptions,
-    ) => Promise<{code: string, map: string}>,
-    save: (
-      {code: string, map: string},
-      OutputOptions,
-      (...args: Array<string>) => void,
-    ) => Promise<mixed>,
-  },
-  platform?: string,
-  sourceMap?: boolean,
-  sourceMapUrl?: string,
-|};
-
 exports.runBuild = async (
   config: ConfigT,
   {
@@ -267,8 +288,14 @@ exports.runBuild = async (
     sourceMap = false,
     sourceMapUrl,
   }: RunBuildOptions,
-): Promise<{code: string, map: string}> => {
-  const metroServer = await runMetro(config);
+): Promise<{
+  code: string,
+  map: string,
+  ...
+}> => {
+  const metroServer = await runMetro(config, {
+    watch: false,
+  });
 
   try {
     const requestOptions: RequestOptions = {
@@ -344,10 +371,8 @@ exports.buildGraph = async function(
   }
 };
 
-type BuildCommandOptions = {||} | null;
-type ServeCommandOptions = {||} | null;
-
 exports.attachMetroCli = function(
+  // $FlowFixMe[value-as-type]
   yargs: Yargs,
   {
     build = {},
@@ -357,7 +382,9 @@ exports.attachMetroCli = function(
     build: BuildCommandOptions,
     serve: ServeCommandOptions,
     dependencies: any,
+    ...
   } = {},
+  // $FlowFixMe[value-as-type]
 ): Yargs {
   if (build) {
     const {command, description, builder, handler} = makeBuildCommand();
@@ -373,6 +400,3 @@ exports.attachMetroCli = function(
   }
   return yargs;
 };
-
-// The symbols below belong to the legacy API and should not be relied upon
-Object.assign(exports, require('./legacy'));
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/AssetRegistry.js b/node_modules/metro/src/integration_tests/basic_bundle/AssetRegistry.js
index 6ec62bf..a3857bf 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/AssetRegistry.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/AssetRegistry.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/Bar.js b/node_modules/metro/src/integration_tests/basic_bundle/Bar.js
index 8471104..c5cd0c6 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/Bar.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/Bar.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/ErrorBundle.js b/node_modules/metro/src/integration_tests/basic_bundle/ErrorBundle.js
index dd6a218..1a97c5f 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/ErrorBundle.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/ErrorBundle.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict"; // Add a random require to fill the bundle with some sourcecode.
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/ErrorBundle.js.flow b/node_modules/metro/src/integration_tests/basic_bundle/ErrorBundle.js.flow
index 59d06dd..95864fb 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/ErrorBundle.js.flow
+++ b/node_modules/metro/src/integration_tests/basic_bundle/ErrorBundle.js.flow
@@ -20,4 +20,4 @@ const calcSum = (value: string) => {
   return error;
 };
 
-module.exports = calcSum('anything');
+module.exports = (calcSum('anything'): Error);
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/Foo.js b/node_modules/metro/src/integration_tests/basic_bundle/Foo.js
index f494e8f..dc93060 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/Foo.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/Foo.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/TestBundle.js b/node_modules/metro/src/integration_tests/basic_bundle/TestBundle.js
index 3c829cb..a23cb34 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/TestBundle.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/TestBundle.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/TestPolyfill.js b/node_modules/metro/src/integration_tests/basic_bundle/TestPolyfill.js
index de5d04c..054a13d 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/TestPolyfill.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/TestPolyfill.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-1.js b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-1.js
index 11b2af8..87d520e 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-1.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-1.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-2.js b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-2.js
index 8a7fdc7..12a8f50 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-2.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-2.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-3.js b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-3.js
index 2b6389f..42d4efa 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-3.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-3.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-4.js b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-4.js
index 818e620..ab3a36b 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-4.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-4.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-5.js b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-5.js
index 5579e4c..03804ea 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-5.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-5.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-6.js b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-6.js
index 4beb4cb..7799712 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-6.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-6.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-null.js b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-null.js
index 755e03b..5caebaf 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-null.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-null.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-primitive-default.js b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-primitive-default.js
index 8dd6c49..13f4fa0 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-primitive-default.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/export-primitive-default.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/index.js b/node_modules/metro/src/integration_tests/basic_bundle/import-export/index.js
index 662f82e..f7cf23a 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/index.js
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/index.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
@@ -41,32 +41,66 @@ var _export3 = _interopRequireDefault(require("./export-3"));
 var _export4 = require("./export-4");
 
 function _interopRequireDefault(obj) {
-  return obj && obj.__esModule ? obj : { default: obj };
+  return obj && obj.__esModule
+    ? obj
+    : {
+        default: obj
+      };
+}
+
+function _getRequireWildcardCache() {
+  if (typeof WeakMap !== "function") return null;
+  var cache = new WeakMap();
+
+  _getRequireWildcardCache = function() {
+    return cache;
+  };
+
+  return cache;
 }
 
 function _interopRequireWildcard(obj) {
   if (obj && obj.__esModule) {
     return obj;
-  } else {
-    var newObj = {};
-    if (obj != null) {
-      for (var key in obj) {
-        if (Object.prototype.hasOwnProperty.call(obj, key)) {
-          var desc =
-            Object.defineProperty && Object.getOwnPropertyDescriptor
-              ? Object.getOwnPropertyDescriptor(obj, key)
-              : {};
-          if (desc.get || desc.set) {
-            Object.defineProperty(newObj, key, desc);
-          } else {
-            newObj[key] = obj[key];
-          }
-        }
+  }
+
+  if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
+    return {
+      default: obj
+    };
+  }
+
+  var cache = _getRequireWildcardCache();
+
+  if (cache && cache.has(obj)) {
+    return cache.get(obj);
+  }
+
+  var newObj = {};
+  var hasPropertyDescriptor =
+    Object.defineProperty && Object.getOwnPropertyDescriptor;
+
+  for (var key in obj) {
+    if (Object.prototype.hasOwnProperty.call(obj, key)) {
+      var desc = hasPropertyDescriptor
+        ? Object.getOwnPropertyDescriptor(obj, key)
+        : null;
+
+      if (desc && (desc.get || desc.set)) {
+        Object.defineProperty(newObj, key, desc);
+      } else {
+        newObj[key] = obj[key];
       }
     }
-    newObj.default = obj;
-    return newObj;
   }
+
+  newObj.default = obj;
+
+  if (cache) {
+    cache.set(obj, newObj);
+  }
+
+  return newObj;
 }
 
 const extraData = {
diff --git a/node_modules/metro/src/integration_tests/basic_bundle/import-export/index.js.flow b/node_modules/metro/src/integration_tests/basic_bundle/import-export/index.js.flow
index 7e4b9c1..dc6ec35 100644
--- a/node_modules/metro/src/integration_tests/basic_bundle/import-export/index.js.flow
+++ b/node_modules/metro/src/integration_tests/basic_bundle/import-export/index.js.flow
@@ -25,7 +25,7 @@ export const extraData = {
   importStar,
   myDefault,
   myFoo,
-  myFunction: myFunction(),
+  myFunction: (myFunction(): string),
   primitiveDefault,
   primitiveFoo,
 };
diff --git a/node_modules/metro/src/integration_tests/execBundle.js b/node_modules/metro/src/integration_tests/execBundle.js
index dc43195..3d94911 100644
--- a/node_modules/metro/src/integration_tests/execBundle.js
+++ b/node_modules/metro/src/integration_tests/execBundle.js
@@ -16,8 +16,8 @@ const vm = require("vm");
 
 module.exports = function execBundle(code) {
   let context =
-    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
-  // Verify the code can run on older VMs by parsing it as ES5 (versus ES6+).
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Verify the code can run on older VMs by parsing it as ES5 (versus ES6+).
+
   acorn.parse(code, {
     ecmaVersion: 5
   });
diff --git a/node_modules/metro/src/integration_tests/execBundle.js.flow b/node_modules/metro/src/integration_tests/execBundle.js.flow
index 3a3ca68..e85c9d3 100644
--- a/node_modules/metro/src/integration_tests/execBundle.js.flow
+++ b/node_modules/metro/src/integration_tests/execBundle.js.flow
@@ -14,7 +14,7 @@
 const acorn = require('acorn');
 const vm = require('vm');
 
-module.exports = function execBundle(code: string, context: {} = {}): mixed {
+module.exports = function execBundle(code: string, context: {...} = {}): mixed {
   // Verify the code can run on older VMs by parsing it as ES5 (versus ES6+).
   acorn.parse(code, {ecmaVersion: 5});
 
diff --git a/node_modules/metro/src/integration_tests/metro.config.js b/node_modules/metro/src/integration_tests/metro.config.js
index f98354b..01183cf 100644
--- a/node_modules/metro/src/integration_tests/metro.config.js
+++ b/node_modules/metro/src/integration_tests/metro.config.js
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +31,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -51,7 +55,7 @@ module.exports = {
   reporter: {
     update() {}
   },
-  watchFolders: [path.resolve(__dirname, "../../")],
+  watchFolders: [path.resolve(__dirname, "../../../")],
   server: {
     port: 10028
   },
@@ -61,7 +65,7 @@ module.exports = {
   transformer: {
     assetRegistryPath: path.join(ROOT_PATH, "AssetRegistry"),
     asyncRequireModulePath: require.resolve(
-      "metro/src/lib/bundle-modules/asyncRequire"
+      "metro-runtime/src/modules/asyncRequire"
     ),
     babelTransformerPath: require.resolve(
       "metro-react-native-babel-transformer"
diff --git a/node_modules/metro/src/legacy.js b/node_modules/metro/src/legacy.js
deleted file mode 100644
index 4334b6f..0000000
--- a/node_modules/metro/src/legacy.js
+++ /dev/null
@@ -1,212 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
-  try {
-    var info = gen[key](arg);
-    var value = info.value;
-  } catch (error) {
-    reject(error);
-    return;
-  }
-  if (info.done) {
-    resolve(value);
-  } else {
-    Promise.resolve(value).then(_next, _throw);
-  }
-}
-
-function _asyncToGenerator(fn) {
-  return function() {
-    var self = this,
-      args = arguments;
-    return new Promise(function(resolve, reject) {
-      var gen = fn.apply(self, args);
-      function _next(value) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
-      }
-      function _throw(err) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
-      }
-      _next(undefined);
-    });
-  };
-}
-
-function _objectSpread(target) {
-  for (var i = 1; i < arguments.length; i++) {
-    var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
-    }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
-  }
-  return target;
-}
-
-function _defineProperty(obj, key, value) {
-  if (key in obj) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-  } else {
-    obj[key] = value;
-  }
-  return obj;
-}
-
-const blacklist = require("metro-config/src/defaults/blacklist");
-
-const invariant = require("invariant");
-
-const _require = require("metro-core"),
-  Logger = _require.Logger;
-
-const _require2 = require("metro-source-map"),
-  fromRawMappings = _require2.fromRawMappings,
-  toSegmentTuple = _require2.toSegmentTuple;
-
-exports.createBlacklist = blacklist;
-exports.sourceMaps = {
-  fromRawMappings,
-  compactMapping: toSegmentTuple
-};
-exports.createServer = createServer;
-exports.Logger = Logger;
-
-/**
- * This is a public API, so we don't trust the value and purposefully downgrade
- * it as `mixed`. Because it understands `invariant`, Flow ensure that we
- * refine these values completely.
- */
-function assertPublicBundleOptions(bo) {
-  invariant(
-    typeof bo === "object" && bo != null,
-    "bundle options must be an object"
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.dev === undefined || typeof bo.dev === "boolean",
-    "bundle options field `dev` must be a boolean"
-  );
-  const entryFile = bo.entryFile;
-  invariant(
-    typeof entryFile === "string",
-    "bundle options must contain a string field `entryFile`"
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.inlineSourceMap === undefined || typeof bo.inlineSourceMap === "boolean",
-    "bundle options field `inlineSourceMap` must be a boolean"
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.minify === undefined || typeof bo.minify === "boolean",
-    "bundle options field `minify` must be a boolean"
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.platform === undefined || typeof bo.platform === "string",
-    "bundle options field `platform` must be a string"
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.runModule === undefined || typeof bo.runModule === "boolean",
-    "bundle options field `runModule` must be a boolean"
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.sourceMapUrl === undefined || typeof bo.sourceMapUrl === "string",
-    "bundle options field `sourceMapUrl` must be a boolean"
-  );
-  return _objectSpread(
-    {
-      entryFile
-    },
-    bo
-  );
-}
-
-exports.build =
-  /*#__PURE__*/
-  (function() {
-    var _ref = _asyncToGenerator(function*(options, bundleOptions) {
-      // TODO: Find out if this is used at all
-      // // eslint-disable-next-line lint/strictly-null
-      // if (options.targetBabelVersion !== undefined) {
-      //   process.env.BABEL_VERSION = String(options.targetBabelVersion);
-      // }
-      var server = createNonPersistentServer(options);
-
-      const ServerClass = require("./Server");
-
-      const result = yield server.build(
-        _objectSpread(
-          {},
-          ServerClass.DEFAULT_BUNDLE_OPTIONS,
-          assertPublicBundleOptions(bundleOptions),
-          {
-            bundleType: "todo"
-          }
-        )
-      );
-      server.end();
-      return result;
-    });
-
-    return function(_x, _x2) {
-      return _ref.apply(this, arguments);
-    };
-  })();
-
-exports.getOrderedDependencyPaths =
-  /*#__PURE__*/
-  (function() {
-    var _ref2 = _asyncToGenerator(function*(options, depOptions) {
-      var server = createNonPersistentServer(options);
-
-      try {
-        return yield server.getOrderedDependencyPaths(depOptions);
-      } finally {
-        server.end();
-      }
-    });
-
-    return function(_x3, _x4) {
-      return _ref2.apply(this, arguments);
-    };
-  })();
-
-function createServer(options) {
-  // Some callsites may not be Flowified yet.
-  invariant(
-    options.transformer.assetRegistryPath != null,
-    "createServer() requires assetRegistryPath"
-  );
-
-  const ServerClass = require("./Server");
-
-  return new ServerClass(options);
-}
-
-function createNonPersistentServer(config) {
-  return createServer(config);
-}
diff --git a/node_modules/metro/src/legacy.js.flow b/node_modules/metro/src/legacy.js.flow
deleted file mode 100644
index 781730d..0000000
--- a/node_modules/metro/src/legacy.js.flow
+++ /dev/null
@@ -1,139 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-const blacklist = require('metro-config/src/defaults/blacklist');
-const invariant = require('invariant');
-
-const {Logger} = require('metro-core');
-const {fromRawMappings, toSegmentTuple} = require('metro-source-map');
-
-import type Server from './Server';
-import type {ConfigT} from 'metro-config/src/configTypes.flow';
-
-exports.createBlacklist = blacklist;
-exports.sourceMaps = {fromRawMappings, compactMapping: toSegmentTuple};
-exports.createServer = createServer;
-exports.Logger = Logger;
-
-type PublicBundleOptions = {|
-  +dev?: boolean,
-  +entryFile: string,
-  +inlineSourceMap?: boolean,
-  +minify?: boolean,
-  +platform?: string,
-  +runModule?: boolean,
-  +sourceMapUrl?: string,
-|};
-
-/**
- * This is a public API, so we don't trust the value and purposefully downgrade
- * it as `mixed`. Because it understands `invariant`, Flow ensure that we
- * refine these values completely.
- */
-function assertPublicBundleOptions(bo: mixed): PublicBundleOptions {
-  invariant(
-    typeof bo === 'object' && bo != null,
-    'bundle options must be an object',
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.dev === undefined || typeof bo.dev === 'boolean',
-    'bundle options field `dev` must be a boolean',
-  );
-  const {entryFile} = bo;
-  invariant(
-    typeof entryFile === 'string',
-    'bundle options must contain a string field `entryFile`',
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.inlineSourceMap === undefined || typeof bo.inlineSourceMap === 'boolean',
-    'bundle options field `inlineSourceMap` must be a boolean',
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.minify === undefined || typeof bo.minify === 'boolean',
-    'bundle options field `minify` must be a boolean',
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.platform === undefined || typeof bo.platform === 'string',
-    'bundle options field `platform` must be a string',
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.runModule === undefined || typeof bo.runModule === 'boolean',
-    'bundle options field `runModule` must be a boolean',
-  );
-  invariant(
-    // eslint-disable-next-line lint/strictly-null
-    bo.sourceMapUrl === undefined || typeof bo.sourceMapUrl === 'string',
-    'bundle options field `sourceMapUrl` must be a boolean',
-  );
-  return {entryFile, ...bo};
-}
-
-exports.build = async function(
-  options: ConfigT,
-  bundleOptions: PublicBundleOptions,
-): Promise<{code: string, map: string}> {
-  // TODO: Find out if this is used at all
-  // // eslint-disable-next-line lint/strictly-null
-  // if (options.targetBabelVersion !== undefined) {
-  //   process.env.BABEL_VERSION = String(options.targetBabelVersion);
-  // }
-  var server = createNonPersistentServer(options);
-  const ServerClass = require('./Server');
-
-  const result = await server.build({
-    ...ServerClass.DEFAULT_BUNDLE_OPTIONS,
-    ...assertPublicBundleOptions(bundleOptions),
-    bundleType: 'todo',
-  });
-
-  server.end();
-
-  return result;
-};
-
-exports.getOrderedDependencyPaths = async function(
-  options: ConfigT,
-  depOptions: {
-    +dev: boolean,
-    +entryFile: string,
-    +minify: boolean,
-    +platform: string,
-  },
-): Promise<Array<string>> {
-  var server = createNonPersistentServer(options);
-
-  try {
-    return await server.getOrderedDependencyPaths(depOptions);
-  } finally {
-    server.end();
-  }
-};
-
-function createServer(options: ConfigT): Server {
-  // Some callsites may not be Flowified yet.
-  invariant(
-    options.transformer.assetRegistryPath != null,
-    'createServer() requires assetRegistryPath',
-  );
-
-  const ServerClass = require('./Server');
-  return new ServerClass(options);
-}
-
-function createNonPersistentServer(config: ConfigT): Server {
-  return createServer(config);
-}
diff --git a/node_modules/metro/src/lib/BatchProcessor.js b/node_modules/metro/src/lib/BatchProcessor.js
index 70899ed..cbd6cf4 100644
--- a/node_modules/metro/src/lib/BatchProcessor.js
+++ b/node_modules/metro/src/lib/BatchProcessor.js
@@ -10,7 +10,6 @@
 "use strict";
 
 const invariant = require("invariant");
-
 /**
  * We batch items together trying to minimize their processing, for example as
  * network queries. For that we wait a small moment before processing a batch.
@@ -18,6 +17,7 @@ const invariant = require("invariant");
  * if we have many items pending in a short amount of time, we can start
  * processing right away.
  */
+
 class BatchProcessor {
   constructor(options, processBatch) {
     this._options = options;
diff --git a/node_modules/metro/src/lib/BatchProcessor.js.flow b/node_modules/metro/src/lib/BatchProcessor.js.flow
index fc74e31..a502af1 100644
--- a/node_modules/metro/src/lib/BatchProcessor.js.flow
+++ b/node_modules/metro/src/lib/BatchProcessor.js.flow
@@ -20,12 +20,14 @@ type BatchProcessorOptions = {
   maximumDelayMs: number,
   maximumItems: number,
   concurrency: number,
+  ...
 };
 
 type QueueItem<TItem, TResult> = {
   item: TItem,
   reject: (error: mixed) => mixed,
   resolve: (result: TResult) => mixed,
+  ...
 };
 
 /**
diff --git a/node_modules/metro/src/lib/JsonReporter.js.flow b/node_modules/metro/src/lib/JsonReporter.js.flow
index 157069d..c77a3b8 100644
--- a/node_modules/metro/src/lib/JsonReporter.js.flow
+++ b/node_modules/metro/src/lib/JsonReporter.js.flow
@@ -12,7 +12,7 @@
 
 const {Writable} = require('stream');
 
-class JsonReporter<TEvent: {[string]: any}> {
+class JsonReporter<TEvent: {[string]: any, ...}> {
   _stream: Writable;
 
   constructor(stream: Writable) {
diff --git a/node_modules/metro/src/lib/RamBundleParser.js b/node_modules/metro/src/lib/RamBundleParser.js
index eb365f1..1d7f397 100644
--- a/node_modules/metro/src/lib/RamBundleParser.js
+++ b/node_modules/metro/src/lib/RamBundleParser.js
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/lib/RamBundleParser.js.flow b/node_modules/metro/src/lib/RamBundleParser.js.flow
index be365ea..fe18691 100644
--- a/node_modules/metro/src/lib/RamBundleParser.js.flow
+++ b/node_modules/metro/src/lib/RamBundleParser.js.flow
@@ -7,6 +7,7 @@
  * @format
  * @flow strict
  */
+
 'use strict';
 
 const MAGIC_NUMBER = require('../shared/output/RamBundle/magic-number');
diff --git a/node_modules/metro/src/lib/TerminalReporter.js b/node_modules/metro/src/lib/TerminalReporter.js
index 1615b04..172eec4 100644
--- a/node_modules/metro/src/lib/TerminalReporter.js
+++ b/node_modules/metro/src/lib/TerminalReporter.js
@@ -11,19 +11,27 @@
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -31,6 +39,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -43,6 +52,7 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
@@ -50,21 +60,84 @@ function _arrayWithHoles(arr) {
   if (Array.isArray(arr)) return arr;
 }
 
+function _toConsumableArray(arr) {
+  return (
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
+  );
+}
+
+function _nonIterableSpread() {
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _iterableToArray(iter) {
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
+    return Array.from(iter);
+}
+
+function _arrayWithoutHoles(arr) {
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -79,11 +152,14 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
 const chalk = require("chalk");
 
+const logToConsole = require("./logToConsole");
+
 const path = require("path");
 
 const reporting = require("./reporting");
@@ -93,20 +169,16 @@ const throttle = require("lodash.throttle");
 const _require = require("metro-core"),
   AmbiguousModuleResolutionError = _require.AmbiguousModuleResolutionError;
 
-const _require2 = require("metro-core"),
-  formatBanner = _require2.formatBanner;
-
-const DEP_GRAPH_MESSAGE = "Loading dependency graph";
 const GLOBAL_CACHE_DISABLED_MESSAGE_FORMAT =
   "The global cache is now disabled because %s";
 const DARK_BLOCK_CHAR = "\u2593";
 const LIGHT_BLOCK_CHAR = "\u2591";
 const MAX_PROGRESS_BAR_CHAR_WIDTH = 16;
-
 /**
  * We try to print useful information to the terminal for interactive builds.
  * This implements the `Reporter` interface from the './reporting' module.
  */
+
 class TerminalReporter {
   /**
    * The bundle builds for which we are actively maintaining the status on the
@@ -114,13 +186,16 @@ class TerminalReporter {
    * built at the same time.
    */
   constructor(terminal) {
-    this._dependencyGraphHasLoaded = false;
     this._activeBundles = new Map();
     this._scheduleUpdateBundleProgress = throttle(data => {
       this.update(
-        _objectSpread({}, data, {
-          type: "bundle_transform_progressed_throttled"
-        })
+        _objectSpread(
+          _objectSpread({}, data),
+          {},
+          {
+            type: "bundle_transform_progressed_throttled"
+          }
+        )
       );
     }, 100);
     this.terminal = terminal;
@@ -129,41 +204,45 @@ class TerminalReporter {
    * Construct a message that represents the progress of a
    * single bundle build, for example:
    *
-   *     BUNDLE [ios, dev, minified] foo.js  ▓▓▓▓▓░░░░░░░░░░░ 36.6% (4790/7922)
+   *     BUNDLE path/to/bundle.js ▓▓▓▓▓░░░░░░░░░░░ 36.6% (4790/7922)
    */
 
   _getBundleStatusMessage(_ref, phase) {
     let _ref$bundleDetails = _ref.bundleDetails,
       entryFile = _ref$bundleDetails.entryFile,
-      platform = _ref$bundleDetails.platform,
-      dev = _ref$bundleDetails.dev,
-      minify = _ref$bundleDetails.minify,
       bundleType = _ref$bundleDetails.bundleType,
+      runtimeBytecodeVersion = _ref$bundleDetails.runtimeBytecodeVersion,
       transformedFileCount = _ref.transformedFileCount,
       totalFileCount = _ref.totalFileCount,
       ratio = _ref.ratio;
+
+    if (runtimeBytecodeVersion) {
+      bundleType = "bytecodebundle";
+    }
+
     const localPath = path.relative(".", entryFile);
-    const fileName = path.basename(localPath);
-    const dirName = path.dirname(localPath);
-    platform = platform ? platform + ", " : "";
-    const devOrProd = dev ? "dev" : "prod";
-    const min = minify ? ", minified" : "";
-    const progress = (100 * ratio).toFixed(1);
-    const currentPhase =
-      phase === "done" ? ", done." : phase === "failed" ? ", failed." : "";
     const filledBar = Math.floor(ratio * MAX_PROGRESS_BAR_CHAR_WIDTH);
+    const bundleTypeColor =
+      phase === "done"
+        ? chalk.green
+        : phase === "failed"
+        ? chalk.red
+        : chalk.yellow;
+    const progress =
+      phase === "in_progress"
+        ? chalk.green.bgGreen(DARK_BLOCK_CHAR.repeat(filledBar)) +
+          chalk.bgWhite.white(
+            LIGHT_BLOCK_CHAR.repeat(MAX_PROGRESS_BAR_CHAR_WIDTH - filledBar)
+          ) +
+          chalk.bold(` ${(100 * ratio).toFixed(1)}% `) +
+          chalk.dim(`(${transformedFileCount}/${totalFileCount})`)
+        : "";
     return (
-      chalk.inverse.green.bold(` ${bundleType.toUpperCase()} `) +
-      chalk.dim(` [${platform}${devOrProd}${min}] ${dirName}/`) +
-      chalk.bold(fileName) +
+      bundleTypeColor.inverse.bold(` ${bundleType.toUpperCase()} `) +
+      chalk.reset.dim(` ${path.dirname(localPath)}/`) +
+      chalk.bold(path.basename(localPath)) +
       " " +
-      chalk.green.bgGreen(DARK_BLOCK_CHAR.repeat(filledBar)) +
-      chalk.bgWhite.white(
-        LIGHT_BLOCK_CHAR.repeat(MAX_PROGRESS_BAR_CHAR_WIDTH - filledBar)
-      ) +
-      chalk.bold(` ${progress}% `) +
-      chalk.dim(`(${transformedFileCount}/${totalFileCount})`) +
-      currentPhase +
+      progress +
       "\n"
     );
   }
@@ -195,10 +274,14 @@ class TerminalReporter {
 
     if (progress != null) {
       const msg = this._getBundleStatusMessage(
-        _objectSpread({}, progress, {
-          ratio: 1,
-          transformedFileCount: progress.totalFileCount
-        }),
+        _objectSpread(
+          _objectSpread({}, progress),
+          {},
+          {
+            ratio: 1,
+            transformedFileCount: progress.totalFileCount
+          }
+        ),
         "done"
       );
 
@@ -218,40 +301,40 @@ class TerminalReporter {
     }
   }
 
-  _logInitializing(port, projectRoots) {
-    if (port) {
-      this.terminal.log(
-        formatBanner(
-          "Running Metro Bundler on port " +
-            port +
-            ".\n\n" +
-            "Keep Metro running while developing on any JS projects. Feel " +
-            "free to close this tab and run your own Metro instance " +
-            "if you prefer.\n\n" +
-            "https://github.com/facebook/react-native",
-          {
-            paddingTop: 1,
-            paddingBottom: 1
-          }
-        ) + "\n"
-      );
-    }
-
-    this.terminal.log(
-      "Looking for JS files in\n  ",
-      chalk.dim(projectRoots.join("\n   ")),
-      "\n"
-    );
+  _logInitializing(port, hasReducedPerformance) {
+    const logo = [
+      "                                                      ",
+      "                        #######                       ",
+      "                   ################                   ",
+      "                #########     #########               ",
+      "            #########             ##########          ",
+      "        #########        ######        #########      ",
+      "       ##########################################     ",
+      "      #####      #####################       #####    ",
+      "      #####          ##############          #####    ",
+      "      #####    ###       ######       ###    #####    ",
+      "      #####    #######            #######    #####    ",
+      "      #####    ###########    ###########    #####    ",
+      "      #####    ##########################    #####    ",
+      "      #####    ##########################    #####    ",
+      "      #####      ######################     ######    ",
+      "       ######        #############        #######     ",
+      "         #########        ####       #########        ",
+      "              #########          #########            ",
+      "                  ######### #########                 ",
+      "                       #########                      ",
+      "                                                      ",
+      "                                                      "
+    ];
+    const color = hasReducedPerformance ? chalk.red : chalk.blue;
+    this.terminal.log(color(logo.join("\n")));
   }
 
   _logInitializingFailed(port, error) {
     if (error.code === "EADDRINUSE") {
       this.terminal.log(
         chalk.bgRed.bold(" ERROR "),
-        chalk.red(
-          "Metro Bundler can't listen on port",
-          chalk.bold(String(port))
-        )
+        chalk.red("Metro can't listen on port", chalk.bold(String(port)))
       );
       this.terminal.log(
         "Most likely another process is already using this port"
@@ -260,7 +343,7 @@ class TerminalReporter {
       this.terminal.log("\n  ", chalk.bold("lsof -i :" + port), "\n");
       this.terminal.log("Then, you can either shut down the other process:");
       this.terminal.log("\n  ", chalk.bold("kill -9 <PID>"), "\n");
-      this.terminal.log("or run Metro Bundler on different port.");
+      this.terminal.log("or run Metro on different port.");
     } else {
       this.terminal.log(chalk.bgRed.bold(" ERROR "), chalk.red(error.message));
       const errorAttributes = JSON.stringify(error);
@@ -280,12 +363,8 @@ class TerminalReporter {
   _log(event) {
     switch (event.type) {
       case "initialize_started":
-        this._logInitializing(event.port, event.projectRoots);
-
-        break;
+        this._logInitializing(event.port, event.hasReducedPerformance);
 
-      case "initialize_done":
-        this.terminal.log("\nMetro Bundler ready.\n");
         break;
 
       case "initialize_failed":
@@ -308,10 +387,6 @@ class TerminalReporter {
 
         break;
 
-      case "dep_graph_loaded":
-        this.terminal.log(`${DEP_GRAPH_MESSAGE}, done.`);
-        break;
-
       case "global_cache_disabled":
         this._logCacheDisabled(event.reason);
 
@@ -334,6 +409,31 @@ class TerminalReporter {
       case "hmr_client_error":
         this._logHmrClientError(event.error);
 
+        break;
+
+      case "client_log":
+        logToConsole.apply(
+          void 0,
+          [this.terminal, event.level].concat(_toConsumableArray(event.data))
+        );
+        break;
+
+      case "dep_graph_loading":
+        const color = event.hasReducedPerformance ? chalk.red : chalk.blue;
+        this.terminal.log(
+          color.bold("                    Welcome to Metro!\n") +
+            chalk.dim("              Fast - Scalable - Integrated\n\n")
+        );
+
+        if (event.hasReducedPerformance) {
+          this.terminal.log(
+            chalk.red(
+              "Metro is operating with reduced performance.\n" +
+                "Please fix the problem above and restart Metro.\n\n"
+            )
+          );
+        }
+
         break;
     }
   }
@@ -355,9 +455,7 @@ class TerminalReporter {
           .sort()
           .map(dupFilePath => `  * \`${dupFilePath}\`\n`)
           .join("");
-
-      this._logBundlingErrorMessage(message);
-
+      reporting.logError(this.terminal, message);
       return;
     }
 
@@ -378,11 +476,7 @@ class TerminalReporter {
       message += "\n" + error.snippet;
     }
 
-    this._logBundlingErrorMessage(message);
-  }
-
-  _logBundlingErrorMessage(message) {
-    reporting.logError(this.terminal, "bundling failed: %s", message);
+    reporting.logError(this.terminal, message);
   }
 
   _logWorkerChunk(origin, chunk) {
@@ -449,9 +543,6 @@ class TerminalReporter {
 
       case "bundle_transform_progressed":
         if (event.totalFileCount === event.transformedFileCount) {
-          /* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses
-           * an error found when Flow v0.99 was deployed. To see the error,
-           * delete this comment and run Flow. */
           this._scheduleUpdateBundleProgress.cancel();
 
           this._updateBundleProgress(event);
@@ -465,24 +556,8 @@ class TerminalReporter {
         this._updateBundleProgress(event);
 
         break;
-
-      case "dep_graph_loading":
-        this._dependencyGraphHasLoaded = false;
-        break;
-
-      case "dep_graph_loaded":
-        this._dependencyGraphHasLoaded = true;
-        break;
     }
   }
-
-  _getDepGraphStatusMessage() {
-    if (!this._dependencyGraphHasLoaded) {
-      return `${DEP_GRAPH_MESSAGE}...`;
-    }
-
-    return null;
-  }
   /**
    * Return a status message that is always consistent with the current state
    * of the application. Having this single function ensures we don't have
@@ -490,16 +565,14 @@ class TerminalReporter {
    */
 
   _getStatusMessage() {
-    return [this._getDepGraphStatusMessage()]
-      .concat(
-        Array.from(this._activeBundles.entries()).map(_ref3 => {
-          let _ref4 = _slicedToArray(_ref3, 2),
-            _ = _ref4[0],
-            progress = _ref4[1];
-
-          return this._getBundleStatusMessage(progress, "in_progress");
-        })
-      )
+    return Array.from(this._activeBundles.entries())
+      .map(_ref3 => {
+        let _ref4 = _slicedToArray(_ref3, 2),
+          _ = _ref4[0],
+          progress = _ref4[1];
+
+        return this._getBundleStatusMessage(progress, "in_progress");
+      })
       .filter(str => str != null)
       .join("\n");
   }
diff --git a/node_modules/metro/src/lib/TerminalReporter.js.flow b/node_modules/metro/src/lib/TerminalReporter.js.flow
index e0e810e..4a5eb08 100644
--- a/node_modules/metro/src/lib/TerminalReporter.js.flow
+++ b/node_modules/metro/src/lib/TerminalReporter.js.flow
@@ -11,12 +11,12 @@
 'use strict';
 
 const chalk = require('chalk');
+const logToConsole = require('./logToConsole');
 const path = require('path');
 const reporting = require('./reporting');
 const throttle = require('lodash.throttle');
 
 const {AmbiguousModuleResolutionError} = require('metro-core');
-const {formatBanner} = require('metro-core');
 
 import type {
   BundleDetails,
@@ -25,21 +25,14 @@ import type {
 } from './reporting';
 import type {Terminal} from 'metro-core';
 
-const DEP_GRAPH_MESSAGE = 'Loading dependency graph';
-const GLOBAL_CACHE_DISABLED_MESSAGE_FORMAT =
-  'The global cache is now disabled because %s';
-
 type BundleProgress = {
   bundleDetails: BundleDetails,
   transformedFileCount: number,
   totalFileCount: number,
   ratio: number,
+  ...
 };
 
-const DARK_BLOCK_CHAR = '\u2593';
-const LIGHT_BLOCK_CHAR = '\u2591';
-const MAX_PROGRESS_BAR_CHAR_WIDTH = 16;
-
 export type TerminalReportableEvent =
   | ReportableEvent
   | {
@@ -47,6 +40,7 @@ export type TerminalReportableEvent =
       type: 'bundle_transform_progressed_throttled',
       transformedFileCount: number,
       totalFileCount: number,
+      ...
     };
 
 type BuildPhase = 'in_progress' | 'done' | 'failed';
@@ -54,8 +48,16 @@ type BuildPhase = 'in_progress' | 'done' | 'failed';
 type SnippetError = ErrnoError & {
   filename?: string,
   snippet?: string,
+  ...
 };
 
+const GLOBAL_CACHE_DISABLED_MESSAGE_FORMAT =
+  'The global cache is now disabled because %s';
+
+const DARK_BLOCK_CHAR = '\u2593';
+const LIGHT_BLOCK_CHAR = '\u2591';
+const MAX_PROGRESS_BAR_CHAR_WIDTH = 16;
+
 /**
  * We try to print useful information to the terminal for interactive builds.
  * This implements the `Reporter` interface from the './reporting' module.
@@ -68,64 +70,69 @@ class TerminalReporter {
    */
   _activeBundles: Map<string, BundleProgress>;
 
-  _dependencyGraphHasLoaded: boolean;
-  _scheduleUpdateBundleProgress: (data: {
-    buildID: string,
-    transformedFileCount: number,
-    totalFileCount: number,
-  }) => void;
+  _scheduleUpdateBundleProgress: {
+    (data: {
+      buildID: string,
+      transformedFileCount: number,
+      totalFileCount: number,
+      ...
+    }): void,
+    cancel(): void,
+  };
 
   +terminal: Terminal;
 
   constructor(terminal: Terminal) {
-    this._dependencyGraphHasLoaded = false;
     this._activeBundles = new Map();
     this._scheduleUpdateBundleProgress = throttle(data => {
       this.update({...data, type: 'bundle_transform_progressed_throttled'});
     }, 100);
-    (this: any).terminal = terminal;
+    this.terminal = terminal;
   }
 
   /**
    * Construct a message that represents the progress of a
    * single bundle build, for example:
    *
-   *     BUNDLE [ios, dev, minified] foo.js  ▓▓▓▓▓░░░░░░░░░░░ 36.6% (4790/7922)
+   *     BUNDLE path/to/bundle.js ▓▓▓▓▓░░░░░░░░░░░ 36.6% (4790/7922)
    */
   _getBundleStatusMessage(
     {
-      bundleDetails: {entryFile, platform, dev, minify, bundleType},
+      bundleDetails: {entryFile, bundleType, runtimeBytecodeVersion},
       transformedFileCount,
       totalFileCount,
       ratio,
     }: BundleProgress,
     phase: BuildPhase,
   ): string {
-    const localPath = path.relative('.', entryFile);
-    const fileName = path.basename(localPath);
-    const dirName = path.dirname(localPath);
-
-    platform = platform ? platform + ', ' : '';
-    const devOrProd = dev ? 'dev' : 'prod';
-    const min = minify ? ', minified' : '';
-    const progress = (100 * ratio).toFixed(1);
-    const currentPhase =
-      phase === 'done' ? ', done.' : phase === 'failed' ? ', failed.' : '';
+    if (runtimeBytecodeVersion) {
+      bundleType = 'bytecodebundle';
+    }
 
+    const localPath = path.relative('.', entryFile);
     const filledBar = Math.floor(ratio * MAX_PROGRESS_BAR_CHAR_WIDTH);
+    const bundleTypeColor =
+      phase === 'done'
+        ? chalk.green
+        : phase === 'failed'
+        ? chalk.red
+        : chalk.yellow;
+    const progress =
+      phase === 'in_progress'
+        ? chalk.green.bgGreen(DARK_BLOCK_CHAR.repeat(filledBar)) +
+          chalk.bgWhite.white(
+            LIGHT_BLOCK_CHAR.repeat(MAX_PROGRESS_BAR_CHAR_WIDTH - filledBar),
+          ) +
+          chalk.bold(` ${(100 * ratio).toFixed(1)}% `) +
+          chalk.dim(`(${transformedFileCount}/${totalFileCount})`)
+        : '';
 
     return (
-      chalk.inverse.green.bold(` ${bundleType.toUpperCase()} `) +
-      chalk.dim(` [${platform}${devOrProd}${min}] ${dirName}/`) +
-      chalk.bold(fileName) +
+      bundleTypeColor.inverse.bold(` ${bundleType.toUpperCase()} `) +
+      chalk.reset.dim(` ${path.dirname(localPath)}/`) +
+      chalk.bold(path.basename(localPath)) +
       ' ' +
-      chalk.green.bgGreen(DARK_BLOCK_CHAR.repeat(filledBar)) +
-      chalk.bgWhite.white(
-        LIGHT_BLOCK_CHAR.repeat(MAX_PROGRESS_BAR_CHAR_WIDTH - filledBar),
-      ) +
-      chalk.bold(` ${progress}% `) +
-      chalk.dim(`(${transformedFileCount}/${totalFileCount})`) +
-      currentPhase +
+      progress +
       '\n'
     );
   }
@@ -174,40 +181,41 @@ class TerminalReporter {
     }
   }
 
-  _logInitializing(port: ?number, projectRoots: $ReadOnlyArray<string>): void {
-    if (port) {
-      this.terminal.log(
-        formatBanner(
-          'Running Metro Bundler on port ' +
-            port +
-            '.\n\n' +
-            'Keep Metro running while developing on any JS projects. Feel ' +
-            'free to close this tab and run your own Metro instance ' +
-            'if you prefer.\n\n' +
-            'https://github.com/facebook/react-native',
-          {
-            paddingTop: 1,
-            paddingBottom: 1,
-          },
-        ) + '\n',
-      );
-    }
-
-    this.terminal.log(
-      'Looking for JS files in\n  ',
-      chalk.dim(projectRoots.join('\n   ')),
-      '\n',
-    );
+  _logInitializing(port: number, hasReducedPerformance: boolean): void {
+    const logo = [
+      '                                                      ',
+      '                        #######                       ',
+      '                   ################                   ',
+      '                #########     #########               ',
+      '            #########             ##########          ',
+      '        #########        ######        #########      ',
+      '       ##########################################     ',
+      '      #####      #####################       #####    ',
+      '      #####          ##############          #####    ',
+      '      #####    ###       ######       ###    #####    ',
+      '      #####    #######            #######    #####    ',
+      '      #####    ###########    ###########    #####    ',
+      '      #####    ##########################    #####    ',
+      '      #####    ##########################    #####    ',
+      '      #####      ######################     ######    ',
+      '       ######        #############        #######     ',
+      '         #########        ####       #########        ',
+      '              #########          #########            ',
+      '                  ######### #########                 ',
+      '                       #########                      ',
+      '                                                      ',
+      '                                                      ',
+    ];
+
+    const color = hasReducedPerformance ? chalk.red : chalk.blue;
+    this.terminal.log(color(logo.join('\n')));
   }
 
   _logInitializingFailed(port: number, error: SnippetError): void {
     if (error.code === 'EADDRINUSE') {
       this.terminal.log(
         chalk.bgRed.bold(' ERROR '),
-        chalk.red(
-          "Metro Bundler can't listen on port",
-          chalk.bold(String(port)),
-        ),
+        chalk.red("Metro can't listen on port", chalk.bold(String(port))),
       );
       this.terminal.log(
         'Most likely another process is already using this port',
@@ -216,7 +224,7 @@ class TerminalReporter {
       this.terminal.log('\n  ', chalk.bold('lsof -i :' + port), '\n');
       this.terminal.log('Then, you can either shut down the other process:');
       this.terminal.log('\n  ', chalk.bold('kill -9 <PID>'), '\n');
-      this.terminal.log('or run Metro Bundler on different port.');
+      this.terminal.log('or run Metro on different port.');
     } else {
       this.terminal.log(chalk.bgRed.bold(' ERROR '), chalk.red(error.message));
       const errorAttributes = JSON.stringify(error);
@@ -234,10 +242,7 @@ class TerminalReporter {
   _log(event: TerminalReportableEvent): void {
     switch (event.type) {
       case 'initialize_started':
-        this._logInitializing(event.port, event.projectRoots);
-        break;
-      case 'initialize_done':
-        this.terminal.log('\nMetro Bundler ready.\n');
+        this._logInitializing(event.port, event.hasReducedPerformance);
         break;
       case 'initialize_failed':
         this._logInitializingFailed(event.port, event.error);
@@ -251,9 +256,6 @@ class TerminalReporter {
       case 'bundling_error':
         this._logBundlingError(event.error);
         break;
-      case 'dep_graph_loaded':
-        this.terminal.log(`${DEP_GRAPH_MESSAGE}, done.`);
-        break;
       case 'global_cache_disabled':
         this._logCacheDisabled(event.reason);
         break;
@@ -268,6 +270,26 @@ class TerminalReporter {
         break;
       case 'hmr_client_error':
         this._logHmrClientError(event.error);
+        break;
+      case 'client_log':
+        logToConsole(this.terminal, event.level, ...event.data);
+        break;
+      case 'dep_graph_loading':
+        const color = event.hasReducedPerformance ? chalk.red : chalk.blue;
+        this.terminal.log(
+          color.bold('                    Welcome to Metro!\n') +
+            chalk.dim('              Fast - Scalable - Integrated\n\n'),
+        );
+
+        if (event.hasReducedPerformance) {
+          this.terminal.log(
+            chalk.red(
+              'Metro is operating with reduced performance.\n' +
+                'Please fix the problem above and restart Metro.\n\n',
+            ),
+          );
+        }
+
         break;
     }
   }
@@ -289,7 +311,7 @@ class TerminalReporter {
           .sort()
           .map(dupFilePath => `  * \`${dupFilePath}\`\n`)
           .join('');
-      this._logBundlingErrorMessage(message);
+      reporting.logError(this.terminal, message);
       return;
     }
 
@@ -310,11 +332,7 @@ class TerminalReporter {
     if (error.snippet != null) {
       message += '\n' + error.snippet;
     }
-    this._logBundlingErrorMessage(message);
-  }
-
-  _logBundlingErrorMessage(message: string): void {
-    reporting.logError(this.terminal, 'bundling failed: %s', message);
+    reporting.logError(this.terminal, message);
   }
 
   _logWorkerChunk(origin: 'stdout' | 'stderr', chunk: string): void {
@@ -340,6 +358,7 @@ class TerminalReporter {
     buildID: string,
     transformedFileCount: number,
     totalFileCount: number,
+    ...
   }): void {
     const currentProgress = this._activeBundles.get(buildID);
     if (currentProgress == null) {
@@ -376,9 +395,6 @@ class TerminalReporter {
         break;
       case 'bundle_transform_progressed':
         if (event.totalFileCount === event.transformedFileCount) {
-          /* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses
-           * an error found when Flow v0.99 was deployed. To see the error,
-           * delete this comment and run Flow. */
           this._scheduleUpdateBundleProgress.cancel();
           this._updateBundleProgress(event);
         } else {
@@ -388,20 +404,7 @@ class TerminalReporter {
       case 'bundle_transform_progressed_throttled':
         this._updateBundleProgress(event);
         break;
-      case 'dep_graph_loading':
-        this._dependencyGraphHasLoaded = false;
-        break;
-      case 'dep_graph_loaded':
-        this._dependencyGraphHasLoaded = true;
-        break;
-    }
-  }
-
-  _getDepGraphStatusMessage(): null | string {
-    if (!this._dependencyGraphHasLoaded) {
-      return `${DEP_GRAPH_MESSAGE}...`;
     }
-    return null;
   }
 
   /**
@@ -410,12 +413,9 @@ class TerminalReporter {
    * different callsites overriding each other status messages.
    */
   _getStatusMessage(): string {
-    return [this._getDepGraphStatusMessage()]
-      .concat(
-        Array.from(this._activeBundles.entries()).map(
-          ([_, progress]: [string, BundleProgress]) =>
-            this._getBundleStatusMessage(progress, 'in_progress'),
-        ),
+    return Array.from(this._activeBundles.entries())
+      .map(([_, progress]: [string, BundleProgress]) =>
+        this._getBundleStatusMessage(progress, 'in_progress'),
       )
       .filter((str: null | string) => str != null)
       .join('\n');
diff --git a/node_modules/metro/src/lib/addParamsToDefineCall.js b/node_modules/metro/src/lib/addParamsToDefineCall.js
deleted file mode 100644
index fb12bf9..0000000
--- a/node_modules/metro/src/lib/addParamsToDefineCall.js
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict
- * @format
- */
-"use strict";
-/**
- * Simple way of adding additional parameters to the end of the define calls.
- *
- * This is used to add extra information to the generaic compiled modules (like
- * the dependencyMap object or the list of inverse dependencies).
- */
-
-function addParamsToDefineCall(code) {
-  const index = code.lastIndexOf(")");
-
-  for (
-    var _len = arguments.length,
-      paramsToAdd = new Array(_len > 1 ? _len - 1 : 0),
-      _key = 1;
-    _key < _len;
-    _key++
-  ) {
-    paramsToAdd[_key - 1] = arguments[_key];
-  }
-
-  const params = paramsToAdd.map(param =>
-    param !== undefined ? JSON.stringify(param) : "undefined"
-  );
-  return code.slice(0, index) + "," + params.join(",") + code.slice(index);
-}
-
-module.exports = addParamsToDefineCall;
diff --git a/node_modules/metro/src/lib/addParamsToDefineCall.js.flow b/node_modules/metro/src/lib/addParamsToDefineCall.js.flow
deleted file mode 100644
index d75f687..0000000
--- a/node_modules/metro/src/lib/addParamsToDefineCall.js.flow
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict
- * @format
- */
-
-'use strict';
-
-/**
- * Simple way of adding additional parameters to the end of the define calls.
- *
- * This is used to add extra information to the generaic compiled modules (like
- * the dependencyMap object or the list of inverse dependencies).
- */
-function addParamsToDefineCall(
-  code: string,
-  ...paramsToAdd: Array<mixed>
-): string {
-  const index = code.lastIndexOf(')');
-  const params = paramsToAdd.map(param =>
-    param !== undefined ? JSON.stringify(param) : 'undefined',
-  );
-
-  return code.slice(0, index) + ',' + params.join(',') + code.slice(index);
-}
-
-module.exports = addParamsToDefineCall;
diff --git a/node_modules/metro/src/lib/attachWebsocketServer.js b/node_modules/metro/src/lib/attachWebsocketServer.js
index 2d9324b..b6b2869 100644
--- a/node_modules/metro/src/lib/attachWebsocketServer.js
+++ b/node_modules/metro/src/lib/attachWebsocketServer.js
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,17 +31,19 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
 }
-
 /**
  * Attach a websocket server to an already existing HTTP[S] server, and forward
  * the received events on the given "websocketServer" parameter. It must be an
@@ -51,6 +54,7 @@ function _asyncToGenerator(fn) {
  *   - onClientMessage
  *   - onClientDisconnect
  */
+
 module.exports = function attachWebsocketServer(_ref) {
   let httpServer = _ref.httpServer,
     websocketServer = _ref.websocketServer,
@@ -64,8 +68,7 @@ module.exports = function attachWebsocketServer(_ref) {
   });
   wss.on(
     "connection",
-    /*#__PURE__*/
-    (function() {
+    /*#__PURE__*/ (function() {
       var _ref2 = _asyncToGenerator(function*(ws) {
         let connected = true;
         const url = ws.upgradeReq.url;
diff --git a/node_modules/metro/src/lib/attachWebsocketServer.js.flow b/node_modules/metro/src/lib/attachWebsocketServer.js.flow
index 8b6bb0f..d26241d 100644
--- a/node_modules/metro/src/lib/attachWebsocketServer.js.flow
+++ b/node_modules/metro/src/lib/attachWebsocketServer.js.flow
@@ -25,12 +25,14 @@ type WebsocketServiceInterface<T> = {
     message: string,
     sendFn: (data: string) => void,
   ) => mixed,
+  ...
 };
 
 type HMROptions<TClient> = {
   httpServer: HttpServer | HttpsServer,
   websocketServer: WebsocketServiceInterface<TClient>,
   path: string,
+  ...
 };
 
 /**
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/BundleNotFoundError.js b/node_modules/metro/src/lib/bundle-modules/DeltaClient/BundleNotFoundError.js
deleted file mode 100644
index 56a4bc3..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/BundleNotFoundError.js
+++ /dev/null
@@ -1,21 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-"use strict";
-
-class BundleNotFoundError extends Error {
-  constructor(bundleKey) {
-    super(
-      `The Delta Client could not find a bundle corresponding to \`${bundleKey}\` in its bundle cache. ` +
-        "Use `deltaClient.registerBundle` to register a new bundle."
-    );
-  }
-}
-
-module.exports = BundleNotFoundError;
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/BundleNotFoundError.js.flow b/node_modules/metro/src/lib/bundle-modules/DeltaClient/BundleNotFoundError.js.flow
deleted file mode 100644
index 6a81d00..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/BundleNotFoundError.js.flow
+++ /dev/null
@@ -1,22 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-'use strict';
-
-class BundleNotFoundError extends Error {
-  constructor(bundleKey: string) {
-    super(
-      `The Delta Client could not find a bundle corresponding to \`${bundleKey}\` in its bundle cache. ` +
-        'Use `deltaClient.registerBundle` to register a new bundle.',
-    );
-  }
-}
-
-module.exports = BundleNotFoundError;
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleDB.js b/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleDB.js
deleted file mode 100644
index 6ab66d5..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleDB.js
+++ /dev/null
@@ -1,170 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-"use strict";
-
-function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
-  try {
-    var info = gen[key](arg);
-    var value = info.value;
-  } catch (error) {
-    reject(error);
-    return;
-  }
-  if (info.done) {
-    resolve(value);
-  } else {
-    Promise.resolve(value).then(_next, _throw);
-  }
-}
-
-function _asyncToGenerator(fn) {
-  return function() {
-    var self = this,
-      args = arguments;
-    return new Promise(function(resolve, reject) {
-      var gen = fn.apply(self, args);
-      function _next(value) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
-      }
-      function _throw(err) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
-      }
-      _next(undefined);
-    });
-  };
-}
-
-const DB_VERSION = 1; // Flow's IndexedDB definitions are unusable.
-// $FlowIssue https://github.com/facebook/flow/issues/3324
-
-function openDB(_x) {
-  return _openDB.apply(this, arguments);
-}
-/**
- * Retrieves bundle metadata from the database.
- */
-
-function _openDB() {
-  _openDB = _asyncToGenerator(function*(dbName) {
-    return yield new Promise((resolve, reject) => {
-      const request = self.indexedDB.open(dbName, DB_VERSION);
-
-      request.onerror = event => {
-        reject(request.error);
-      };
-
-      request.onsuccess = () => {
-        resolve(request.result);
-      };
-
-      request.onupgradeneeded = () => {
-        request.result.createObjectStore("metadata", {
-          keyPath: "revisionId"
-        });
-      };
-    });
-  });
-  return _openDB.apply(this, arguments);
-}
-
-function getBundleMetadata(_x2, _x3) {
-  return _getBundleMetadata.apply(this, arguments);
-}
-/**
- * Stores bundle metadata to the database.
- */
-
-function _getBundleMetadata() {
-  _getBundleMetadata = _asyncToGenerator(function*(db, revisionId) {
-    return yield new Promise((resolve, reject) => {
-      const transaction = db.transaction(["metadata"]);
-
-      transaction.onerror = () => {
-        reject(transaction.error);
-      };
-
-      const objectStore = transaction.objectStore("metadata");
-      const request = objectStore.get(revisionId);
-
-      request.onsuccess = () => {
-        if (request.result != null) {
-          resolve(request.result.metadata);
-        } else {
-          resolve(null);
-        }
-      };
-    });
-  });
-  return _getBundleMetadata.apply(this, arguments);
-}
-
-function setBundleMetadata(_x4, _x5, _x6) {
-  return _setBundleMetadata.apply(this, arguments);
-}
-/**
- * Removes bundle metadata from the database.
- */
-
-function _setBundleMetadata() {
-  _setBundleMetadata = _asyncToGenerator(function*(db, revisionId, metadata) {
-    yield new Promise((resolve, reject) => {
-      const transaction = db.transaction(["metadata"], "readwrite");
-
-      transaction.oncomplete = () => {
-        resolve();
-      };
-
-      transaction.onerror = event => {
-        // transaction.error has yet to be set at this point.
-        reject(event.target.error);
-      };
-
-      const objectStore = transaction.objectStore("metadata");
-      objectStore.add({
-        revisionId,
-        metadata
-      });
-    });
-  });
-  return _setBundleMetadata.apply(this, arguments);
-}
-
-function removeBundleMetadata(_x7, _x8) {
-  return _removeBundleMetadata.apply(this, arguments);
-}
-
-function _removeBundleMetadata() {
-  _removeBundleMetadata = _asyncToGenerator(function*(db, revisionId) {
-    yield new Promise((resolve, reject) => {
-      const transaction = db.transaction(["metadata"], "readwrite");
-
-      transaction.oncomplete = () => {
-        resolve();
-      };
-
-      transaction.onerror = () => {
-        reject(transaction.error);
-      };
-
-      const objectStore = transaction.objectStore("metadata");
-      objectStore.delete(revisionId);
-    });
-  });
-  return _removeBundleMetadata.apply(this, arguments);
-}
-
-module.exports = {
-  openDB,
-  getBundleMetadata,
-  setBundleMetadata,
-  removeBundleMetadata
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleDB.js.flow b/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleDB.js.flow
deleted file mode 100644
index a199a19..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleDB.js.flow
+++ /dev/null
@@ -1,123 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-
-'use strict';
-
-import type {BundleMetadata} from '../types.flow';
-
-const DB_VERSION = 1;
-
-// Flow's IndexedDB definitions are unusable.
-// $FlowIssue https://github.com/facebook/flow/issues/3324
-type IDBFactory = $FlowIssue;
-type IDBDatabase = $FlowIssue;
-
-async function openDB(dbName: string): Promise<IDBDatabase> {
-  return await new Promise(
-    (resolve: (result: IDBDatabase) => void, reject: mixed => void) => {
-      const request = (self.indexedDB: IDBFactory).open(dbName, DB_VERSION);
-
-      request.onerror = event => {
-        reject(request.error);
-      };
-
-      request.onsuccess = () => {
-        resolve(request.result);
-      };
-
-      request.onupgradeneeded = () => {
-        request.result.createObjectStore('metadata', {keyPath: 'revisionId'});
-      };
-    },
-  );
-}
-
-/**
- * Retrieves bundle metadata from the database.
- */
-async function getBundleMetadata(
-  db: IDBDatabase,
-  revisionId: string,
-): Promise<?BundleMetadata> {
-  return await new Promise(
-    (resolve: (result: ?BundleMetadata) => void, reject: mixed => void) => {
-      const transaction = db.transaction(['metadata']);
-      transaction.onerror = () => {
-        reject(transaction.error);
-      };
-
-      const objectStore = transaction.objectStore('metadata');
-      const request = objectStore.get(revisionId);
-      request.onsuccess = () => {
-        if (request.result != null) {
-          resolve(request.result.metadata);
-        } else {
-          resolve(null);
-        }
-      };
-    },
-  );
-}
-
-/**
- * Stores bundle metadata to the database.
- */
-async function setBundleMetadata(
-  db: IDBDatabase,
-  revisionId: string,
-  metadata: BundleMetadata,
-): Promise<void> {
-  await new Promise((resolve: () => void, reject: (error?: mixed) => void) => {
-    const transaction = db.transaction(['metadata'], 'readwrite');
-    transaction.oncomplete = () => {
-      resolve();
-    };
-    transaction.onerror = event => {
-      // transaction.error has yet to be set at this point.
-      reject(event.target.error);
-    };
-
-    const objectStore = transaction.objectStore('metadata');
-    objectStore.add({
-      revisionId,
-      metadata,
-    });
-  });
-}
-
-/**
- * Removes bundle metadata from the database.
- */
-async function removeBundleMetadata(
-  db: IDBDatabase,
-  revisionId: string,
-): Promise<void> {
-  await new Promise((resolve: () => void, reject: (error?: mixed) => void) => {
-    const transaction = db.transaction(['metadata'], 'readwrite');
-    transaction.oncomplete = () => {
-      resolve();
-    };
-    transaction.onerror = () => {
-      reject(transaction.error);
-    };
-
-    const objectStore = transaction.objectStore('metadata');
-    objectStore.delete(revisionId);
-  });
-}
-
-module.exports = {
-  openDB,
-  getBundleMetadata,
-  setBundleMetadata,
-  removeBundleMetadata,
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/dev.js b/node_modules/metro/src/lib/bundle-modules/DeltaClient/dev.js
deleted file mode 100644
index 262ce33..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/dev.js
+++ /dev/null
@@ -1,419 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-"use strict";
-
-function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
-  try {
-    var info = gen[key](arg);
-    var value = info.value;
-  } catch (error) {
-    reject(error);
-    return;
-  }
-  if (info.done) {
-    resolve(value);
-  } else {
-    Promise.resolve(value).then(_next, _throw);
-  }
-}
-
-function _asyncToGenerator(fn) {
-  return function() {
-    var self = this,
-      args = arguments;
-    return new Promise(function(resolve, reject) {
-      var gen = fn.apply(self, args);
-      function _next(value) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
-      }
-      function _throw(err) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
-      }
-      _next(undefined);
-    });
-  };
-}
-
-const BundleNotFoundError = require("./BundleNotFoundError");
-
-const WebSocketHMRClient = require("../WebSocketHMRClient");
-
-const bundleToString = require("./bundleToString");
-
-const patchBundle = require("./patchBundle");
-
-const stringToBundle = require("./stringToBundle");
-
-const _require = require("./bundleDB"),
-  openDB = _require.openDB,
-  getBundleMetadataFromDB = _require.getBundleMetadata,
-  setBundleMetadata = _require.setBundleMetadata,
-  removeBundleMetadata = _require.removeBundleMetadata;
-
-const _require2 = require("./metadata"),
-  fetchBundleMetadata = _require2.fetchBundleMetadata;
-
-const _require3 = require("./response"),
-  createResponse = _require3.createResponse,
-  getRevisionId = _require3.getRevisionId;
-
-class UpdateError extends Error {
-  constructor(bundleUrl, originalError) {
-    super(
-      `Error retrieving an initial update for the bundle \`${bundleUrl}\`.`
-    );
-    this.stack = "Caused by: " + originalError.stack;
-  }
-}
-
-function defaultGetHmrServerUrl(bundleUrl, revisionId) {
-  const url = new URL(bundleUrl);
-  return `${url.protocol === "https:" ? "wss" : "ws"}://${
-    url.host
-  }/hot?revisionId=${revisionId}`;
-}
-
-function defaultOnUpdate(clientId, update) {
-  clients.get(clientId).then(client => {
-    if (client != null) {
-      client.postMessage({
-        type: "METRO_UPDATE",
-        update
-      });
-    }
-  });
-}
-
-function defaultOnUpdateStart(clientId) {
-  clients.get(clientId).then(client => {
-    if (client != null) {
-      client.postMessage({
-        type: "METRO_UPDATE_START"
-      });
-    }
-  });
-}
-
-function defaultOnUpdateError(clientId, error) {
-  clients.get(clientId).then(client => {
-    if (client != null) {
-      client.postMessage({
-        type: "METRO_UPDATE_ERROR",
-        error
-      });
-    }
-  });
-}
-
-const DEFAULT_DB_NAME = "__metroBundleDB";
-const CACHE_VERSION = 1;
-const DEFAULT_CACHE_NAME = "__metroBundleCacheV" + CACHE_VERSION;
-
-function create() {
-  let _ref =
-      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
-    _ref$getHmrServerUrl = _ref.getHmrServerUrl,
-    getHmrServerUrl =
-      _ref$getHmrServerUrl === void 0
-        ? defaultGetHmrServerUrl
-        : _ref$getHmrServerUrl,
-    _ref$getBundleMetadat = _ref.getBundleMetadata,
-    getBundleMetadata =
-      _ref$getBundleMetadat === void 0
-        ? fetchBundleMetadata
-        : _ref$getBundleMetadat,
-    _ref$onUpdateStart = _ref.onUpdateStart,
-    onUpdateStart =
-      _ref$onUpdateStart === void 0 ? defaultOnUpdateStart : _ref$onUpdateStart,
-    _ref$onUpdate = _ref.onUpdate,
-    onUpdate = _ref$onUpdate === void 0 ? defaultOnUpdate : _ref$onUpdate,
-    _ref$onUpdateError = _ref.onUpdateError,
-    onUpdateError =
-      _ref$onUpdateError === void 0 ? defaultOnUpdateError : _ref$onUpdateError,
-    _ref$bundleCacheName = _ref.bundleCacheName,
-    bundleCacheName =
-      _ref$bundleCacheName === void 0
-        ? DEFAULT_CACHE_NAME
-        : _ref$bundleCacheName,
-    _ref$bundleDBName = _ref.bundleDBName,
-    bundleDBName =
-      _ref$bundleDBName === void 0 ? DEFAULT_DB_NAME : _ref$bundleDBName;
-
-  const cachePromise = caches.open(bundleCacheName);
-  const dbPromise = openDB(DEFAULT_DB_NAME);
-  const clients = new Map();
-
-  const setupUpdates =
-    /*#__PURE__*/
-    (function() {
-      var _ref2 = _asyncToGenerator(function*(
-        bundleKey,
-        clientId,
-        prevRevisionId,
-        prevBundleRes,
-        prevBundleMetadataPromise
-      ) {
-        const cache = yield cachePromise;
-        const db = yield dbPromise;
-        let bundleRes = prevBundleRes;
-        let revisionId = prevRevisionId;
-
-        let bundlePromise = _asyncToGenerator(function*() {
-          const stringBundle = yield prevBundleRes.clone().text();
-          const prevBundleMetadata = yield prevBundleMetadataPromise;
-          return stringToBundle(stringBundle, prevBundleMetadata);
-        })();
-
-        let resolveBundleRes;
-        let rejectBundleRes;
-        const client = {
-          ids: new Set([clientId]),
-          bundleResPromise: new Promise((resolve, reject) => {
-            // Note: the arg type will be a Resolve result in service-workers
-            resolveBundleRes = resolve;
-            rejectBundleRes = reject;
-          })
-        };
-        clients.set(bundleKey, client);
-        let resolved = false;
-        const wsClient = new WebSocketHMRClient(
-          getHmrServerUrl(bundleKey, prevRevisionId)
-        );
-        wsClient.on("open", () => {
-          wsClient.send(
-            JSON.stringify({
-              type: "register-entrypoints",
-              entryPoints: [getHmrServerUrl(bundleKey, prevRevisionId)]
-            })
-          );
-        });
-        wsClient.on("connection-error", error => {
-          rejectBundleRes(error);
-        });
-        wsClient.on("close", () => {
-          clients.delete(bundleKey);
-        });
-        wsClient.on("error", error => {
-          if (!resolved) {
-            rejectBundleRes(error);
-            return;
-          }
-
-          client.ids.forEach(clientId => onUpdateError(clientId, error));
-        });
-        wsClient.on("update-start", () => {
-          client.ids.forEach(clientId => onUpdateStart(clientId));
-        });
-        wsClient.on(
-          "update",
-          /*#__PURE__*/
-          (function() {
-            var _ref4 = _asyncToGenerator(function*(update) {
-              if (resolved) {
-                // Only notify clients for later updates.
-                client.ids.forEach(clientId => onUpdate(clientId, update));
-              }
-
-              let nextBundleRes; // type: Response, built-in function for service worker
-
-              if (revisionId === update.revisionId) {
-                nextBundleRes = bundleRes;
-              } else {
-                let bundle;
-
-                try {
-                  bundle = yield bundlePromise;
-                } catch (error) {
-                  // This error should only happen when either the initial bundle or the
-                  // initial bundle metadata are invalid or cannot be retrieved.
-                  rejectBundleRes(error);
-                  return;
-                }
-
-                const nextBundle = patchBundle(bundle, {
-                  added: update.added,
-                  modified: update.modified,
-                  deleted: update.deleted
-                });
-                bundlePromise = Promise.resolve(nextBundle);
-
-                const _bundleToString = bundleToString(nextBundle),
-                  stringBundle = _bundleToString.code,
-                  metadata = _bundleToString.metadata;
-
-                nextBundleRes = createResponse(
-                  stringBundle,
-                  update.revisionId,
-                  new Headers({
-                    // In development, we expect the bundle URL to be static. As such,
-                    // the browser should always request the Service Worker for the
-                    // latest version.
-                    "Cache-Control": "no-cache"
-                  })
-                );
-                cache.put(bundleKey, nextBundleRes.clone());
-                setBundleMetadata(db, update.revisionId, metadata);
-                removeBundleMetadata(db, revisionId);
-                revisionId = update.revisionId;
-              } // We need to clone the response before it can be consumed anywhere else.
-
-              bundleRes = nextBundleRes.clone();
-
-              if (!resolved) {
-                resolved = true;
-                resolveBundleRes(nextBundleRes);
-              } else {
-                client.bundleResPromise = Promise.resolve(nextBundleRes);
-              }
-            });
-
-            return function(_x6) {
-              return _ref4.apply(this, arguments);
-            };
-          })()
-        );
-        return client;
-      });
-
-      return function setupUpdates(_x, _x2, _x3, _x4, _x5) {
-        return _ref2.apply(this, arguments);
-      };
-    })();
-
-  function getOrFetchBundleMetadata(_x7, _x8) {
-    return _getOrFetchBundleMetadata.apply(this, arguments);
-  }
-
-  function _getOrFetchBundleMetadata() {
-    _getOrFetchBundleMetadata = _asyncToGenerator(function*(
-      bundleKey,
-      revisionId
-    ) {
-      const metadata = yield getBundleMetadataFromDB(
-        yield dbPromise,
-        revisionId
-      );
-
-      if (metadata != null) {
-        return metadata;
-      }
-
-      return yield getBundleMetadata(bundleKey, revisionId);
-    });
-    return _getOrFetchBundleMetadata.apply(this, arguments);
-  }
-
-  const getBundle =
-    /*#__PURE__*/
-    (function() {
-      var _ref5 = _asyncToGenerator(function*(bundleKey, clientId) {
-        let client = clients.get(bundleKey);
-
-        if (client != null) {
-          // There's already an update client running for this bundle URL.
-          client.ids.add(clientId);
-        } else {
-          const cache = yield cachePromise;
-          const prevBundleRes = yield cache.match(bundleKey);
-
-          if (prevBundleRes == null) {
-            throw new BundleNotFoundError(bundleKey);
-          }
-
-          const prevRevisionId = getRevisionId(prevBundleRes); // We could expect metadata to always be defined. However, the cache and the
-          // database can be cleared independently, which means that there is a
-          // possibility that the bundle cache was cleared and the database was not
-          // and vice versa.
-
-          const prevBundleMetadataPromise = getOrFetchBundleMetadata(
-            bundleKey,
-            prevRevisionId
-          );
-          client = yield setupUpdates(
-            bundleKey,
-            clientId,
-            prevRevisionId,
-            prevBundleRes,
-            prevBundleMetadataPromise
-          );
-        }
-
-        let bundleRes;
-
-        try {
-          // Whenever we consume a response, we need to clone it so that we can
-          // still use its body for the next request.
-          bundleRes = yield client.bundleResPromise;
-          client.bundleResPromise = Promise.resolve(bundleRes.clone());
-        } catch (error) {
-          throw new UpdateError(bundleKey, error);
-        }
-
-        return bundleRes;
-      });
-
-      return function getBundle(_x9, _x10) {
-        return _ref5.apply(this, arguments);
-      };
-    })();
-
-  const registerBundle =
-    /*#__PURE__*/
-    (function() {
-      var _ref6 = _asyncToGenerator(function*(bundleKey, bundleRes, clientId) {
-        const cache = yield cachePromise; // Since the user might not be aware of Response semantics, we should not
-        // consume the provided response's body, but instead make clones of it.
-
-        const initialRevisionId = getRevisionId(bundleRes);
-        const putPromise = cache.put(bundleKey, bundleRes.clone()); // See the comment regarding getOrFetchBundleMetadata in getBundle.
-
-        const metadataPromise = getOrFetchBundleMetadata(
-          bundleKey,
-          initialRevisionId
-        );
-        yield Promise.all([
-          putPromise,
-          _asyncToGenerator(function*() {
-            const metadata = yield metadataPromise;
-            yield setBundleMetadata(
-              yield dbPromise,
-              initialRevisionId,
-              metadata
-            );
-          })(),
-          setupUpdates(
-            bundleKey,
-            clientId,
-            initialRevisionId,
-            bundleRes.clone(),
-            metadataPromise
-          )
-        ]);
-      });
-
-      return function registerBundle(_x11, _x12, _x13) {
-        return _ref6.apply(this, arguments);
-      };
-    })();
-
-  return {
-    getBundle,
-    registerBundle
-  };
-}
-
-module.exports = {
-  create,
-  BundleNotFoundError,
-  UpdateError,
-  CACHE_VERSION
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/dev.js.flow b/node_modules/metro/src/lib/bundle-modules/DeltaClient/dev.js.flow
deleted file mode 100644
index adcc8c6..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/dev.js.flow
+++ /dev/null
@@ -1,354 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-
-'use strict';
-
-const BundleNotFoundError = require('./BundleNotFoundError');
-const WebSocketHMRClient = require('../WebSocketHMRClient');
-
-const bundleToString = require('./bundleToString');
-const patchBundle = require('./patchBundle');
-const stringToBundle = require('./stringToBundle');
-
-const {
-  openDB,
-  getBundleMetadata: getBundleMetadataFromDB,
-  setBundleMetadata,
-  removeBundleMetadata,
-} = require('./bundleDB');
-const {fetchBundleMetadata} = require('./metadata');
-const {createResponse, getRevisionId} = require('./response');
-
-import type {BundleMetadata, HmrUpdate, FormattedError} from '../types.flow';
-import type {GetBundleMetadata} from './metadata';
-
-export type GetHmrServerUrl = (bundleUrl: string, revisionId: string) => string;
-
-export type DeltaClientOptions = {|
-  +bundleCacheName?: string,
-  +bundleDBName?: string,
-  +getBundleMetadata?: GetBundleMetadata,
-  +getHmrServerUrl?: GetHmrServerUrl,
-  +onUpdateStart?: (clientId: string) => void,
-  +onUpdate?: (clientId: string, update: HmrUpdate) => void,
-  +onUpdateError?: (clientId: string, error: FormattedError) => void,
-|};
-
-export type DeltaClient = {|
-  +getBundle: (bundleKey: string, clientId: string) => Promise<Response>,
-  +registerBundle: (
-    bundleKey: string,
-    bundleRes: Response,
-    clientId: string,
-  ) => Promise<void>,
-|};
-
-export type CreateDeltaClient = (options: DeltaClientOptions) => DeltaClient;
-
-export type HandleOptions = {|
-  +bundleUrl: string,
-  +bundleKey: string,
-  +clientId: string,
-|};
-
-export type Handle = HandleOptions => Promise<Response>;
-
-type UpdateClient = {|bundleResPromise: Promise<Response>, +ids: Set<string>|};
-
-class UpdateError extends Error {
-  constructor(bundleUrl: string, originalError: Error) {
-    super(
-      `Error retrieving an initial update for the bundle \`${bundleUrl}\`.`,
-    );
-    this.stack = 'Caused by: ' + originalError.stack;
-  }
-}
-
-function defaultGetHmrServerUrl(bundleUrl: string, revisionId: string): string {
-  const url = new URL(bundleUrl);
-  return `${url.protocol === 'https:' ? 'wss' : 'ws'}://${
-    url.host
-  }/hot?revisionId=${revisionId}`;
-}
-
-function defaultOnUpdate(clientId: string, update: HmrUpdate): void {
-  clients.get(clientId).then((client: ?Client) => {
-    if (client != null) {
-      client.postMessage({
-        type: 'METRO_UPDATE',
-        update,
-      });
-    }
-  });
-}
-
-function defaultOnUpdateStart(clientId: string): void {
-  clients.get(clientId).then((client: ?Client) => {
-    if (client != null) {
-      client.postMessage({
-        type: 'METRO_UPDATE_START',
-      });
-    }
-  });
-}
-
-function defaultOnUpdateError(clientId: string, error: FormattedError): void {
-  clients.get(clientId).then((client: ?Client) => {
-    if (client != null) {
-      client.postMessage({
-        type: 'METRO_UPDATE_ERROR',
-        error,
-      });
-    }
-  });
-}
-
-const DEFAULT_DB_NAME = '__metroBundleDB';
-const CACHE_VERSION = 1;
-const DEFAULT_CACHE_NAME = '__metroBundleCacheV' + CACHE_VERSION;
-
-function create({
-  getHmrServerUrl = defaultGetHmrServerUrl,
-  getBundleMetadata = fetchBundleMetadata,
-  onUpdateStart = defaultOnUpdateStart,
-  onUpdate = defaultOnUpdate,
-  onUpdateError = defaultOnUpdateError,
-  bundleCacheName = DEFAULT_CACHE_NAME,
-  bundleDBName = DEFAULT_DB_NAME,
-}: DeltaClientOptions = {}): DeltaClient {
-  const cachePromise = caches.open(bundleCacheName);
-  const dbPromise = openDB(DEFAULT_DB_NAME);
-  const clients: Map<string, UpdateClient> = new Map();
-
-  const setupUpdates = async (
-    bundleKey: string,
-    clientId: string,
-    prevRevisionId: string,
-    prevBundleRes: Response,
-    prevBundleMetadataPromise: Promise<BundleMetadata>,
-  ): Promise<UpdateClient> => {
-    const cache = await cachePromise;
-    const db = await dbPromise;
-
-    let bundleRes = prevBundleRes;
-    let revisionId = prevRevisionId;
-    let bundlePromise = (async () => {
-      const stringBundle = await prevBundleRes.clone().text();
-      const prevBundleMetadata = await prevBundleMetadataPromise;
-      return stringToBundle(stringBundle, prevBundleMetadata);
-    })();
-
-    let resolveBundleRes;
-    let rejectBundleRes;
-    const client = {
-      ids: new Set([clientId]),
-      bundleResPromise: new Promise(
-        (resolve, reject: (error: mixed) => void) => {
-          // Note: the arg type will be a Resolve result in service-workers
-          resolveBundleRes = resolve;
-          rejectBundleRes = reject;
-        },
-      ),
-    };
-
-    clients.set(bundleKey, client);
-
-    let resolved = false;
-    const wsClient = new WebSocketHMRClient(
-      getHmrServerUrl(bundleKey, prevRevisionId),
-    );
-
-    wsClient.on('open', () => {
-      wsClient.send(
-        JSON.stringify({
-          type: 'register-entrypoints',
-          entryPoints: [getHmrServerUrl(bundleKey, prevRevisionId)],
-        }),
-      );
-    });
-
-    wsClient.on('connection-error', error => {
-      rejectBundleRes(error);
-    });
-
-    wsClient.on('close', () => {
-      clients.delete(bundleKey);
-    });
-
-    wsClient.on('error', error => {
-      if (!resolved) {
-        rejectBundleRes(error);
-        return;
-      }
-      client.ids.forEach((clientId: string) => onUpdateError(clientId, error));
-    });
-
-    wsClient.on('update-start', () => {
-      client.ids.forEach((clientId: string) => onUpdateStart(clientId));
-    });
-
-    wsClient.on('update', async update => {
-      if (resolved) {
-        // Only notify clients for later updates.
-        client.ids.forEach((clientId: string) => onUpdate(clientId, update));
-      }
-
-      let nextBundleRes; // type: Response, built-in function for service worker
-      if (revisionId === update.revisionId) {
-        nextBundleRes = bundleRes;
-      } else {
-        let bundle;
-        try {
-          bundle = await bundlePromise;
-        } catch (error) {
-          // This error should only happen when either the initial bundle or the
-          // initial bundle metadata are invalid or cannot be retrieved.
-          rejectBundleRes(error);
-          return;
-        }
-        const nextBundle = patchBundle(bundle, {
-          added: update.added,
-          modified: update.modified,
-          deleted: update.deleted,
-        });
-        bundlePromise = Promise.resolve(nextBundle);
-
-        const {code: stringBundle, metadata} = bundleToString(nextBundle);
-        nextBundleRes = createResponse(
-          stringBundle,
-          update.revisionId,
-          new Headers({
-            // In development, we expect the bundle URL to be static. As such,
-            // the browser should always request the Service Worker for the
-            // latest version.
-            'Cache-Control': 'no-cache',
-          }),
-        );
-
-        cache.put(bundleKey, nextBundleRes.clone());
-        setBundleMetadata(db, update.revisionId, metadata);
-        removeBundleMetadata(db, revisionId);
-
-        revisionId = update.revisionId;
-      }
-
-      // We need to clone the response before it can be consumed anywhere else.
-      bundleRes = nextBundleRes.clone();
-
-      if (!resolved) {
-        resolved = true;
-        resolveBundleRes(nextBundleRes);
-      } else {
-        client.bundleResPromise = Promise.resolve(nextBundleRes);
-      }
-    });
-
-    return client;
-  };
-
-  async function getOrFetchBundleMetadata(
-    bundleKey: string,
-    revisionId: string,
-  ): Promise<BundleMetadata> {
-    const metadata = await getBundleMetadataFromDB(await dbPromise, revisionId);
-    if (metadata != null) {
-      return metadata;
-    }
-    return await getBundleMetadata(bundleKey, revisionId);
-  }
-
-  const getBundle = async (bundleKey: string, clientId: string) => {
-    let client = clients.get(bundleKey);
-    if (client != null) {
-      // There's already an update client running for this bundle URL.
-      client.ids.add(clientId);
-    } else {
-      const cache = await cachePromise;
-      const prevBundleRes = await cache.match(bundleKey);
-
-      if (prevBundleRes == null) {
-        throw new BundleNotFoundError(bundleKey);
-      }
-
-      const prevRevisionId = getRevisionId(prevBundleRes);
-      // We could expect metadata to always be defined. However, the cache and the
-      // database can be cleared independently, which means that there is a
-      // possibility that the bundle cache was cleared and the database was not
-      // and vice versa.
-      const prevBundleMetadataPromise = getOrFetchBundleMetadata(
-        bundleKey,
-        prevRevisionId,
-      );
-
-      client = await setupUpdates(
-        bundleKey,
-        clientId,
-        prevRevisionId,
-        prevBundleRes,
-        prevBundleMetadataPromise,
-      );
-    }
-
-    let bundleRes;
-    try {
-      // Whenever we consume a response, we need to clone it so that we can
-      // still use its body for the next request.
-      bundleRes = await client.bundleResPromise;
-      client.bundleResPromise = Promise.resolve(bundleRes.clone());
-    } catch (error) {
-      throw new UpdateError(bundleKey, error);
-    }
-
-    return bundleRes;
-  };
-
-  const registerBundle = async (
-    bundleKey: string,
-    bundleRes,
-    clientId: string,
-  ) => {
-    const cache = await cachePromise;
-    // Since the user might not be aware of Response semantics, we should not
-    // consume the provided response's body, but instead make clones of it.
-    const initialRevisionId = getRevisionId(bundleRes);
-    const putPromise = cache.put(bundleKey, bundleRes.clone());
-    // See the comment regarding getOrFetchBundleMetadata in getBundle.
-    const metadataPromise = getOrFetchBundleMetadata(
-      bundleKey,
-      initialRevisionId,
-    );
-
-    await Promise.all([
-      putPromise,
-      (async () => {
-        const metadata = await metadataPromise;
-        await setBundleMetadata(await dbPromise, initialRevisionId, metadata);
-      })(),
-      setupUpdates(
-        bundleKey,
-        clientId,
-        initialRevisionId,
-        bundleRes.clone(),
-        metadataPromise,
-      ),
-    ]);
-  };
-
-  return {getBundle, registerBundle};
-}
-
-module.exports = {
-  create,
-  BundleNotFoundError,
-  UpdateError,
-  CACHE_VERSION,
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/index.js b/node_modules/metro/src/lib/bundle-modules/DeltaClient/index.js
deleted file mode 100644
index 51a89fa..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/index.js
+++ /dev/null
@@ -1,326 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-"use strict";
-
-function _toConsumableArray(arr) {
-  return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
-  );
-}
-
-function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
-}
-
-function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
-    return Array.from(iter);
-}
-
-function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
-}
-
-function _slicedToArray(arr, i) {
-  return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
-  );
-}
-
-function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
-}
-
-function _iterableToArrayLimit(arr, i) {
-  var _arr = [];
-  var _n = true;
-  var _d = false;
-  var _e = undefined;
-  try {
-    for (
-      var _i = arr[Symbol.iterator](), _s;
-      !(_n = (_s = _i.next()).done);
-      _n = true
-    ) {
-      _arr.push(_s.value);
-      if (i && _arr.length === i) break;
-    }
-  } catch (err) {
-    _d = true;
-    _e = err;
-  } finally {
-    try {
-      if (!_n && _i["return"] != null) _i["return"]();
-    } finally {
-      if (_d) throw _e;
-    }
-  }
-  return _arr;
-}
-
-function _arrayWithHoles(arr) {
-  if (Array.isArray(arr)) return arr;
-}
-
-function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
-  try {
-    var info = gen[key](arg);
-    var value = info.value;
-  } catch (error) {
-    reject(error);
-    return;
-  }
-  if (info.done) {
-    resolve(value);
-  } else {
-    Promise.resolve(value).then(_next, _throw);
-  }
-}
-
-function _asyncToGenerator(fn) {
-  return function() {
-    var self = this,
-      args = arguments;
-    return new Promise(function(resolve, reject) {
-      var gen = fn.apply(self, args);
-      function _next(value) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
-      }
-      function _throw(err) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
-      }
-      _next(undefined);
-    });
-  };
-}
-
-const BundleNotFoundError = require("./BundleNotFoundError");
-
-const bundleToString = require("./bundleToString");
-
-const patchBundle = require("./patchBundle");
-
-const stringToBundle = require("./stringToBundle");
-
-const _require = require("./bundleDB"),
-  openDB = _require.openDB,
-  getBundleMetadataFromDB = _require.getBundleMetadata,
-  setBundleMetadata = _require.setBundleMetadata,
-  removeBundleMetadata = _require.removeBundleMetadata;
-
-const _require2 = require("./metadata"),
-  fetchBundleMetadata = _require2.fetchBundleMetadata;
-
-const _require3 = require("./response"),
-  createResponse = _require3.createResponse,
-  getRevisionId = _require3.getRevisionId;
-
-function defaultGetDeltaBundle(_x, _x2, _x3) {
-  return _defaultGetDeltaBundle.apply(this, arguments);
-}
-
-function _defaultGetDeltaBundle() {
-  _defaultGetDeltaBundle = _asyncToGenerator(function*(
-    bundleUrl,
-    fromRevisionId,
-    toRevisionId
-  ) {
-    const url = new URL(bundleUrl);
-    url.pathname = url.pathname.replace(/\.(bundle|js)$/, ".delta");
-
-    if (fromRevisionId != null) {
-      url.searchParams.append("revisionId", fromRevisionId);
-    }
-
-    const res = yield fetch(url.href, {
-      includeCredentials: true
-    });
-    const json = yield res.json();
-
-    if (res.status != 200 && res.status != 304) {
-      throw new Error(
-        `Error retrieving delta for the bundle \`${bundleUrl}\`: ${
-          json.type
-        }: ${json.message}`
-      );
-    }
-
-    return json;
-  });
-  return _defaultGetDeltaBundle.apply(this, arguments);
-}
-
-const DEFAULT_DB_NAME = "__metroBundleDB";
-const CACHE_VERSION = 1;
-const DEFAULT_CACHE_NAME = "__metroBundleCacheV" + CACHE_VERSION;
-
-function create() {
-  let _ref =
-      arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
-    _ref$getDeltaBundle = _ref.getDeltaBundle,
-    getDeltaBundle =
-      _ref$getDeltaBundle === void 0
-        ? defaultGetDeltaBundle
-        : _ref$getDeltaBundle,
-    _ref$getBundleMetadat = _ref.getBundleMetadata,
-    getBundleMetadata =
-      _ref$getBundleMetadat === void 0
-        ? fetchBundleMetadata
-        : _ref$getBundleMetadat,
-    _ref$bundleCacheName = _ref.bundleCacheName,
-    bundleCacheName =
-      _ref$bundleCacheName === void 0
-        ? DEFAULT_CACHE_NAME
-        : _ref$bundleCacheName,
-    _ref$bundleDBName = _ref.bundleDBName,
-    bundleDBName =
-      _ref$bundleDBName === void 0 ? DEFAULT_DB_NAME : _ref$bundleDBName;
-
-  const cachePromise = caches.open(bundleCacheName);
-  const dbPromise = openDB(DEFAULT_DB_NAME);
-
-  const getBundle =
-    /*#__PURE__*/
-    (function() {
-      var _ref2 = _asyncToGenerator(function*(
-        bundleKey,
-        revisionId,
-        waitUntil
-      ) {
-        const cache = yield cachePromise;
-        const db = yield dbPromise;
-        const prevBundleRes = yield cache.match(bundleKey);
-
-        if (prevBundleRes == null) {
-          throw new BundleNotFoundError(bundleKey);
-        }
-
-        const prevRevisionId = getRevisionId(prevBundleRes);
-
-        if (revisionId === prevRevisionId) {
-          return prevBundleRes;
-        }
-
-        const _ref3 = yield Promise.all([
-            prevBundleRes.text(),
-            _asyncToGenerator(function*() {
-              const metadata = yield getBundleMetadataFromDB(
-                db,
-                prevRevisionId
-              );
-
-              if (metadata != null) {
-                return metadata;
-              }
-
-              return yield getBundleMetadata(bundleKey, prevRevisionId);
-            })(),
-            getDeltaBundle(bundleKey, prevRevisionId, revisionId)
-          ]),
-          _ref4 = _slicedToArray(_ref3, 3),
-          prevStringBundle = _ref4[0],
-          prevBundleMetadata = _ref4[1],
-          delta = _ref4[2];
-
-        const prevBundle = stringToBundle(prevStringBundle, prevBundleMetadata);
-        const bundle = delta.base
-          ? {
-              pre: delta.pre,
-              post: delta.post,
-              modules: delta.modules
-            }
-          : patchBundle(prevBundle, {
-              added: delta.added,
-              modified: delta.modified,
-              deleted: delta.deleted
-            });
-
-        const _bundleToString = bundleToString(bundle),
-          stringBundle = _bundleToString.code,
-          metadata = _bundleToString.metadata;
-
-        const bundleRes = createResponse(
-          stringBundle,
-          revisionId,
-          _toConsumableArray(prevBundleRes.headers).concat([
-            ["Date", new Date().toUTCString()]
-          ])
-        );
-        waitUntil(
-          Promise.all([
-            cache.put(bundleKey, bundleRes.clone()),
-            setBundleMetadata(db, revisionId, metadata),
-            removeBundleMetadata(db, prevRevisionId)
-          ])
-        );
-        return bundleRes;
-      });
-
-      return function getBundle(_x4, _x5, _x6) {
-        return _ref2.apply(this, arguments);
-      };
-    })();
-
-  const registerBundle = (
-    bundleKey,
-    initialRevisionId,
-    initialBundleRes,
-    waitUntil
-  ) => {
-    const res = createResponse(
-      initialBundleRes.clone().body,
-      initialRevisionId,
-      initialBundleRes.headers
-    );
-    waitUntil(
-      Promise.all([
-        _asyncToGenerator(function*() {
-          const cache = yield cachePromise;
-          yield cache.put(bundleKey, res);
-        })(),
-        _asyncToGenerator(function*() {
-          const db = yield dbPromise;
-          const metadata = yield getBundleMetadataFromDB(db, initialRevisionId);
-
-          if (metadata != null) {
-            return;
-          }
-
-          yield setBundleMetadata(
-            db,
-            initialRevisionId,
-            yield getBundleMetadata(bundleKey, initialRevisionId)
-          );
-        })()
-      ])
-    );
-    return res;
-  };
-
-  return {
-    getBundle,
-    registerBundle
-  };
-}
-
-module.exports = {
-  create,
-  BundleNotFoundError,
-  CACHE_VERSION
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/index.js.flow b/node_modules/metro/src/lib/bundle-modules/DeltaClient/index.js.flow
deleted file mode 100644
index 036d981..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/index.js.flow
+++ /dev/null
@@ -1,193 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-
-'use strict';
-
-const BundleNotFoundError = require('./BundleNotFoundError');
-
-const bundleToString = require('./bundleToString');
-const patchBundle = require('./patchBundle');
-const stringToBundle = require('./stringToBundle');
-
-const {
-  openDB,
-  getBundleMetadata: getBundleMetadataFromDB,
-  setBundleMetadata,
-  removeBundleMetadata,
-} = require('./bundleDB');
-const {fetchBundleMetadata} = require('./metadata');
-const {createResponse, getRevisionId} = require('./response');
-
-import type {BundleVariant} from '../types.flow';
-import type {GetBundleMetadata} from './metadata';
-
-export type GetDeltaBundle = (
-  bundleKey: string,
-  fromRevisionId: string,
-  toRevisionId: ?string,
-) => Promise<BundleVariant>;
-
-export type DeltaClientOptions = {|
-  +bundleCacheName?: string,
-  +bundleDBName?: string,
-  +getDeltaBundle: GetDeltaBundle,
-  +getBundleMetadata: GetBundleMetadata,
-|};
-
-export type DeltaClient = {|
-  +getBundle: (
-    bundleKey: string,
-    revisionId: string,
-    waitUntil: <T>(op: Promise<T>) => void,
-  ) => Promise<Response>,
-  +registerBundle: (
-    bundleKey: string,
-    revisionId: string,
-    bundleRes: Response,
-    waitUntil: <T>(op: Promise<T>) => void,
-  ) => Response,
-|};
-
-async function defaultGetDeltaBundle(
-  bundleUrl: string,
-  fromRevisionId: string,
-  toRevisionId: ?string,
-): Promise<BundleVariant> {
-  const url = new URL(bundleUrl);
-  url.pathname = url.pathname.replace(/\.(bundle|js)$/, '.delta');
-  if (fromRevisionId != null) {
-    url.searchParams.append('revisionId', fromRevisionId);
-  }
-  const res = await fetch(url.href, {
-    includeCredentials: true,
-  });
-  const json = await res.json();
-  if (res.status != 200 && res.status != 304) {
-    throw new Error(
-      `Error retrieving delta for the bundle \`${bundleUrl}\`: ${json.type}: ${
-        json.message
-      }`,
-    );
-  }
-  return json;
-}
-
-const DEFAULT_DB_NAME = '__metroBundleDB';
-const CACHE_VERSION = 1;
-const DEFAULT_CACHE_NAME = '__metroBundleCacheV' + CACHE_VERSION;
-
-function create({
-  getDeltaBundle = defaultGetDeltaBundle,
-  getBundleMetadata = fetchBundleMetadata,
-  bundleCacheName = DEFAULT_CACHE_NAME,
-  bundleDBName = DEFAULT_DB_NAME,
-}: DeltaClientOptions = {}): DeltaClient {
-  const cachePromise = caches.open(bundleCacheName);
-  const dbPromise = openDB(DEFAULT_DB_NAME);
-
-  const getBundle = async (
-    bundleKey: string,
-    revisionId: string,
-    waitUntil: <T>(op: Promise<T>) => void,
-  ) => {
-    const cache = await cachePromise;
-    const db = await dbPromise;
-
-    const prevBundleRes = await cache.match(bundleKey);
-
-    if (prevBundleRes == null) {
-      throw new BundleNotFoundError(bundleKey);
-    }
-
-    const prevRevisionId = getRevisionId(prevBundleRes);
-
-    if (revisionId === prevRevisionId) {
-      return prevBundleRes;
-    }
-
-    const [prevStringBundle, prevBundleMetadata, delta] = await Promise.all([
-      prevBundleRes.text(),
-      (async () => {
-        const metadata = await getBundleMetadataFromDB(db, prevRevisionId);
-        if (metadata != null) {
-          return metadata;
-        }
-        return await getBundleMetadata(bundleKey, prevRevisionId);
-      })(),
-      getDeltaBundle(bundleKey, prevRevisionId, revisionId),
-    ]);
-
-    const prevBundle = stringToBundle(prevStringBundle, prevBundleMetadata);
-    const bundle = delta.base
-      ? {pre: delta.pre, post: delta.post, modules: delta.modules}
-      : patchBundle(prevBundle, {
-          added: delta.added,
-          modified: delta.modified,
-          deleted: delta.deleted,
-        });
-    const {code: stringBundle, metadata} = bundleToString(bundle);
-    const bundleRes = createResponse(stringBundle, revisionId, [
-      ...prevBundleRes.headers,
-      ['Date', new Date().toUTCString()],
-    ]);
-
-    waitUntil(
-      Promise.all([
-        cache.put(bundleKey, bundleRes.clone()),
-        setBundleMetadata(db, revisionId, metadata),
-        removeBundleMetadata(db, prevRevisionId),
-      ]),
-    );
-
-    return bundleRes;
-  };
-
-  const registerBundle = (
-    bundleKey: string,
-    initialRevisionId: string,
-    initialBundleRes,
-    waitUntil: <T>(op: Promise<T>) => void,
-  ) => {
-    const res = createResponse(
-      initialBundleRes.clone().body,
-      initialRevisionId,
-      initialBundleRes.headers,
-    );
-
-    waitUntil(
-      Promise.all([
-        (async () => {
-          const cache = await cachePromise;
-          await cache.put(bundleKey, res);
-        })(),
-        (async () => {
-          const db = await dbPromise;
-          const metadata = await getBundleMetadataFromDB(db, initialRevisionId);
-          if (metadata != null) {
-            return;
-          }
-          await setBundleMetadata(
-            db,
-            initialRevisionId,
-            await getBundleMetadata(bundleKey, initialRevisionId),
-          );
-        })(),
-      ]),
-    );
-
-    return res;
-  };
-
-  return {getBundle, registerBundle};
-}
-
-module.exports = {create, BundleNotFoundError, CACHE_VERSION};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/metadata.js b/node_modules/metro/src/lib/bundle-modules/DeltaClient/metadata.js
deleted file mode 100644
index b902cb0..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/metadata.js
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-"use strict";
-
-function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
-  try {
-    var info = gen[key](arg);
-    var value = info.value;
-  } catch (error) {
-    reject(error);
-    return;
-  }
-  if (info.done) {
-    resolve(value);
-  } else {
-    Promise.resolve(value).then(_next, _throw);
-  }
-}
-
-function _asyncToGenerator(fn) {
-  return function() {
-    var self = this,
-      args = arguments;
-    return new Promise(function(resolve, reject) {
-      var gen = fn.apply(self, args);
-      function _next(value) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
-      }
-      function _throw(err) {
-        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
-      }
-      _next(undefined);
-    });
-  };
-}
-
-const fetchBundleMetadata =
-  /*#__PURE__*/
-  (function() {
-    var _ref = _asyncToGenerator(function*(bundleUrl, revisionId) {
-      const url = new URL(bundleUrl);
-      url.pathname = url.pathname.replace(/\.(bundle|js)$/, ".meta");
-      url.searchParams.append("revisionId", revisionId);
-      const res = yield fetch(url.href, {
-        includeCredentials: true
-      });
-      const json = yield res.json();
-
-      if (res.status != 200 && res.status != 304) {
-        throw new Error(
-          `Error retrieving metadata for the bundle \`${bundleUrl}\`: ${
-            json.type
-          }: ${json.message}`
-        );
-      }
-
-      return json;
-    });
-
-    return function fetchBundleMetadata(_x, _x2) {
-      return _ref.apply(this, arguments);
-    };
-  })();
-
-module.exports = {
-  fetchBundleMetadata
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/metadata.js.flow b/node_modules/metro/src/lib/bundle-modules/DeltaClient/metadata.js.flow
deleted file mode 100644
index f5ce22f..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/metadata.js.flow
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-
-'use strict';
-
-import type {BundleMetadata} from '../types.flow';
-
-export type GetBundleMetadata = (
-  bundleUrl: string,
-  revisionId: string,
-) => Promise<BundleMetadata>;
-
-const fetchBundleMetadata: GetBundleMetadata = async (
-  bundleUrl: string,
-  revisionId: string,
-) => {
-  const url = new URL(bundleUrl);
-  url.pathname = url.pathname.replace(/\.(bundle|js)$/, '.meta');
-  url.searchParams.append('revisionId', revisionId);
-  const res = await fetch(url.href, {
-    includeCredentials: true,
-  });
-  const json = await res.json();
-  if (res.status != 200 && res.status != 304) {
-    throw new Error(
-      `Error retrieving metadata for the bundle \`${bundleUrl}\`: ${
-        json.type
-      }: ${json.message}`,
-    );
-  }
-  return json;
-};
-
-module.exports = {
-  fetchBundleMetadata,
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/patchBundle.js b/node_modules/metro/src/lib/bundle-modules/DeltaClient/patchBundle.js
deleted file mode 100644
index 833aaeb..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/patchBundle.js
+++ /dev/null
@@ -1,87 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-"use strict";
-
-function _slicedToArray(arr, i) {
-  return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
-  );
-}
-
-function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
-}
-
-function _iterableToArrayLimit(arr, i) {
-  var _arr = [];
-  var _n = true;
-  var _d = false;
-  var _e = undefined;
-  try {
-    for (
-      var _i = arr[Symbol.iterator](), _s;
-      !(_n = (_s = _i.next()).done);
-      _n = true
-    ) {
-      _arr.push(_s.value);
-      if (i && _arr.length === i) break;
-    }
-  } catch (err) {
-    _d = true;
-    _e = err;
-  } finally {
-    try {
-      if (!_n && _i["return"] != null) _i["return"]();
-    } finally {
-      if (_d) throw _e;
-    }
-  }
-  return _arr;
-}
-
-function _arrayWithHoles(arr) {
-  if (Array.isArray(arr)) return arr;
-}
-
-/**
- * Patches a bundle with a delta.
- */
-function patchBundle(bundle, delta) {
-  const map = new Map(bundle.modules);
-
-  for (const _ref of delta.modified) {
-    var _ref2 = _slicedToArray(_ref, 2);
-
-    const key = _ref2[0];
-    const value = _ref2[1];
-    map.set(key, value);
-  }
-
-  for (const _ref3 of delta.added) {
-    var _ref4 = _slicedToArray(_ref3, 2);
-
-    const key = _ref4[0];
-    const value = _ref4[1];
-    map.set(key, value);
-  }
-
-  for (const key of delta.deleted) {
-    map.delete(key);
-  }
-
-  const modules = Array.from(map.entries());
-  return {
-    pre: bundle.pre,
-    post: bundle.post,
-    modules
-  };
-}
-
-module.exports = patchBundle;
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/patchBundle.js.flow b/node_modules/metro/src/lib/bundle-modules/DeltaClient/patchBundle.js.flow
deleted file mode 100644
index e335412..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/patchBundle.js.flow
+++ /dev/null
@@ -1,42 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-'use strict';
-
-import type {Bundle, DeltaBundle} from '../types.flow';
-
-/**
- * Patches a bundle with a delta.
- */
-function patchBundle(bundle: Bundle, delta: DeltaBundle): Bundle {
-  const map = new Map(bundle.modules);
-
-  for (const [key, value] of delta.modified) {
-    map.set(key, value);
-  }
-
-  for (const [key, value] of delta.added) {
-    map.set(key, value);
-  }
-
-  for (const key of delta.deleted) {
-    map.delete(key);
-  }
-
-  const modules = Array.from(map.entries());
-
-  return {
-    pre: bundle.pre,
-    post: bundle.post,
-    modules,
-  };
-}
-
-module.exports = patchBundle;
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/response.js b/node_modules/metro/src/lib/bundle-modules/DeltaClient/response.js
deleted file mode 100644
index 8550098..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/response.js
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-"use strict";
-
-function _slicedToArray(arr, i) {
-  return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
-  );
-}
-
-function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
-}
-
-function _iterableToArrayLimit(arr, i) {
-  var _arr = [];
-  var _n = true;
-  var _d = false;
-  var _e = undefined;
-  try {
-    for (
-      var _i = arr[Symbol.iterator](), _s;
-      !(_n = (_s = _i.next()).done);
-      _n = true
-    ) {
-      _arr.push(_s.value);
-      if (i && _arr.length === i) break;
-    }
-  } catch (err) {
-    _d = true;
-    _e = err;
-  } finally {
-    try {
-      if (!_n && _i["return"] != null) _i["return"]();
-    } finally {
-      if (_d) throw _e;
-    }
-  }
-  return _arr;
-}
-
-function _arrayWithHoles(arr) {
-  if (Array.isArray(arr)) return arr;
-}
-
-// Note: the type `Response` is a built-in object in a service worker...
-const REVISION_ID_HEADER = "X-Metro-Delta-ID";
-
-function getRevisionId(bundleRes) {
-  const revisionId = bundleRes.headers.get(REVISION_ID_HEADER);
-
-  if (revisionId == null) {
-    if (__DEV__) {
-      throw new Error(
-        `The \`${REVISION_ID_HEADER}\` header should be present on bundle responses from the Metro server.`
-      );
-    } else {
-      // This should never happen since we fully control the cache contents in
-      // the production version of the delta client.
-      throw new Error("The bundle cache is corrupted.");
-    }
-  }
-
-  return revisionId;
-}
-
-function createResponse(contents, revisionId) {
-  let headersEntries =
-    arguments.length > 2 && arguments[2] !== undefined
-      ? arguments[2]
-      : new Map();
-  const headers = new Headers();
-
-  for (const _ref of headersEntries) {
-    var _ref2 = _slicedToArray(_ref, 2);
-
-    const name = _ref2[0];
-    const value = _ref2[1];
-    headers.append(name, value);
-  }
-
-  headers.set(REVISION_ID_HEADER, revisionId);
-  return new Response(contents, {
-    headers
-  });
-}
-
-module.exports = {
-  createResponse,
-  getRevisionId
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/response.js.flow b/node_modules/metro/src/lib/bundle-modules/DeltaClient/response.js.flow
deleted file mode 100644
index 046f30c..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/response.js.flow
+++ /dev/null
@@ -1,52 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-
-'use strict';
-
-declare var __DEV__: boolean;
-
-// Note: the type `Response` is a built-in object in a service worker...
-
-export type GetRevisionId = (bundleUrl: string, bundleRes: Response) => string;
-
-const REVISION_ID_HEADER = 'X-Metro-Delta-ID';
-
-function getRevisionId(bundleRes: Response): string {
-  const revisionId = bundleRes.headers.get(REVISION_ID_HEADER);
-  if (revisionId == null) {
-    if (__DEV__) {
-      throw new Error(
-        `The \`${REVISION_ID_HEADER}\` header should be present on bundle responses from the Metro server.`,
-      );
-    } else {
-      // This should never happen since we fully control the cache contents in
-      // the production version of the delta client.
-      throw new Error('The bundle cache is corrupted.');
-    }
-  }
-  return revisionId;
-}
-
-function createResponse(
-  contents: ?string | ReadableStream,
-  revisionId: string,
-  headersEntries: Iterable<[string, string]> = new Map(),
-): Response {
-  const headers = new Headers();
-  for (const [name, value] of headersEntries) {
-    headers.append(name, value);
-  }
-  headers.set(REVISION_ID_HEADER, revisionId);
-  return new Response(contents, {headers});
-}
-
-module.exports = {createResponse, getRevisionId};
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/stringToBundle.js b/node_modules/metro/src/lib/bundle-modules/DeltaClient/stringToBundle.js
deleted file mode 100644
index 0aa390e..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/stringToBundle.js
+++ /dev/null
@@ -1,97 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-"use strict";
-
-function _slicedToArray(arr, i) {
-  return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
-  );
-}
-
-function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
-}
-
-function _iterableToArrayLimit(arr, i) {
-  var _arr = [];
-  var _n = true;
-  var _d = false;
-  var _e = undefined;
-  try {
-    for (
-      var _i = arr[Symbol.iterator](), _s;
-      !(_n = (_s = _i.next()).done);
-      _n = true
-    ) {
-      _arr.push(_s.value);
-      if (i && _arr.length === i) break;
-    }
-  } catch (err) {
-    _d = true;
-    _e = err;
-  } finally {
-    try {
-      if (!_n && _i["return"] != null) _i["return"]();
-    } finally {
-      if (_d) throw _e;
-    }
-  }
-  return _arr;
-}
-
-function _arrayWithHoles(arr) {
-  if (Array.isArray(arr)) return arr;
-}
-
-function sliceModules(moduleLengths, str, startOffset) {
-  const modules = [];
-  let offset = startOffset;
-
-  for (const _ref of moduleLengths) {
-    var _ref2 = _slicedToArray(_ref, 2);
-
-    const id = _ref2[0];
-    const length = _ref2[1];
-    modules.push([id, str.slice(offset, offset + length)]);
-
-    if (length > 0) {
-      // Modules are separated by a line break, when their code is non-null.
-      offset += length + 1;
-    }
-  }
-
-  return [offset, modules];
-}
-/**
- * Parses a bundle from an embedded delta bundle.
- */
-
-function stringToBundle(str, metadata) {
-  const pre = str.slice(0, metadata.pre);
-
-  const _sliceModules = sliceModules(
-      metadata.modules,
-      str, // There's a line break after the pre segment, when it exists.
-      pre.length > 0 ? pre.length + 1 : 0
-    ),
-    _sliceModules2 = _slicedToArray(_sliceModules, 2),
-    offset = _sliceModules2[0],
-    modules = _sliceModules2[1]; // We technically don't need the bundle post segment length, since it should
-  // normally continue until the end.
-
-  const post = str.slice(offset, offset + metadata.post);
-  return {
-    pre,
-    post,
-    modules
-  };
-}
-
-module.exports = stringToBundle;
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/stringToBundle.js.flow b/node_modules/metro/src/lib/bundle-modules/DeltaClient/stringToBundle.js.flow
deleted file mode 100644
index 95b2694..0000000
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/stringToBundle.js.flow
+++ /dev/null
@@ -1,54 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-'use strict';
-
-import type {Bundle, ModuleMap, BundleMetadata} from '../types.flow';
-
-function sliceModules(
-  moduleLengths: $ReadOnlyArray<[number, number]>,
-  str: string,
-  startOffset: number,
-): [number, ModuleMap] {
-  const modules = [];
-  let offset = startOffset;
-  for (const [id, length] of moduleLengths) {
-    modules.push([id, str.slice(offset, offset + length)]);
-    if (length > 0) {
-      // Modules are separated by a line break, when their code is non-null.
-      offset += length + 1;
-    }
-  }
-  return [offset, modules];
-}
-
-/**
- * Parses a bundle from an embedded delta bundle.
- */
-function stringToBundle(str: string, metadata: BundleMetadata): Bundle {
-  const pre = str.slice(0, metadata.pre);
-  const [offset, modules] = sliceModules(
-    metadata.modules,
-    str,
-    // There's a line break after the pre segment, when it exists.
-    pre.length > 0 ? pre.length + 1 : 0,
-  );
-  // We technically don't need the bundle post segment length, since it should
-  // normally continue until the end.
-  const post = str.slice(offset, offset + metadata.post);
-
-  return {
-    pre,
-    post,
-    modules,
-  };
-}
-
-module.exports = stringToBundle;
diff --git a/node_modules/metro/src/lib/bundle-modules/HMRClient.js b/node_modules/metro/src/lib/bundle-modules/HMRClient.js
deleted file mode 100644
index 54e8c8f..0000000
--- a/node_modules/metro/src/lib/bundle-modules/HMRClient.js
+++ /dev/null
@@ -1,132 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-"use strict";
-
-function _defineProperty(obj, key, value) {
-  if (key in obj) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-  } else {
-    obj[key] = value;
-  }
-  return obj;
-}
-
-const WebSocketHMRClient = require("./WebSocketHMRClient");
-
-const injectUpdate = require("./injectUpdate");
-
-class HMRClient extends WebSocketHMRClient {
-  constructor(url) {
-    super(url);
-
-    _defineProperty(this, "_isEnabled", false);
-
-    _defineProperty(this, "_pendingUpdate", null);
-
-    this.on("update", update => {
-      if (this._isEnabled) {
-        injectUpdate(update);
-      } else if (this._pendingUpdate == null) {
-        this._pendingUpdate = update;
-      } else {
-        this._pendingUpdate = mergeUpdates(this._pendingUpdate, update);
-      }
-    });
-  }
-
-  enable() {
-    this._isEnabled = true;
-    const update = this._pendingUpdate;
-    this._pendingUpdate = null;
-
-    if (update != null) {
-      injectUpdate(update);
-    }
-  }
-
-  disable() {
-    this._isEnabled = false;
-  }
-
-  isEnabled() {
-    return this._isEnabled;
-  }
-
-  hasPendingUpdates() {
-    return this._pendingUpdate != null;
-  }
-}
-
-function mergeUpdates(base, next) {
-  const addedIDs = new Set();
-  const deletedIDs = new Set();
-  const moduleMap = new Map(); // Fill in the temporary maps and sets from both updates in their order.
-
-  applyUpdateLocally(base);
-  applyUpdateLocally(next);
-
-  function applyUpdateLocally(update) {
-    update.deleted.forEach(id => {
-      if (addedIDs.has(id)) {
-        addedIDs.delete(id);
-      } else {
-        deletedIDs.add(id);
-      }
-
-      moduleMap.delete(id);
-    });
-    update.added.forEach(item => {
-      const id = item.module[0];
-
-      if (deletedIDs.has(id)) {
-        deletedIDs.delete(id);
-      } else {
-        addedIDs.add(id);
-      }
-
-      moduleMap.set(id, item);
-    });
-    update.modified.forEach(item => {
-      const id = item.module[0];
-      moduleMap.set(id, item);
-    });
-  } // Now reconstruct a unified update from our in-memory maps and sets.
-  // Applying it should be equivalent to applying both of them individually.
-
-  const result = {
-    isInitialUpdate: next.isInitialUpdate,
-    revisionId: next.revisionId,
-    added: [],
-    modified: [],
-    deleted: []
-  };
-  deletedIDs.forEach(id => {
-    result.deleted.push(id);
-  });
-  moduleMap.forEach((item, id) => {
-    if (deletedIDs.has(id)) {
-      return;
-    }
-
-    if (addedIDs.has(id)) {
-      result.added.push(item);
-    } else {
-      result.modified.push(item);
-    }
-  });
-  return result;
-}
-
-module.exports = HMRClient;
diff --git a/node_modules/metro/src/lib/bundle-modules/HMRClient.js.flow b/node_modules/metro/src/lib/bundle-modules/HMRClient.js.flow
deleted file mode 100644
index 3feb29b..0000000
--- a/node_modules/metro/src/lib/bundle-modules/HMRClient.js.flow
+++ /dev/null
@@ -1,117 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-'use strict';
-
-const WebSocketHMRClient = require('./WebSocketHMRClient');
-
-const injectUpdate = require('./injectUpdate');
-
-import type {HmrUpdate} from './types.flow';
-
-class HMRClient extends WebSocketHMRClient {
-  _isEnabled: boolean = false;
-  _pendingUpdate: HmrUpdate | null = null;
-
-  constructor(url: string) {
-    super(url);
-
-    this.on('update', (update: HmrUpdate) => {
-      if (this._isEnabled) {
-        injectUpdate(update);
-      } else if (this._pendingUpdate == null) {
-        this._pendingUpdate = update;
-      } else {
-        this._pendingUpdate = mergeUpdates(this._pendingUpdate, update);
-      }
-    });
-  }
-
-  enable() {
-    this._isEnabled = true;
-    const update = this._pendingUpdate;
-    this._pendingUpdate = null;
-    if (update != null) {
-      injectUpdate(update);
-    }
-  }
-
-  disable() {
-    this._isEnabled = false;
-  }
-
-  isEnabled() {
-    return this._isEnabled;
-  }
-
-  hasPendingUpdates() {
-    return this._pendingUpdate != null;
-  }
-}
-
-function mergeUpdates(base: HmrUpdate, next: HmrUpdate): HmrUpdate {
-  const addedIDs = new Set();
-  const deletedIDs = new Set();
-  const moduleMap = new Map();
-
-  // Fill in the temporary maps and sets from both updates in their order.
-  applyUpdateLocally(base);
-  applyUpdateLocally(next);
-
-  function applyUpdateLocally(update: HmrUpdate) {
-    update.deleted.forEach(id => {
-      if (addedIDs.has(id)) {
-        addedIDs.delete(id);
-      } else {
-        deletedIDs.add(id);
-      }
-      moduleMap.delete(id);
-    });
-    update.added.forEach(item => {
-      const id = item.module[0];
-      if (deletedIDs.has(id)) {
-        deletedIDs.delete(id);
-      } else {
-        addedIDs.add(id);
-      }
-      moduleMap.set(id, item);
-    });
-    update.modified.forEach(item => {
-      const id = item.module[0];
-      moduleMap.set(id, item);
-    });
-  }
-
-  // Now reconstruct a unified update from our in-memory maps and sets.
-  // Applying it should be equivalent to applying both of them individually.
-  const result = {
-    isInitialUpdate: next.isInitialUpdate,
-    revisionId: next.revisionId,
-    added: [],
-    modified: [],
-    deleted: [],
-  };
-  deletedIDs.forEach(id => {
-    result.deleted.push(id);
-  });
-  moduleMap.forEach((item, id) => {
-    if (deletedIDs.has(id)) {
-      return;
-    }
-
-    if (addedIDs.has(id)) {
-      result.added.push(item);
-    } else {
-      result.modified.push(item);
-    }
-  });
-  return result;
-}
-
-module.exports = HMRClient;
diff --git a/node_modules/metro/src/lib/bundle-modules/WebSocketHMRClient.js b/node_modules/metro/src/lib/bundle-modules/WebSocketHMRClient.js
deleted file mode 100644
index 9fcee05..0000000
--- a/node_modules/metro/src/lib/bundle-modules/WebSocketHMRClient.js
+++ /dev/null
@@ -1,124 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-"use strict";
-
-function _defineProperty(obj, key, value) {
-  if (key in obj) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-  } else {
-    obj[key] = value;
-  }
-  return obj;
-}
-
-const EventEmitter = require("eventemitter3");
-
-/**
- * The Hot Module Reloading Client connects to Metro via WebSocket, to receive
- * updates from it and propagate them to the runtime to reflect the changes.
- */
-class WebSocketHMRClient extends EventEmitter {
-  constructor(url) {
-    super(); // Access the global WebSocket object only after enabling the client,
-    // since some polyfills do the initialization lazily.
-
-    _defineProperty(this, "_queue", []);
-
-    _defineProperty(this, "_state", "opening");
-
-    this._ws = new global.WebSocket(url);
-
-    this._ws.onopen = () => {
-      this._state = "open";
-      this.emit("open");
-
-      this._flushQueue();
-    };
-
-    this._ws.onerror = error => {
-      this.emit("connection-error", error);
-    };
-
-    this._ws.onclose = () => {
-      this._state = "closed";
-      this.emit("close");
-    };
-
-    this._ws.onmessage = message => {
-      const data = JSON.parse(message.data);
-
-      switch (data.type) {
-        case "bundle-registered":
-          this.emit("bundle-registered");
-          break;
-
-        case "update-start":
-          this.emit("update-start", data.body);
-          break;
-
-        case "update":
-          this.emit("update", data.body);
-          break;
-
-        case "update-done":
-          this.emit("update-done");
-          break;
-
-        case "error":
-          this.emit("error", data.body);
-          break;
-
-        default:
-          this.emit("error", {
-            type: "unknown-message",
-            message: data
-          });
-      }
-    };
-  }
-
-  close() {
-    this._ws.close();
-  }
-
-  send(message) {
-    switch (this._state) {
-      case "opening":
-        this._queue.push(message);
-
-        break;
-
-      case "open":
-        this._ws.send(message);
-
-        break;
-
-      case "closed":
-        // Ignore.
-        break;
-
-      default:
-        throw new Error("[WebSocketHMRClient] Unknown state: " + this._state);
-    }
-  }
-
-  _flushQueue() {
-    this._queue.forEach(message => this.send(message));
-
-    this._queue.length = 0;
-  }
-}
-
-module.exports = WebSocketHMRClient;
diff --git a/node_modules/metro/src/lib/bundle-modules/WebSocketHMRClient.js.flow b/node_modules/metro/src/lib/bundle-modules/WebSocketHMRClient.js.flow
deleted file mode 100644
index 6120df5..0000000
--- a/node_modules/metro/src/lib/bundle-modules/WebSocketHMRClient.js.flow
+++ /dev/null
@@ -1,101 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-'use strict';
-
-const EventEmitter = require('eventemitter3');
-
-import type {HmrMessage} from './types.flow';
-
-type SocketState = 'opening' | 'open' | 'closed';
-
-/**
- * The Hot Module Reloading Client connects to Metro via WebSocket, to receive
- * updates from it and propagate them to the runtime to reflect the changes.
- */
-class WebSocketHMRClient extends EventEmitter {
-  _ws: WebSocket;
-  _queue: Array<string> = [];
-  _state: SocketState = 'opening';
-
-  constructor(url: string) {
-    super();
-
-    // Access the global WebSocket object only after enabling the client,
-    // since some polyfills do the initialization lazily.
-    this._ws = new global.WebSocket(url);
-    this._ws.onopen = () => {
-      this._state = 'open';
-      this.emit('open');
-      this._flushQueue();
-    };
-    this._ws.onerror = error => {
-      this.emit('connection-error', error);
-    };
-    this._ws.onclose = () => {
-      this._state = 'closed';
-      this.emit('close');
-    };
-    this._ws.onmessage = message => {
-      const data: HmrMessage = JSON.parse(message.data);
-
-      switch (data.type) {
-        case 'bundle-registered':
-          this.emit('bundle-registered');
-          break;
-
-        case 'update-start':
-          this.emit('update-start', data.body);
-          break;
-
-        case 'update':
-          this.emit('update', data.body);
-          break;
-
-        case 'update-done':
-          this.emit('update-done');
-          break;
-
-        case 'error':
-          this.emit('error', data.body);
-          break;
-
-        default:
-          this.emit('error', {type: 'unknown-message', message: data});
-      }
-    };
-  }
-
-  close(): void {
-    this._ws.close();
-  }
-
-  send(message: string): void {
-    switch (this._state) {
-      case 'opening':
-        this._queue.push(message);
-        break;
-      case 'open':
-        this._ws.send(message);
-        break;
-      case 'closed':
-        // Ignore.
-        break;
-      default:
-        throw new Error('[WebSocketHMRClient] Unknown state: ' + this._state);
-    }
-  }
-
-  _flushQueue(): void {
-    this._queue.forEach(message => this.send(message));
-    this._queue.length = 0;
-  }
-}
-
-module.exports = WebSocketHMRClient;
diff --git a/node_modules/metro/src/lib/bundle-modules/asyncRequire.js b/node_modules/metro/src/lib/bundle-modules/asyncRequire.js
deleted file mode 100644
index ef3a42d..0000000
--- a/node_modules/metro/src/lib/bundle-modules/asyncRequire.js
+++ /dev/null
@@ -1,16 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @format
- *  strict
- */
-"use strict"; // eslint-disable-next-line lint/flow-no-fixme
-
-const dynamicRequire = require;
-
-module.exports = function(moduleID) {
-  return Promise.resolve().then(() => dynamicRequire.importAll(moduleID));
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/asyncRequire.js.flow b/node_modules/metro/src/lib/bundle-modules/asyncRequire.js.flow
deleted file mode 100644
index 655c9d3..0000000
--- a/node_modules/metro/src/lib/bundle-modules/asyncRequire.js.flow
+++ /dev/null
@@ -1,17 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @format
- * @flow strict
- */
-
-'use strict';
-
-// eslint-disable-next-line lint/flow-no-fixme
-const dynamicRequire = (require: $FlowFixMe);
-module.exports = function(moduleID: mixed): Promise<mixed> {
-  return Promise.resolve().then(() => dynamicRequire.importAll(moduleID));
-};
diff --git a/node_modules/metro/src/lib/bundle-modules/deltaClientServiceWorker.js b/node_modules/metro/src/lib/bundle-modules/deltaClientServiceWorker.js
deleted file mode 100644
index 347a87b..0000000
--- a/node_modules/metro/src/lib/bundle-modules/deltaClientServiceWorker.js
+++ /dev/null
@@ -1,34 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-"use strict";
-
-const DeltaClient = require("./DeltaClient/dev");
-
-const deltaClient = DeltaClient.create();
-self.addEventListener("fetch", event => {
-  const bundleUrl = new URL(event.request.url);
-
-  if (/\/(.+?.bundle)$/.test(bundleUrl.pathname)) {
-    event.respondWith(
-      deltaClient.getBundle(event.request.url, event.clientId).catch(error =>
-        fetch(event.request).then(res => {
-          deltaClient.registerBundle(
-            event.request.url,
-            res.clone(),
-            event.clientId
-          );
-          return res;
-        })
-      )
-    );
-  }
-});
diff --git a/node_modules/metro/src/lib/bundle-modules/deltaClientServiceWorker.js.flow b/node_modules/metro/src/lib/bundle-modules/deltaClientServiceWorker.js.flow
deleted file mode 100644
index 295c9ea..0000000
--- a/node_modules/metro/src/lib/bundle-modules/deltaClientServiceWorker.js.flow
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-/* eslint-env worker, serviceworker */
-
-'use strict';
-
-const DeltaClient = require('./DeltaClient/dev');
-
-const deltaClient = DeltaClient.create();
-
-self.addEventListener('fetch', event => {
-  const bundleUrl = new URL(event.request.url);
-  if (/\/(.+?.bundle)$/.test(bundleUrl.pathname)) {
-    event.respondWith(
-      deltaClient.getBundle(event.request.url, event.clientId).catch(error =>
-        fetch(event.request).then(res => {
-          deltaClient.registerBundle(
-            event.request.url,
-            res.clone(),
-            event.clientId,
-          );
-          return res;
-        }),
-      ),
-    );
-  }
-});
diff --git a/node_modules/metro/src/lib/bundle-modules/injectUpdate.js b/node_modules/metro/src/lib/bundle-modules/injectUpdate.js
deleted file mode 100644
index 1c14b5f..0000000
--- a/node_modules/metro/src/lib/bundle-modules/injectUpdate.js
+++ /dev/null
@@ -1,74 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-"use strict";
-
-function _slicedToArray(arr, i) {
-  return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
-  );
-}
-
-function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
-}
-
-function _iterableToArrayLimit(arr, i) {
-  var _arr = [];
-  var _n = true;
-  var _d = false;
-  var _e = undefined;
-  try {
-    for (
-      var _i = arr[Symbol.iterator](), _s;
-      !(_n = (_s = _i.next()).done);
-      _n = true
-    ) {
-      _arr.push(_s.value);
-      if (i && _arr.length === i) break;
-    }
-  } catch (err) {
-    _d = true;
-    _e = err;
-  } finally {
-    try {
-      if (!_n && _i["return"] != null) _i["return"]();
-    } finally {
-      if (_d) throw _e;
-    }
-  }
-  return _arr;
-}
-
-function _arrayWithHoles(arr) {
-  if (Array.isArray(arr)) return arr;
-}
-
-const inject = _ref => {
-  let _ref$module = _slicedToArray(_ref.module, 2),
-    id = _ref$module[0],
-    code = _ref$module[1],
-    sourceURL = _ref.sourceURL;
-
-  // Some engines do not support `sourceURL` as a comment. We expose a
-  // `globalEvalWithSourceUrl` function to handle updates in that case.
-  if (global.globalEvalWithSourceUrl) {
-    global.globalEvalWithSourceUrl(code, sourceURL);
-  } else {
-    // eslint-disable-next-line no-eval
-    eval(code);
-  }
-};
-
-function injectUpdate(update) {
-  update.added.forEach(inject);
-  update.modified.forEach(inject);
-}
-
-module.exports = injectUpdate;
diff --git a/node_modules/metro/src/lib/bundle-modules/injectUpdate.js.flow b/node_modules/metro/src/lib/bundle-modules/injectUpdate.js.flow
deleted file mode 100644
index 9d91d72..0000000
--- a/node_modules/metro/src/lib/bundle-modules/injectUpdate.js.flow
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-'use strict';
-
-import type {HmrUpdate} from './types.flow';
-
-const inject = ({module: [id, code], sourceURL}) => {
-  // Some engines do not support `sourceURL` as a comment. We expose a
-  // `globalEvalWithSourceUrl` function to handle updates in that case.
-  if (global.globalEvalWithSourceUrl) {
-    global.globalEvalWithSourceUrl(code, sourceURL);
-  } else {
-    // eslint-disable-next-line no-eval
-    eval(code);
-  }
-};
-
-function injectUpdate(update: HmrUpdate): void {
-  update.added.forEach(inject);
-  update.modified.forEach(inject);
-}
-
-module.exports = injectUpdate;
diff --git a/node_modules/metro/src/lib/bundle-modules/registerServiceWorker.js b/node_modules/metro/src/lib/bundle-modules/registerServiceWorker.js
deleted file mode 100644
index b8f20fa..0000000
--- a/node_modules/metro/src/lib/bundle-modules/registerServiceWorker.js
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-
-/* eslint-env browser */
-
-/* eslint-disable no-console */
-"use strict";
-
-const injectUpdate = require("./injectUpdate");
-
-function registerServiceWorker(swUrl) {
-  const serviceWorker = navigator.serviceWorker;
-
-  if (!serviceWorker) {
-    if (__DEV__) {
-      console.info("ServiceWorker not supported");
-    }
-
-    return;
-  }
-
-  window.addEventListener("load", function() {
-    const registrationPromise = serviceWorker.register(swUrl);
-
-    if (__DEV__) {
-      registrationPromise.then(
-        registration => {
-          console.info(
-            "ServiceWorker registration successful with scope: ",
-            registration.scope
-          );
-        },
-        error => {
-          console.error("ServiceWorker registration failed: ", error);
-        }
-      );
-      serviceWorker.addEventListener("message", event => {
-        const data = event.data;
-        /* $FlowFixMe(>=0.97.0 site=react_native_fb) This comment suppresses an
-         * error found when Flow v0.97 was deployed. To see the error delete
-         * this comment and run Flow. */
-
-        if (!(data instanceof Object) || typeof data.type !== "string") {
-          return;
-        }
-
-        switch (data.type) {
-          case "METRO_UPDATE_START": {
-            console.info("Metro update started.");
-            break;
-          }
-
-          case "METRO_UPDATE": {
-            /* $FlowFixMe(>=0.97.0 site=react_native_fb) This comment
-             * suppresses an error found when Flow v0.97 was deployed. To see
-             * the error delete this comment and run Flow. */
-            console.info("Injecting metro update:", data.body);
-            /* $FlowFixMe(>=0.97.0 site=react_native_fb) This comment
-             * suppresses an error found when Flow v0.97 was deployed. To see
-             * the error delete this comment and run Flow. */
-
-            injectUpdate(data.body);
-            break;
-          }
-
-          case "METRO_UPDATE_ERROR": {
-            /* $FlowFixMe(>=0.97.0 site=react_native_fb) This comment
-             * suppresses an error found when Flow v0.97 was deployed. To see
-             * the error delete this comment and run Flow. */
-            console.error("Metro update error: ", data.error);
-            break;
-          }
-        }
-      });
-    }
-  });
-}
-
-module.exports = registerServiceWorker;
diff --git a/node_modules/metro/src/lib/bundle-modules/registerServiceWorker.js.flow b/node_modules/metro/src/lib/bundle-modules/registerServiceWorker.js.flow
deleted file mode 100644
index 8b90a91..0000000
--- a/node_modules/metro/src/lib/bundle-modules/registerServiceWorker.js.flow
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-/* eslint-env browser */
-/* eslint-disable no-console */
-
-'use strict';
-
-declare var __DEV__: boolean;
-
-const injectUpdate = require('./injectUpdate');
-
-function registerServiceWorker(swUrl: string): void {
-  const serviceWorker = navigator.serviceWorker;
-
-  if (!serviceWorker) {
-    if (__DEV__) {
-      console.info('ServiceWorker not supported');
-    }
-
-    return;
-  }
-
-  window.addEventListener('load', function() {
-    const registrationPromise = serviceWorker.register(swUrl);
-
-    if (__DEV__) {
-      registrationPromise.then(
-        (registration: ServiceWorkerRegistration) => {
-          console.info(
-            'ServiceWorker registration successful with scope: ',
-            registration.scope,
-          );
-        },
-        error => {
-          console.error('ServiceWorker registration failed: ', error);
-        },
-      );
-
-      serviceWorker.addEventListener('message', (event: MessageEvent) => {
-        const data = event.data;
-
-        /* $FlowFixMe(>=0.97.0 site=react_native_fb) This comment suppresses an
-         * error found when Flow v0.97 was deployed. To see the error delete
-         * this comment and run Flow. */
-        if (!(data instanceof Object) || typeof data.type !== 'string') {
-          return;
-        }
-
-        switch (data.type) {
-          case 'METRO_UPDATE_START': {
-            console.info('Metro update started.');
-            break;
-          }
-          case 'METRO_UPDATE': {
-            /* $FlowFixMe(>=0.97.0 site=react_native_fb) This comment
-             * suppresses an error found when Flow v0.97 was deployed. To see
-             * the error delete this comment and run Flow. */
-            console.info('Injecting metro update:', data.body);
-            /* $FlowFixMe(>=0.97.0 site=react_native_fb) This comment
-             * suppresses an error found when Flow v0.97 was deployed. To see
-             * the error delete this comment and run Flow. */
-            injectUpdate(data.body);
-            break;
-          }
-          case 'METRO_UPDATE_ERROR': {
-            /* $FlowFixMe(>=0.97.0 site=react_native_fb) This comment
-             * suppresses an error found when Flow v0.97 was deployed. To see
-             * the error delete this comment and run Flow. */
-            console.error('Metro update error: ', data.error);
-            break;
-          }
-        }
-      });
-    }
-  });
-}
-
-module.exports = registerServiceWorker;
diff --git a/node_modules/metro/src/lib/bundle-modules/types.flow.js b/node_modules/metro/src/lib/bundle-modules/types.flow.js
deleted file mode 100644
index 7c6bffd..0000000
--- a/node_modules/metro/src/lib/bundle-modules/types.flow.js
+++ /dev/null
@@ -1,10 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-"use strict";
diff --git a/node_modules/metro/src/lib/bundle-modules/types.flow.js.flow b/node_modules/metro/src/lib/bundle-modules/types.flow.js.flow
deleted file mode 100644
index cde8011..0000000
--- a/node_modules/metro/src/lib/bundle-modules/types.flow.js.flow
+++ /dev/null
@@ -1,103 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-'use strict';
-
-export type ModuleMap = $ReadOnlyArray<[number, string]>;
-
-export type Bundle = {|
-  +pre: string,
-  +post: string,
-  +modules: ModuleMap,
-|};
-
-export type DeltaBundle = {|
-  +added: ModuleMap,
-  +modified: ModuleMap,
-  +deleted: $ReadOnlyArray<number>,
-|};
-
-export type BundleVariant =
-  | {|+base: true, +revisionId: string, ...Bundle|}
-  | {|+base: false, +revisionId: string, ...DeltaBundle|};
-
-export type BundleMetadata = {|
-  +pre: number,
-  +post: number,
-  +modules: $ReadOnlyArray<[number, number]>,
-|};
-
-export type FormattedError = {|
-  +type: string,
-  +message: string,
-  +errors: Array<{description: string}>,
-|};
-
-export type HmrModule = {|
-  +module: [number, string],
-  +sourceMappingURL: string,
-  +sourceURL: string,
-|};
-
-export type HmrUpdate = {|
-  +added: $ReadOnlyArray<HmrModule>,
-  +deleted: $ReadOnlyArray<number>,
-  +isInitialUpdate: boolean,
-  +modified: $ReadOnlyArray<HmrModule>,
-  +revisionId: string,
-|};
-
-export type HmrUpdateMessage = {|
-  +type: 'update',
-  +body: HmrUpdate,
-|};
-
-export type HmrErrorMessage = {|
-  +type: 'error',
-  +body: FormattedError,
-|};
-
-export type HmrClientMessage =
-  | {|
-      +type: 'register-entrypoints',
-      +entryPoints: Array<string>,
-    |}
-  | {|
-      +type: 'log',
-      +level:
-        | 'trace'
-        | 'info'
-        | 'warn'
-        | 'log'
-        | 'group'
-        | 'groupCollapsed'
-        | 'groupEnd'
-        | 'debug',
-      +data: Array<mixed>,
-    |}
-  | {|
-      +type: 'log-opt-in',
-    |};
-
-export type HmrMessage =
-  | {|
-      +type: 'bundle-registered',
-    |}
-  | {|
-      +type: 'update-start',
-      +body: {|
-        +isInitialUpdate: boolean,
-      |},
-    |}
-  | {|
-      +type: 'update-done',
-    |}
-  | HmrUpdateMessage
-  | HmrErrorMessage;
diff --git a/node_modules/metro/src/lib/bundleToBytecode.js b/node_modules/metro/src/lib/bundleToBytecode.js
new file mode 100644
index 0000000..63b491c
--- /dev/null
+++ b/node_modules/metro/src/lib/bundleToBytecode.js
@@ -0,0 +1,183 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ *
+ * @format
+ */
+"use strict";
+
+function _slicedToArray(arr, i) {
+  return (
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
+  );
+}
+
+function _nonIterableRest() {
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
+  var _arr = [];
+  var _n = true;
+  var _d = false;
+  var _e = undefined;
+
+  try {
+    for (
+      var _i = arr[Symbol.iterator](), _s;
+      !(_n = (_s = _i.next()).done);
+      _n = true
+    ) {
+      _arr.push(_s.value);
+
+      if (i && _arr.length === i) break;
+    }
+  } catch (err) {
+    _d = true;
+    _e = err;
+  } finally {
+    try {
+      if (!_n && _i["return"] != null) _i["return"]();
+    } finally {
+      if (_d) throw _e;
+    }
+  }
+
+  return _arr;
+}
+
+function _arrayWithHoles(arr) {
+  if (Array.isArray(arr)) return arr;
+}
+
+function _toConsumableArray(arr) {
+  return (
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
+  );
+}
+
+function _nonIterableSpread() {
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _iterableToArray(iter) {
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
+    return Array.from(iter);
+}
+
+function _arrayWithoutHoles(arr) {
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+const _require = require("metro-hermes-compiler"),
+  getFileLength = _require.getFileLength; // The magic number is used as a header for bytecode.
+// It represents a Metro tunnel in binary.
+//
+// 11111111
+// 11100111
+// 11000011
+// 11000011
+
+const MAGIC_NUMBER = 0xffe7c3c3;
+
+function getFileHeader(moduleCount) {
+  const buffer = Buffer.alloc(8);
+  buffer.writeUInt32LE(MAGIC_NUMBER, 0);
+  buffer.writeUInt32LE(moduleCount, 4);
+  return buffer;
+}
+
+function addModuleHeader(buffer) {
+  const fileLength = getFileLength(buffer, 0);
+  const header = Buffer.alloc(4);
+  header.writeUInt32LE(fileLength, 0);
+  return [header, buffer];
+}
+/**
+ * A bytecode bundle has the following format:
+ *
+ * 4 bytes MAGIC_NUMBER
+ * 4 bytes Module count
+ * 4 bytes Module length N + N bytes
+ * ...
+ *
+ */
+
+function bundleToBytecode(bundle) {
+  const buffers = [];
+
+  if (bundle.pre.length) {
+    buffers.push.apply(buffers, _toConsumableArray(bundle.pre));
+  }
+
+  const modules = [];
+  const sortedModules = bundle.modules
+    .slice() // In a JS bundle, the order of modules needs to be deterministic for source
+    // maps to work. This constraint is not necessary for bytecode bundles but
+    // is kept for consistency.
+    .sort((a, b) => a[0] - b[0]);
+
+  for (const _ref of sortedModules) {
+    var _ref2 = _slicedToArray(_ref, 2);
+
+    const id = _ref2[0];
+    const bytecodeBundle = _ref2[1];
+    buffers.push.apply(buffers, _toConsumableArray(bytecodeBundle)); // Use the size of the last item in `bytecodeBundle` which is always
+    // the actual module without headers.
+
+    modules.push([id, bytecodeBundle[bytecodeBundle.length - 1].length]);
+  }
+
+  if (bundle.post.length) {
+    buffers.push.apply(buffers, _toConsumableArray(bundle.post));
+  }
+
+  return {
+    bytecode: Buffer.concat(
+      [getFileHeader(buffers.length)].concat(
+        _toConsumableArray(buffers.flatMap(addModuleHeader))
+      )
+    ),
+    metadata: {
+      pre: bundle.pre ? bundle.pre.length : 0,
+      post: bundle.post.length,
+      modules
+    }
+  };
+}
+
+module.exports = bundleToBytecode;
+module.exports.MAGIC_NUMBER = MAGIC_NUMBER;
diff --git a/node_modules/metro/src/lib/bundleToBytecode.js.flow b/node_modules/metro/src/lib/bundleToBytecode.js.flow
new file mode 100644
index 0000000..2ff7734
--- /dev/null
+++ b/node_modules/metro/src/lib/bundleToBytecode.js.flow
@@ -0,0 +1,95 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow strict-local
+ * @format
+ */
+
+'use strict';
+
+const {getFileLength} = require('metro-hermes-compiler');
+
+import type {
+  BytecodeBundle,
+  BundleMetadata,
+} from 'metro-runtime/src/modules/types.flow';
+
+// The magic number is used as a header for bytecode.
+// It represents a Metro tunnel in binary.
+//
+// 11111111
+// 11100111
+// 11000011
+// 11000011
+const MAGIC_NUMBER = 0xffe7c3c3;
+
+function getFileHeader(moduleCount: number): Buffer {
+  const buffer = Buffer.alloc(8);
+  buffer.writeUInt32LE(MAGIC_NUMBER, 0);
+  buffer.writeUInt32LE(moduleCount, 4);
+  return buffer;
+}
+
+function addModuleHeader(buffer: Buffer): [Buffer, Buffer] {
+  const fileLength = getFileLength(buffer, 0);
+  const header = Buffer.alloc(4);
+  header.writeUInt32LE(fileLength, 0);
+  return [header, buffer];
+}
+
+/**
+ * A bytecode bundle has the following format:
+ *
+ * 4 bytes MAGIC_NUMBER
+ * 4 bytes Module count
+ * 4 bytes Module length N + N bytes
+ * ...
+ *
+ */
+function bundleToBytecode(
+  bundle: BytecodeBundle,
+): {|+bytecode: Buffer, +metadata: BundleMetadata|} {
+  const buffers = [];
+
+  if (bundle.pre.length) {
+    buffers.push(...bundle.pre);
+  }
+
+  const modules = [];
+
+  const sortedModules = bundle.modules
+    .slice()
+    // In a JS bundle, the order of modules needs to be deterministic for source
+    // maps to work. This constraint is not necessary for bytecode bundles but
+    // is kept for consistency.
+    .sort((a, b) => a[0] - b[0]);
+
+  for (const [id, bytecodeBundle] of sortedModules) {
+    buffers.push(...bytecodeBundle);
+    // Use the size of the last item in `bytecodeBundle` which is always
+    // the actual module without headers.
+    modules.push([id, bytecodeBundle[bytecodeBundle.length - 1].length]);
+  }
+
+  if (bundle.post.length) {
+    buffers.push(...bundle.post);
+  }
+
+  return {
+    bytecode: Buffer.concat([
+      getFileHeader(buffers.length),
+      ...buffers.flatMap(addModuleHeader),
+    ]),
+    metadata: {
+      pre: bundle.pre ? bundle.pre.length : 0,
+      post: bundle.post.length,
+      modules,
+    },
+  };
+}
+
+module.exports = bundleToBytecode;
+module.exports.MAGIC_NUMBER = MAGIC_NUMBER;
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleToString.js b/node_modules/metro/src/lib/bundleToString.js
similarity index 63%
rename from node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleToString.js
rename to node_modules/metro/src/lib/bundleToString.js
index 4591e64..6bfd844 100644
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleToString.js
+++ b/node_modules/metro/src/lib/bundleToString.js
@@ -4,26 +4,52 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
 function _slicedToArray(arr, i) {
   return (
-    _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest()
+    _arrayWithHoles(arr) ||
+    _iterableToArrayLimit(arr, i) ||
+    _unsupportedIterableToArray(arr, i) ||
+    _nonIterableRest()
   );
 }
 
 function _nonIterableRest() {
-  throw new TypeError("Invalid attempt to destructure non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function _iterableToArrayLimit(arr, i) {
+  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
+    return;
   var _arr = [];
   var _n = true;
   var _d = false;
   var _e = undefined;
+
   try {
     for (
       var _i = arr[Symbol.iterator](), _s;
@@ -31,6 +57,7 @@ function _iterableToArrayLimit(arr, i) {
       _n = true
     ) {
       _arr.push(_s.value);
+
       if (i && _arr.length === i) break;
     }
   } catch (err) {
@@ -43,16 +70,17 @@ function _iterableToArrayLimit(arr, i) {
       if (_d) throw _e;
     }
   }
+
   return _arr;
 }
 
 function _arrayWithHoles(arr) {
   if (Array.isArray(arr)) return arr;
 }
-
 /**
  * Serializes a bundle into a plain JS bundle.
  */
+
 function bundleToString(bundle) {
   let code = bundle.pre.length > 0 ? bundle.pre + "\n" : "";
   const modules = [];
diff --git a/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleToString.js.flow b/node_modules/metro/src/lib/bundleToString.js.flow
similarity index 92%
rename from node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleToString.js.flow
rename to node_modules/metro/src/lib/bundleToString.js.flow
index c5f4d9c..64c1eba 100644
--- a/node_modules/metro/src/lib/bundle-modules/DeltaClient/bundleToString.js.flow
+++ b/node_modules/metro/src/lib/bundleToString.js.flow
@@ -10,7 +10,10 @@
 
 'use strict';
 
-import type {Bundle, BundleMetadata} from '../types.flow';
+import type {
+  Bundle,
+  BundleMetadata,
+} from 'metro-runtime/src/modules/types.flow';
 
 /**
  * Serializes a bundle into a plain JS bundle.
diff --git a/node_modules/metro/src/lib/countLines.js b/node_modules/metro/src/lib/countLines.js
index 6921cac..724c456 100644
--- a/node_modules/metro/src/lib/countLines.js
+++ b/node_modules/metro/src/lib/countLines.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/lib/createModuleIdFactory.js b/node_modules/metro/src/lib/createModuleIdFactory.js
index 064940c..5db2d45 100644
--- a/node_modules/metro/src/lib/createModuleIdFactory.js
+++ b/node_modules/metro/src/lib/createModuleIdFactory.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/lib/debounceAsyncQueue.js b/node_modules/metro/src/lib/debounceAsyncQueue.js
index 1684d48..b298529 100644
--- a/node_modules/metro/src/lib/debounceAsyncQueue.js
+++ b/node_modules/metro/src/lib/debounceAsyncQueue.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict"; // Debounces calls with the given delay, and queues the next call while the
@@ -18,6 +18,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -31,12 +32,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -80,8 +84,7 @@ function debounceAsyncQueue(fn, delay) {
         }
 
         timeout = setTimeout(
-          /*#__PURE__*/
-          _asyncToGenerator(function*() {
+          /*#__PURE__*/ _asyncToGenerator(function*() {
             waiting = false;
             yield execute();
           }),
diff --git a/node_modules/metro/src/lib/formatBundlingError.js b/node_modules/metro/src/lib/formatBundlingError.js
index 38a7f14..b795da6 100644
--- a/node_modules/metro/src/lib/formatBundlingError.js
+++ b/node_modules/metro/src/lib/formatBundlingError.js
@@ -9,19 +9,26 @@
  */
 "use strict";
 
+const ErrorStackParser = require("error-stack-parser");
+
 const GraphNotFoundError = require("../IncrementalBundler/GraphNotFoundError");
 
 const ResourceNotFoundError = require("../IncrementalBundler/ResourceNotFoundError");
 
 const RevisionNotFoundError = require("../IncrementalBundler/RevisionNotFoundError");
 
+const fs = require("fs");
+
 const serializeError = require("serialize-error");
 
 const _require = require("../node-haste/DependencyGraph/ModuleResolution"),
   UnableToResolveError = _require.UnableToResolveError;
 
-const _require2 = require("metro-core"),
-  AmbiguousModuleResolutionError = _require2.AmbiguousModuleResolutionError;
+const _require2 = require("@babel/code-frame"),
+  codeFrameColumns = _require2.codeFrameColumns;
+
+const _require3 = require("metro-core"),
+  AmbiguousModuleResolutionError = _require3.AmbiguousModuleResolutionError;
 
 function formatBundlingError(error) {
   if (error instanceof AmbiguousModuleResolutionError) {
@@ -78,10 +85,32 @@ function formatBundlingError(error) {
       message: error.message
     };
   } else {
+    const stack = ErrorStackParser.parse(error);
+    const fileName = stack[0].fileName;
+    const column = stack[0].columnNumber;
+    const line = stack[0].lineNumber;
+    let codeFrame = "";
+
+    try {
+      codeFrame = codeFrameColumns(
+        // If the error was thrown in a node.js builtin module, this call will fail and mask the real error.
+        fs.readFileSync(fileName, "utf8"),
+        {
+          start: {
+            column,
+            line
+          }
+        },
+        {
+          forceColor: true
+        }
+      );
+    } catch {}
+
     return {
       type: "InternalError",
       errors: [],
-      message: "Metro Bundler has encountered an error: " + error.message
+      message: `Metro has encountered an error: ${error.message}: ${fileName} (${line}:${column})\n\n${codeFrame}`
     };
   }
 }
diff --git a/node_modules/metro/src/lib/formatBundlingError.js.flow b/node_modules/metro/src/lib/formatBundlingError.js.flow
index bd39af5..0e953a4 100644
--- a/node_modules/metro/src/lib/formatBundlingError.js.flow
+++ b/node_modules/metro/src/lib/formatBundlingError.js.flow
@@ -10,18 +10,21 @@
 
 'use strict';
 
+const ErrorStackParser = require('error-stack-parser');
 const GraphNotFoundError = require('../IncrementalBundler/GraphNotFoundError');
 const ResourceNotFoundError = require('../IncrementalBundler/ResourceNotFoundError');
 const RevisionNotFoundError = require('../IncrementalBundler/RevisionNotFoundError');
 
+const fs = require('fs');
 const serializeError = require('serialize-error');
 
 const {
   UnableToResolveError,
 } = require('../node-haste/DependencyGraph/ModuleResolution');
+const {codeFrameColumns} = require('@babel/code-frame');
 const {AmbiguousModuleResolutionError} = require('metro-core');
 
-import type {FormattedError} from './bundle-modules/types.flow';
+import type {FormattedError} from 'metro-runtime/src/modules/types.flow';
 
 export type CustomError = Error & {
   type?: string,
@@ -31,7 +34,9 @@ export type CustomError = Error & {
     description: string,
     filename: string,
     lineNumber: number,
+    ...
   }>,
+  ...
 };
 
 function formatBundlingError(error: CustomError): FormattedError {
@@ -87,10 +92,27 @@ function formatBundlingError(error: CustomError): FormattedError {
       message: error.message,
     };
   } else {
+    const stack = ErrorStackParser.parse(error);
+    const fileName = stack[0].fileName;
+    const column = stack[0].columnNumber;
+    const line = stack[0].lineNumber;
+
+    let codeFrame = '';
+    try {
+      codeFrame = codeFrameColumns(
+        // If the error was thrown in a node.js builtin module, this call will fail and mask the real error.
+        fs.readFileSync(fileName, 'utf8'),
+        {
+          start: {column, line},
+        },
+        {forceColor: true},
+      );
+    } catch {}
+
     return {
       type: 'InternalError',
       errors: [],
-      message: 'Metro Bundler has encountered an error: ' + error.message,
+      message: `Metro has encountered an error: ${error.message}: ${fileName} (${line}:${column})\n\n${codeFrame}`,
     };
   }
 }
diff --git a/node_modules/metro/src/lib/getAppendScripts.js b/node_modules/metro/src/lib/getAppendScripts.js
index 6fd4d7e..09833e3 100644
--- a/node_modules/metro/src/lib/getAppendScripts.js
+++ b/node_modules/metro/src/lib/getAppendScripts.js
@@ -11,28 +11,44 @@
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 const countLines = require("./countLines");
@@ -52,8 +68,9 @@ function getAppendScripts(entryPoint, modules, importBundleNames, options) {
     const importBundleNamesObject = Object.create(null);
     importBundleNames.forEach(absolutePath => {
       const bundlePath = path.relative(options.projectRoot, absolutePath);
-      importBundleNamesObject[options.createModuleId(absolutePath)] =
-        bundlePath.slice(0, -path.extname(bundlePath).length) + ".bundle";
+      importBundleNamesObject[
+        options.createModuleId(absolutePath)
+      ] = bundlePath.slice(0, -path.extname(bundlePath).length);
     });
     const code = `(function(){var $$=${options.getRunModuleStatement(
       options.createModuleId(options.asyncRequireModulePath)
@@ -79,7 +96,7 @@ function getAppendScripts(entryPoint, modules, importBundleNames, options) {
   }
 
   if (options.runModule) {
-    const paths = _toConsumableArray(options.runBeforeMainModule).concat([
+    const paths = [].concat(_toConsumableArray(options.runBeforeMainModule), [
       entryPoint
     ]);
 
diff --git a/node_modules/metro/src/lib/getAppendScripts.js.flow b/node_modules/metro/src/lib/getAppendScripts.js.flow
index e67429b..23c881f 100644
--- a/node_modules/metro/src/lib/getAppendScripts.js.flow
+++ b/node_modules/metro/src/lib/getAppendScripts.js.flow
@@ -28,6 +28,7 @@ type Options<T: number | string> = {
   +runModule: boolean,
   +sourceMapUrl: ?string,
   +sourceUrl: ?string,
+  ...
 };
 
 function getAppendScripts<T: number | string>(
@@ -42,8 +43,9 @@ function getAppendScripts<T: number | string>(
     const importBundleNamesObject = Object.create(null);
     importBundleNames.forEach(absolutePath => {
       const bundlePath = path.relative(options.projectRoot, absolutePath);
-      importBundleNamesObject[options.createModuleId(absolutePath)] =
-        bundlePath.slice(0, -path.extname(bundlePath).length) + '.bundle';
+      importBundleNamesObject[
+        options.createModuleId(absolutePath)
+      ] = bundlePath.slice(0, -path.extname(bundlePath).length);
     });
     const code = `(function(){var $$=${options.getRunModuleStatement(
       options.createModuleId(options.asyncRequireModulePath),
diff --git a/node_modules/metro/src/lib/getGraphId.js b/node_modules/metro/src/lib/getGraphId.js
index 0870895..8d833ab 100644
--- a/node_modules/metro/src/lib/getGraphId.js
+++ b/node_modules/metro/src/lib/getGraphId.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
@@ -28,9 +28,12 @@ function getGraphId(entryFile, options, _ref) {
         minify: options.minify,
         unstable_disableES6Transforms: options.unstable_disableES6Transforms,
         platform: options.platform != null ? options.platform : null,
+        runtimeBytecodeVersion: options.runtimeBytecodeVersion,
         type: options.type,
         experimentalImportBundleSupport,
-        shallow
+        shallow,
+        unstable_transformProfile:
+          options.unstable_transformProfile || "default"
       }
     },
     canonicalize
diff --git a/node_modules/metro/src/lib/getGraphId.js.flow b/node_modules/metro/src/lib/getGraphId.js.flow
index 0cead24..a178e38 100644
--- a/node_modules/metro/src/lib/getGraphId.js.flow
+++ b/node_modules/metro/src/lib/getGraphId.js.flow
@@ -25,6 +25,7 @@ function getGraphId(
   }: {
     +shallow: boolean,
     +experimentalImportBundleSupport: boolean,
+    ...
   },
 ): GraphId {
   return JSON.stringify(
@@ -41,9 +42,12 @@ function getGraphId(
         minify: options.minify,
         unstable_disableES6Transforms: options.unstable_disableES6Transforms,
         platform: options.platform != null ? options.platform : null,
+        runtimeBytecodeVersion: options.runtimeBytecodeVersion,
         type: options.type,
         experimentalImportBundleSupport,
         shallow,
+        unstable_transformProfile:
+          options.unstable_transformProfile || 'default',
       },
     },
     canonicalize,
diff --git a/node_modules/metro/src/lib/getKeyFromFiles.js b/node_modules/metro/src/lib/getKeyFromFiles.js
deleted file mode 100644
index b0b342e..0000000
--- a/node_modules/metro/src/lib/getKeyFromFiles.js
+++ /dev/null
@@ -1,29 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-const crypto = require("crypto");
-
-const fs = require("fs");
-
-function getKeyFromFile(filePath) {
-  return createHash(fs.readFileSync(filePath));
-}
-
-function createHash(str) {
-  return crypto
-    .createHash("sha1")
-    .update(str)
-    .digest("hex");
-}
-
-module.exports = function getKeyFromFiles(files) {
-  return createHash(files.map(getKeyFromFile).join("$"));
-};
diff --git a/node_modules/metro/src/lib/getKeyFromFiles.js.flow b/node_modules/metro/src/lib/getKeyFromFiles.js.flow
deleted file mode 100644
index f99870a..0000000
--- a/node_modules/metro/src/lib/getKeyFromFiles.js.flow
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-const crypto = require('crypto');
-const fs = require('fs');
-
-function getKeyFromFile(filePath: string): string {
-  return createHash(fs.readFileSync(filePath));
-}
-
-function createHash(str: string | Buffer): string {
-  return crypto
-    .createHash('sha1')
-    .update(str)
-    .digest('hex');
-}
-
-module.exports = function getKeyFromFiles(
-  files: $ReadOnlyArray<string>,
-): string {
-  return createHash(files.map(getKeyFromFile).join('$'));
-};
diff --git a/node_modules/metro/src/lib/getMaxWorkers.js b/node_modules/metro/src/lib/getMaxWorkers.js
index 060f992..ee15f3c 100644
--- a/node_modules/metro/src/lib/getMaxWorkers.js
+++ b/node_modules/metro/src/lib/getMaxWorkers.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/lib/getMaxWorkers.js.flow b/node_modules/metro/src/lib/getMaxWorkers.js.flow
index 0489a6e..96b9936 100644
--- a/node_modules/metro/src/lib/getMaxWorkers.js.flow
+++ b/node_modules/metro/src/lib/getMaxWorkers.js.flow
@@ -12,7 +12,7 @@
 
 const os = require('os');
 
-module.exports = (workers: ?number) => {
+module.exports = (workers: ?number): number => {
   const cores = os.cpus().length;
   return typeof workers === 'number' && Number.isInteger(workers)
     ? Math.min(cores, workers > 0 ? workers : 1)
diff --git a/node_modules/metro/src/lib/getMinifier.js b/node_modules/metro/src/lib/getMinifier.js
deleted file mode 100644
index 9f0cd82..0000000
--- a/node_modules/metro/src/lib/getMinifier.js
+++ /dev/null
@@ -1,29 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict-local
- * @format
- */
-"use strict";
-
-function getMinifier(minifierPath) {
-  // Note: minifierPath should be an absolute path OR a module name here!
-  // The options allow relative paths but they HAVE to be normalized at
-  // any entry point that accepts them...
-  try {
-    // $FlowFixMe TODO t0 cannot do require with literal
-    return require(minifierPath);
-  } catch (e) {
-    throw new Error(
-      'A problem occurred while trying to fetch the minifier. Path: "' +
-        minifierPath +
-        '", error message: ' +
-        e.message
-    );
-  }
-}
-
-module.exports = getMinifier;
diff --git a/node_modules/metro/src/lib/getMinifier.js.flow b/node_modules/metro/src/lib/getMinifier.js.flow
deleted file mode 100644
index 2094e1a..0000000
--- a/node_modules/metro/src/lib/getMinifier.js.flow
+++ /dev/null
@@ -1,32 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict-local
- * @format
- */
-
-'use strict';
-
-import type {MetroMinifier} from '../shared/types.flow.js';
-
-function getMinifier(minifierPath: string): MetroMinifier {
-  // Note: minifierPath should be an absolute path OR a module name here!
-  // The options allow relative paths but they HAVE to be normalized at
-  // any entry point that accepts them...
-  try {
-    // $FlowFixMe TODO t0 cannot do require with literal
-    return require(minifierPath);
-  } catch (e) {
-    throw new Error(
-      'A problem occurred while trying to fetch the minifier. Path: "' +
-        minifierPath +
-        '", error message: ' +
-        e.message,
-    );
-  }
-}
-
-module.exports = getMinifier;
diff --git a/node_modules/metro/src/lib/getPreludeCode.js b/node_modules/metro/src/lib/getPreludeCode.js
index 57e008e..7ce2500 100644
--- a/node_modules/metro/src/lib/getPreludeCode.js
+++ b/node_modules/metro/src/lib/getPreludeCode.js
@@ -4,45 +4,63 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 function getPreludeCode(_ref) {
   let extraVars = _ref.extraVars,
-    isDev = _ref.isDev;
+    isDev = _ref.isDev,
+    globalPrefix = _ref.globalPrefix;
   const vars = [
     "__BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now()",
     `__DEV__=${String(isDev)}`
   ].concat(_toConsumableArray(formatExtraVars(extraVars)), [
-    "process=this.process||{}"
+    "process=this.process||{}",
+    `__METRO_GLOBAL_PREFIX__='${globalPrefix}'`
   ]);
   return `var ${vars.join(",")};${processEnv(
     isDev ? "development" : "production"
diff --git a/node_modules/metro/src/lib/getPreludeCode.js.flow b/node_modules/metro/src/lib/getPreludeCode.js.flow
index 9ca0ed1..a59ddbf 100644
--- a/node_modules/metro/src/lib/getPreludeCode.js.flow
+++ b/node_modules/metro/src/lib/getPreludeCode.js.flow
@@ -13,15 +13,18 @@
 function getPreludeCode({
   extraVars,
   isDev,
+  globalPrefix,
 }: {|
-  +extraVars?: {[string]: mixed},
+  +extraVars?: {[string]: mixed, ...},
   +isDev: boolean,
+  +globalPrefix: string,
 |}): string {
   const vars = [
     '__BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now()',
     `__DEV__=${String(isDev)}`,
     ...formatExtraVars(extraVars),
     'process=this.process||{}',
+    `__METRO_GLOBAL_PREFIX__='${globalPrefix}'`,
   ];
   return `var ${vars.join(',')};${processEnv(
     isDev ? 'development' : 'production',
@@ -30,7 +33,7 @@ function getPreludeCode({
 
 const excluded = new Set(['__BUNDLE_START_TIME__', '__DEV__', 'process']);
 
-function formatExtraVars(extraVars: ?{[string]: mixed}): Array<string> {
+function formatExtraVars(extraVars: ?{[string]: mixed, ...}): Array<string> {
   const assignments = [];
 
   for (const key in extraVars) {
diff --git a/node_modules/metro/src/lib/getPrependedScripts.js b/node_modules/metro/src/lib/getPrependedScripts.js
index 771c7b7..ad525e1 100644
--- a/node_modules/metro/src/lib/getPrependedScripts.js
+++ b/node_modules/metro/src/lib/getPrependedScripts.js
@@ -4,52 +4,89 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
   }
+
+  return keys;
 }
 
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -64,6 +101,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -75,6 +113,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -88,12 +127,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -107,6 +149,9 @@ const getPreludeCode = require("./getPreludeCode");
 
 const transformHelpers = require("./transformHelpers");
 
+const _require = require("metro-hermes-compiler"),
+  compile = _require.compile;
+
 function getPrependedScripts(_x, _x2, _x3, _x4) {
   return _getPrependedScripts.apply(this, arguments);
 }
@@ -126,11 +171,15 @@ function _getPrependedScripts() {
       })
       .concat(config.serializer.polyfillModuleNames);
 
-    const transformOptions = _objectSpread({}, options, {
-      type: "script"
-    });
+    const transformOptions = _objectSpread(
+      _objectSpread({}, options),
+      {},
+      {
+        type: "script"
+      }
+    );
 
-    const graph = yield deltaBundler.buildGraph(
+    const dependencies = yield deltaBundler.getDependencies(
       [defaults.moduleSystem].concat(_toConsumableArray(polyfillModuleNames)),
       {
         resolve: yield transformHelpers.getResolveDependencyFn(
@@ -154,17 +203,20 @@ function _getPrependedScripts() {
     );
     return [
       _getPrelude({
-        dev: options.dev
+        dev: options.dev,
+        globalPrefix: config.transformer.globalPrefix
       })
-    ].concat(_toConsumableArray(graph.dependencies.values()));
+    ].concat(_toConsumableArray(dependencies.values()));
   });
   return _getPrependedScripts.apply(this, arguments);
 }
 
 function _getPrelude(_ref) {
-  let dev = _ref.dev;
+  let dev = _ref.dev,
+    globalPrefix = _ref.globalPrefix;
   const code = getPreludeCode({
-    isDev: dev
+    isDev: dev,
+    globalPrefix
   });
   const name = "__prelude__";
   return {
@@ -180,6 +232,14 @@ function _getPrelude(_ref) {
           lineCount: countLines(code),
           map: []
         }
+      },
+      {
+        type: "bytecode/script/virtual",
+        data: {
+          bytecode: compile(code, {
+            sourceURL: "__prelude__.virtual.js"
+          }).bytecode
+        }
       }
     ]
   };
diff --git a/node_modules/metro/src/lib/getPrependedScripts.js.flow b/node_modules/metro/src/lib/getPrependedScripts.js.flow
index 78c167e..07a27af 100644
--- a/node_modules/metro/src/lib/getPrependedScripts.js.flow
+++ b/node_modules/metro/src/lib/getPrependedScripts.js.flow
@@ -15,6 +15,8 @@ const defaults = require('metro-config/src/defaults/defaults');
 const getPreludeCode = require('./getPreludeCode');
 const transformHelpers = require('./transformHelpers');
 
+const {compile} = require('metro-hermes-compiler');
+
 import type Bundler from '../Bundler';
 import type DeltaBundler, {Module} from '../DeltaBundler';
 import type {TransformInputOptions} from '../lib/transformHelpers';
@@ -24,7 +26,7 @@ async function getPrependedScripts(
   config: ConfigT,
   options: $Diff<
     TransformInputOptions,
-    {type: $PropertyType<TransformInputOptions, 'type'>},
+    {type: $PropertyType<TransformInputOptions, 'type'>, ...},
   >,
   bundler: Bundler,
   deltaBundler: DeltaBundler<>,
@@ -42,7 +44,7 @@ async function getPrependedScripts(
     type: 'script',
   };
 
-  const graph = await deltaBundler.buildGraph(
+  const dependencies = await deltaBundler.getDependencies(
     [defaults.moduleSystem, ...polyfillModuleNames],
     {
       resolve: await transformHelpers.getResolveDependencyFn(
@@ -63,11 +65,24 @@ async function getPrependedScripts(
     },
   );
 
-  return [_getPrelude({dev: options.dev}), ...graph.dependencies.values()];
+  return [
+    _getPrelude({
+      dev: options.dev,
+      globalPrefix: config.transformer.globalPrefix,
+    }),
+    ...dependencies.values(),
+  ];
 }
 
-function _getPrelude({dev}: {dev: boolean}): Module<> {
-  const code = getPreludeCode({isDev: dev});
+function _getPrelude({
+  dev,
+  globalPrefix,
+}: {
+  dev: boolean,
+  globalPrefix: string,
+  ...
+}): Module<> {
+  const code = getPreludeCode({isDev: dev, globalPrefix});
   const name = '__prelude__';
 
   return {
@@ -84,6 +99,13 @@ function _getPrelude({dev}: {dev: boolean}): Module<> {
           map: [],
         },
       },
+      {
+        type: 'bytecode/script/virtual',
+        data: {
+          bytecode: compile(code, {sourceURL: '__prelude__.virtual.js'})
+            .bytecode,
+        },
+      },
     ],
   };
 }
diff --git a/node_modules/metro/src/lib/logToConsole.js b/node_modules/metro/src/lib/logToConsole.js
index 93eed8e..cd40861 100644
--- a/node_modules/metro/src/lib/logToConsole.js
+++ b/node_modules/metro/src/lib/logToConsole.js
@@ -5,46 +5,25 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
+ *
  */
 
 /* eslint-disable no-console */
 "use strict";
 
-function _toConsumableArray(arr) {
-  return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
-  );
-}
-
-function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
-}
-
-function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
-    return Array.from(iter);
-}
-
-function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
-}
-
 const chalk = require("chalk");
 
 const groupStack = [];
 let collapsedGuardTimer;
 
-module.exports = (level, data) => {
+module.exports = function(terminal, level) {
   const logFunction = console[level] && level !== "trace" ? level : "log";
   const color =
-    level === "error" ? "red" : level === "warn" ? "yellow" : "white";
+    level === "error"
+      ? chalk.inverse.red
+      : level === "warn"
+      ? chalk.inverse.yellow
+      : chalk.inverse.white;
 
   if (level === "group") {
     groupStack.push(level);
@@ -54,7 +33,7 @@ module.exports = (level, data) => {
 
     collapsedGuardTimer = setTimeout(() => {
       if (groupStack.includes("groupCollapsed")) {
-        console.warn(
+        terminal.log(
           chalk.inverse.yellow.bold(" WARN "),
           "Expected `console.groupEnd` to be called after `console.groupCollapsed`."
         );
@@ -73,13 +52,28 @@ module.exports = (level, data) => {
   }
 
   if (!groupStack.includes("groupCollapsed")) {
-    var _console;
+    for (
+      var _len = arguments.length,
+        data = new Array(_len > 2 ? _len - 2 : 0),
+        _key = 2;
+      _key < _len;
+      _key++
+    ) {
+      data[_key - 2] = arguments[_key];
+    } // Remove excess whitespace at the end of a log message, if possible.
+
+    const lastItem = data[data.length - 1];
+
+    if (typeof lastItem === "string") {
+      data[data.length - 1] = lastItem.trimEnd();
+    }
 
-    (_console = console)[logFunction].apply(
-      _console,
-      [chalk.inverse[color].bold(` ${logFunction.toUpperCase()} `)].concat(
-        _toConsumableArray(data)
-      )
+    terminal.log.apply(
+      terminal,
+      [
+        color.bold(` ${logFunction.toUpperCase()} `) +
+          "".padEnd(groupStack.length * 2, " ")
+      ].concat(data)
     );
   }
 };
diff --git a/node_modules/metro/src/lib/logToConsole.js.flow b/node_modules/metro/src/lib/logToConsole.js.flow
new file mode 100644
index 0000000..2a754af
--- /dev/null
+++ b/node_modules/metro/src/lib/logToConsole.js.flow
@@ -0,0 +1,67 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @format
+ * @flow
+ */
+
+/* eslint-disable no-console */
+
+'use strict';
+
+const chalk = require('chalk');
+
+import type {Terminal} from 'metro-core';
+
+const groupStack = [];
+let collapsedGuardTimer;
+
+module.exports = (terminal: Terminal, level: string, ...data: Array<mixed>) => {
+  const logFunction = console[level] && level !== 'trace' ? level : 'log';
+  const color =
+    level === 'error'
+      ? chalk.inverse.red
+      : level === 'warn'
+      ? chalk.inverse.yellow
+      : chalk.inverse.white;
+
+  if (level === 'group') {
+    groupStack.push(level);
+  } else if (level === 'groupCollapsed') {
+    groupStack.push(level);
+    clearTimeout(collapsedGuardTimer);
+    // Inform users that logs get swallowed if they forget to call `groupEnd`.
+    collapsedGuardTimer = setTimeout(() => {
+      if (groupStack.includes('groupCollapsed')) {
+        terminal.log(
+          chalk.inverse.yellow.bold(' WARN '),
+          'Expected `console.groupEnd` to be called after `console.groupCollapsed`.',
+        );
+        groupStack.length = 0;
+      }
+    }, 3000);
+    return;
+  } else if (level === 'groupEnd') {
+    groupStack.pop();
+    if (!groupStack.length) {
+      clearTimeout(collapsedGuardTimer);
+    }
+    return;
+  }
+
+  if (!groupStack.includes('groupCollapsed')) {
+    // Remove excess whitespace at the end of a log message, if possible.
+    const lastItem = data[data.length - 1];
+    if (typeof lastItem === 'string') {
+      data[data.length - 1] = lastItem.trimEnd();
+    }
+    terminal.log(
+      color.bold(` ${logFunction.toUpperCase()} `) +
+        ''.padEnd(groupStack.length * 2, ' '),
+      ...data,
+    );
+  }
+};
diff --git a/node_modules/metro/src/lib/parseCustomTransformOptions.js b/node_modules/metro/src/lib/parseCustomTransformOptions.js
index 5edb281..f48e36b 100644
--- a/node_modules/metro/src/lib/parseCustomTransformOptions.js
+++ b/node_modules/metro/src/lib/parseCustomTransformOptions.js
@@ -6,7 +6,7 @@
  *
  * @emails oncall+metro_bundler
  * @format
- *  strict-local
+ *
  */
 "use strict";
 
diff --git a/node_modules/metro/src/lib/parseCustomTransformOptions.js.flow b/node_modules/metro/src/lib/parseCustomTransformOptions.js.flow
index 2816fc0..0f3a661 100644
--- a/node_modules/metro/src/lib/parseCustomTransformOptions.js.flow
+++ b/node_modules/metro/src/lib/parseCustomTransformOptions.js.flow
@@ -13,12 +13,13 @@
 
 const nullthrows = require('nullthrows');
 
-import type {CustomTransformOptions} from '../JSTransformer/worker';
+import type {CustomTransformOptions} from 'metro-transform-worker';
 
 const PREFIX = 'transform.';
 
 module.exports = function parseCustomTransformOptions(urlObj: {
-  query?: {[string]: string},
+  +query?: {[string]: string, ...},
+  ...
 }): CustomTransformOptions {
   const customTransformOptions = Object.create(null);
   const query = nullthrows(urlObj.query);
diff --git a/node_modules/metro/src/lib/parseOptionsFromUrl.js b/node_modules/metro/src/lib/parseOptionsFromUrl.js
index 89f8ef9..5ec4197 100644
--- a/node_modules/metro/src/lib/parseOptionsFromUrl.js
+++ b/node_modules/metro/src/lib/parseOptionsFromUrl.js
@@ -4,26 +4,47 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,6 +59,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -51,20 +73,29 @@ const path = require("path");
 
 const url = require("url");
 
-const _require = require("../IncrementalBundler"),
-  revisionIdFromString = _require.revisionIdFromString;
-
-const getBoolean = (query, opt, defaultVal) =>
-  query[opt] == null ? defaultVal : query[opt] === "true" || query[opt] === "1";
+const getBoolean = (query, opt, defaultValue) =>
+  query[opt] == null
+    ? defaultValue
+    : query[opt] === "true" || query[opt] === "1";
 
-const getBundleType = bundleName => {
-  const bundleType = path.extname(bundleName).substr(1);
-  return bundleType === "delta" || bundleType === "map" || bundleType === "meta"
-    ? bundleType
-    : "bundle";
+const getNumber = (query, opt, defaultValue) => {
+  const number = parseInt(query[opt], 10);
+  return Number.isNaN(number) ? defaultValue : number;
 };
 
-module.exports = function parseOptionsFromUrl(requestUrl, platforms) {
+const getBundleType = bundleType =>
+  bundleType === "map" ? bundleType : "bundle";
+
+const getTransformProfile = transformProfile =>
+  transformProfile === "hermes-stable" || transformProfile === "hermes-canary"
+    ? transformProfile
+    : "default";
+
+module.exports = function parseOptionsFromUrl(
+  requestUrl,
+  platforms,
+  bytecodeVersion
+) {
   const parsedURL = nullthrows(url.parse(requestUrl, true)); // `true` to parse the query param as an object.
 
   const query = nullthrows(parsedURL.query);
@@ -73,25 +104,33 @@ module.exports = function parseOptionsFromUrl(requestUrl, platforms) {
     (parsedURL.pathname != null ? decodeURIComponent(parsedURL.pathname) : "");
   const platform =
     query.platform || parsePlatformFilePath(pathname, platforms).platform;
-  const revisionId = query.revisionId || query.deltaBundleId || null;
+  const bundleType = getBundleType(path.extname(pathname).substr(1));
+  const runtimeBytecodeVersion = getNumber(
+    query,
+    "runtimeBytecodeVersion",
+    null
+  );
   return {
-    revisionId: revisionId != null ? revisionIdFromString(revisionId) : null,
-    options: {
-      bundleType: getBundleType(pathname),
-      customTransformOptions: parseCustomTransformOptions(parsedURL),
-      dev: getBoolean(query, "dev", true),
-      entryFile: pathname.replace(/^(?:\.?\/)?/, "./").replace(/\.[^/.]+$/, ""),
-      excludeSource: getBoolean(query, "excludeSource", false),
-      hot: true,
-      inlineSourceMap: getBoolean(query, "inlineSourceMap", false),
-      minify: getBoolean(query, "minify", false),
-      modulesOnly: getBoolean(query, "modulesOnly", false),
-      onProgress: null,
-      platform,
-      runModule: getBoolean(query, "runModule", true),
-      shallow: getBoolean(query, "shallow", false),
-      sourceMapUrl: url.format(
-        _objectSpread({}, parsedURL, {
+    bundleType,
+    runtimeBytecodeVersion:
+      bytecodeVersion === runtimeBytecodeVersion ? bytecodeVersion : null,
+    customTransformOptions: parseCustomTransformOptions(parsedURL),
+    dev: getBoolean(query, "dev", true),
+    entryFile: pathname.replace(/^(?:\.?\/)?/, "./").replace(/\.[^/.]+$/, ""),
+    excludeSource: getBoolean(query, "excludeSource", false),
+    hot: true,
+    inlineSourceMap: getBoolean(query, "inlineSourceMap", false),
+    minify: getBoolean(query, "minify", false),
+    modulesOnly: getBoolean(query, "modulesOnly", false),
+    onProgress: null,
+    platform,
+    runModule: getBoolean(query, "runModule", true),
+    shallow: getBoolean(query, "shallow", false),
+    sourceMapUrl: url.format(
+      _objectSpread(
+        _objectSpread({}, parsedURL),
+        {},
+        {
           // The Chrome Debugger loads bundles via Blob urls, whose
           // protocol is blob:http. This breaks loading source maps through
           // protocol-relative URLs, which is why we must force the HTTP protocol
@@ -99,9 +138,12 @@ module.exports = function parseOptionsFromUrl(requestUrl, platforms) {
           protocol:
             platform != null && platform.match(/^(android|ios)$/) ? "http" : "",
           pathname: pathname.replace(/\.(bundle|delta)$/, ".map")
-        })
-      ),
-      sourceUrl: requestUrl
-    }
+        }
+      )
+    ),
+    sourceUrl: requestUrl,
+    unstable_transformProfile: getTransformProfile(
+      query.unstable_transformProfile
+    )
   };
 };
diff --git a/node_modules/metro/src/lib/parseOptionsFromUrl.js.flow b/node_modules/metro/src/lib/parseOptionsFromUrl.js.flow
index efa3ed8..f9466f6 100644
--- a/node_modules/metro/src/lib/parseOptionsFromUrl.js.flow
+++ b/node_modules/metro/src/lib/parseOptionsFromUrl.js.flow
@@ -16,25 +16,31 @@ const parsePlatformFilePath = require('../node-haste/lib/parsePlatformFilePath')
 const path = require('path');
 const url = require('url');
 
-const {revisionIdFromString} = require('../IncrementalBundler');
-
-import type {RevisionId} from '../IncrementalBundler';
 import type {BundleOptions} from '../shared/types.flow';
 
-const getBoolean = (query, opt, defaultVal) =>
-  query[opt] == null ? defaultVal : query[opt] === 'true' || query[opt] === '1';
+const getBoolean = (query, opt, defaultValue) =>
+  query[opt] == null
+    ? defaultValue
+    : query[opt] === 'true' || query[opt] === '1';
 
-const getBundleType = bundleName => {
-  const bundleType = path.extname(bundleName).substr(1);
-  return bundleType === 'delta' || bundleType === 'map' || bundleType === 'meta'
-    ? bundleType
-    : 'bundle';
+const getNumber = (query, opt, defaultValue) => {
+  const number = parseInt(query[opt], 10);
+  return Number.isNaN(number) ? defaultValue : number;
 };
 
+const getBundleType = bundleType =>
+  bundleType === 'map' ? bundleType : 'bundle';
+
+const getTransformProfile = transformProfile =>
+  transformProfile === 'hermes-stable' || transformProfile === 'hermes-canary'
+    ? transformProfile
+    : 'default';
+
 module.exports = function parseOptionsFromUrl(
   requestUrl: string,
   platforms: Set<string>,
-): {|options: BundleOptions, revisionId: ?RevisionId|} {
+  bytecodeVersion: number,
+): BundleOptions {
   const parsedURL = nullthrows(url.parse(requestUrl, true)); // `true` to parse the query param as an object.
   const query = nullthrows(parsedURL.query);
   const pathname =
@@ -42,34 +48,42 @@ module.exports = function parseOptionsFromUrl(
     (parsedURL.pathname != null ? decodeURIComponent(parsedURL.pathname) : '');
   const platform =
     query.platform || parsePlatformFilePath(pathname, platforms).platform;
-  const revisionId = query.revisionId || query.deltaBundleId || null;
+  const bundleType = getBundleType(path.extname(pathname).substr(1));
+  const runtimeBytecodeVersion = getNumber(
+    query,
+    'runtimeBytecodeVersion',
+    null,
+  );
+
   return {
-    revisionId: revisionId != null ? revisionIdFromString(revisionId) : null,
-    options: {
-      bundleType: getBundleType(pathname),
-      customTransformOptions: parseCustomTransformOptions(parsedURL),
-      dev: getBoolean(query, 'dev', true),
-      entryFile: pathname.replace(/^(?:\.?\/)?/, './').replace(/\.[^/.]+$/, ''),
-      excludeSource: getBoolean(query, 'excludeSource', false),
-      hot: true,
-      inlineSourceMap: getBoolean(query, 'inlineSourceMap', false),
-      minify: getBoolean(query, 'minify', false),
-      modulesOnly: getBoolean(query, 'modulesOnly', false),
-      onProgress: null,
-      platform,
-      runModule: getBoolean(query, 'runModule', true),
-      shallow: getBoolean(query, 'shallow', false),
-      sourceMapUrl: url.format({
-        ...parsedURL,
-        // The Chrome Debugger loads bundles via Blob urls, whose
-        // protocol is blob:http. This breaks loading source maps through
-        // protocol-relative URLs, which is why we must force the HTTP protocol
-        // when loading the bundle for either Android or iOS.
-        protocol:
-          platform != null && platform.match(/^(android|ios)$/) ? 'http' : '',
-        pathname: pathname.replace(/\.(bundle|delta)$/, '.map'),
-      }),
-      sourceUrl: requestUrl,
-    },
+    bundleType,
+    runtimeBytecodeVersion:
+      bytecodeVersion === runtimeBytecodeVersion ? bytecodeVersion : null,
+    customTransformOptions: parseCustomTransformOptions(parsedURL),
+    dev: getBoolean(query, 'dev', true),
+    entryFile: pathname.replace(/^(?:\.?\/)?/, './').replace(/\.[^/.]+$/, ''),
+    excludeSource: getBoolean(query, 'excludeSource', false),
+    hot: true,
+    inlineSourceMap: getBoolean(query, 'inlineSourceMap', false),
+    minify: getBoolean(query, 'minify', false),
+    modulesOnly: getBoolean(query, 'modulesOnly', false),
+    onProgress: null,
+    platform,
+    runModule: getBoolean(query, 'runModule', true),
+    shallow: getBoolean(query, 'shallow', false),
+    sourceMapUrl: url.format({
+      ...parsedURL,
+      // The Chrome Debugger loads bundles via Blob urls, whose
+      // protocol is blob:http. This breaks loading source maps through
+      // protocol-relative URLs, which is why we must force the HTTP protocol
+      // when loading the bundle for either Android or iOS.
+      protocol:
+        platform != null && platform.match(/^(android|ios)$/) ? 'http' : '',
+      pathname: pathname.replace(/\.(bundle|delta)$/, '.map'),
+    }),
+    sourceUrl: requestUrl,
+    unstable_transformProfile: getTransformProfile(
+      query.unstable_transformProfile,
+    ),
   };
 };
diff --git a/node_modules/metro/src/lib/polyfills/require.js b/node_modules/metro/src/lib/polyfills/require.js
deleted file mode 100644
index 301725c..0000000
--- a/node_modules/metro/src/lib/polyfills/require.js
+++ /dev/null
@@ -1,819 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @polyfill
- *
- * @format
- */
-"use strict";
-/* eslint-disable no-bitwise */
-
-global.__r = metroRequire;
-global.__d = define;
-global.__c = clear;
-global.__registerSegment = registerSegment;
-var modules = clear(); // Don't use a Symbol here, it would pull in an extra polyfill with all sorts of
-// additional stuff (e.g. Array.from).
-
-const EMPTY = {};
-const _ref = {},
-  hasOwnProperty = _ref.hasOwnProperty;
-
-if (__DEV__) {
-  global.$RefreshReg$ = () => {};
-
-  global.$RefreshSig$ = () => type => type;
-}
-
-function clear() {
-  modules = Object.create(null); // We return modules here so that we can assign an initial value to modules
-  // when defining it. Otherwise, we would have to do "let modules = null",
-  // which will force us to add "nullthrows" everywhere.
-
-  return modules;
-}
-
-if (__DEV__) {
-  var verboseNamesToModuleIds = Object.create(null);
-  var initializingModuleIds = [];
-}
-
-function define(factory, moduleId, dependencyMap) {
-  if (modules[moduleId] != null) {
-    if (__DEV__) {
-      // (We take `inverseDependencies` from `arguments` to avoid an unused
-      // named parameter in `define` in production.
-      const inverseDependencies = arguments[4]; // If the module has already been defined and the define method has been
-      // called with inverseDependencies, we can hot reload it.
-
-      if (inverseDependencies) {
-        global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
-      }
-    } // prevent repeated calls to `global.nativeRequire` to overwrite modules
-    // that are already loaded
-
-    return;
-  }
-
-  const mod = {
-    dependencyMap,
-    factory,
-    hasError: false,
-    importedAll: EMPTY,
-    importedDefault: EMPTY,
-    isInitialized: false,
-    publicModule: {
-      exports: {}
-    }
-  };
-  modules[moduleId] = mod;
-
-  if (__DEV__) {
-    // HMR
-    mod.hot = createHotReloadingObject(); // DEBUGGABLE MODULES NAMES
-    // we take `verboseName` from `arguments` to avoid an unused named parameter
-    // in `define` in production.
-
-    const verboseName = arguments[3];
-
-    if (verboseName) {
-      mod.verboseName = verboseName;
-      verboseNamesToModuleIds[verboseName] = moduleId;
-    }
-  }
-}
-
-function metroRequire(moduleId) {
-  if (__DEV__ && typeof moduleId === "string") {
-    const verboseName = moduleId;
-    moduleId = verboseNamesToModuleIds[verboseName];
-
-    if (moduleId == null) {
-      throw new Error(`Unknown named module: "${verboseName}"`);
-    } else {
-      console.warn(
-        `Requiring module "${verboseName}" by name is only supported for ` +
-          "debugging purposes and will BREAK IN PRODUCTION!"
-      );
-    }
-  } //$FlowFixMe: at this point we know that moduleId is a number
-
-  const moduleIdReallyIsNumber = moduleId;
-
-  if (__DEV__) {
-    const initializingIndex = initializingModuleIds.indexOf(
-      moduleIdReallyIsNumber
-    );
-
-    if (initializingIndex !== -1) {
-      const cycle = initializingModuleIds
-        .slice(initializingIndex)
-        .map(id => (modules[id] ? modules[id].verboseName : "[unknown]")); // We want to show A -> B -> A:
-
-      cycle.push(cycle[0]);
-      console.warn(
-        `Require cycle: ${cycle.join(" -> ")}\n\n` +
-          "Require cycles are allowed, but can result in uninitialized values. " +
-          "Consider refactoring to remove the need for a cycle."
-      );
-    }
-  }
-
-  const module = modules[moduleIdReallyIsNumber];
-  return module && module.isInitialized
-    ? module.publicModule.exports
-    : guardedLoadModule(moduleIdReallyIsNumber, module);
-}
-
-function metroImportDefault(moduleId) {
-  if (__DEV__ && typeof moduleId === "string") {
-    const verboseName = moduleId;
-    moduleId = verboseNamesToModuleIds[verboseName];
-  } //$FlowFixMe: at this point we know that moduleId is a number
-
-  const moduleIdReallyIsNumber = moduleId;
-
-  if (
-    modules[moduleIdReallyIsNumber] &&
-    modules[moduleIdReallyIsNumber].importedDefault !== EMPTY
-  ) {
-    return modules[moduleIdReallyIsNumber].importedDefault;
-  }
-
-  const exports = metroRequire(moduleIdReallyIsNumber);
-  const importedDefault =
-    exports && exports.__esModule ? exports.default : exports; // $FlowFixMe The metroRequire call above will throw if modules[id] is null
-
-  return (modules[moduleIdReallyIsNumber].importedDefault = importedDefault);
-}
-
-metroRequire.importDefault = metroImportDefault;
-
-function metroImportAll(moduleId) {
-  if (__DEV__ && typeof moduleId === "string") {
-    const verboseName = moduleId;
-    moduleId = verboseNamesToModuleIds[verboseName];
-  } //$FlowFixMe: at this point we know that moduleId is a number
-
-  const moduleIdReallyIsNumber = moduleId;
-
-  if (
-    modules[moduleIdReallyIsNumber] &&
-    modules[moduleIdReallyIsNumber].importedAll !== EMPTY
-  ) {
-    return modules[moduleIdReallyIsNumber].importedAll;
-  }
-
-  const exports = metroRequire(moduleIdReallyIsNumber);
-  let importedAll;
-
-  if (exports && exports.__esModule) {
-    importedAll = exports;
-  } else {
-    importedAll = {}; // Refrain from using Object.assign, it has to work in ES3 environments.
-
-    if (exports) {
-      for (const key in exports) {
-        if (hasOwnProperty.call(exports, key)) {
-          importedAll[key] = exports[key];
-        }
-      }
-    }
-
-    importedAll.default = exports;
-  } // $FlowFixMe The metroRequire call above will throw if modules[id] is null
-
-  return (modules[moduleIdReallyIsNumber].importedAll = importedAll);
-}
-
-metroRequire.importAll = metroImportAll;
-let inGuard = false;
-
-function guardedLoadModule(moduleId, module) {
-  if (!inGuard && global.ErrorUtils) {
-    inGuard = true;
-    let returnValue;
-
-    try {
-      returnValue = loadModuleImplementation(moduleId, module);
-    } catch (e) {
-      // TODO: (moti) T48204692 Type this use of ErrorUtils.
-      global.ErrorUtils.reportFatalError(e);
-    }
-
-    inGuard = false;
-    return returnValue;
-  } else {
-    return loadModuleImplementation(moduleId, module);
-  }
-}
-
-const ID_MASK_SHIFT = 16;
-const LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;
-
-function unpackModuleId(moduleId) {
-  const segmentId = moduleId >>> ID_MASK_SHIFT;
-  const localId = moduleId & LOCAL_ID_MASK;
-  return {
-    segmentId,
-    localId
-  };
-}
-
-metroRequire.unpackModuleId = unpackModuleId;
-
-function packModuleId(value) {
-  return (value.segmentId << ID_MASK_SHIFT) + value.localId;
-}
-
-metroRequire.packModuleId = packModuleId;
-const moduleDefinersBySegmentID = [];
-
-function registerSegment(segmentID, moduleDefiner) {
-  moduleDefinersBySegmentID[segmentID] = moduleDefiner;
-}
-
-function loadModuleImplementation(moduleId, module) {
-  if (!module && moduleDefinersBySegmentID.length > 0) {
-    const _unpackModuleId = unpackModuleId(moduleId),
-      segmentId = _unpackModuleId.segmentId,
-      localId = _unpackModuleId.localId;
-
-    const definer = moduleDefinersBySegmentID[segmentId];
-
-    if (definer != null) {
-      definer(localId);
-      module = modules[moduleId];
-    }
-  }
-
-  const nativeRequire = global.nativeRequire;
-
-  if (!module && nativeRequire) {
-    const _unpackModuleId2 = unpackModuleId(moduleId),
-      segmentId = _unpackModuleId2.segmentId,
-      localId = _unpackModuleId2.localId;
-
-    nativeRequire(localId, segmentId);
-    module = modules[moduleId];
-  }
-
-  if (!module) {
-    throw unknownModuleError(moduleId);
-  }
-
-  if (module.hasError) {
-    throw moduleThrewError(moduleId, module.error);
-  } // `metroRequire` calls into the require polyfill itself are not analyzed and
-  // replaced so that they use numeric module IDs.
-  // The systrace module will expose itself on the metroRequire function so that
-  // it can be used here.
-  // TODO(t9759686) Scan polyfills for dependencies, too
-
-  if (__DEV__) {
-    var Systrace = metroRequire.Systrace,
-      Refresh = metroRequire.Refresh;
-  } // We must optimistically mark module as initialized before running the
-  // factory to keep any require cycles inside the factory from causing an
-  // infinite require loop.
-
-  module.isInitialized = true;
-  const _module = module,
-    factory = _module.factory,
-    dependencyMap = _module.dependencyMap;
-
-  if (__DEV__) {
-    initializingModuleIds.push(moduleId);
-  }
-
-  try {
-    if (__DEV__) {
-      // $FlowFixMe: we know that __DEV__ is const and `Systrace` exists
-      Systrace.beginEvent("JS_require_" + (module.verboseName || moduleId));
-    }
-
-    const moduleObject = module.publicModule;
-
-    if (__DEV__) {
-      moduleObject.hot = module.hot;
-      var prevRefreshReg = global.$RefreshReg$;
-      var prevRefreshSig = global.$RefreshSig$;
-
-      if (Refresh != null) {
-        const RefreshRuntime = Refresh;
-
-        global.$RefreshReg$ = (type, id) => {
-          RefreshRuntime.register(type, moduleId + " " + id);
-        };
-
-        global.$RefreshSig$ =
-          RefreshRuntime.createSignatureFunctionForTransform;
-      }
-    }
-
-    moduleObject.id = moduleId; // keep args in sync with with defineModuleCode in
-    // metro/src/Resolver/index.js
-    // and metro/src/ModuleGraph/worker.js
-
-    factory(
-      global,
-      metroRequire,
-      metroImportDefault,
-      metroImportAll,
-      moduleObject,
-      moduleObject.exports,
-      dependencyMap
-    ); // avoid removing factory in DEV mode as it breaks HMR
-
-    if (!__DEV__) {
-      // $FlowFixMe: This is only sound because we never access `factory` again
-      module.factory = undefined;
-      module.dependencyMap = undefined;
-    }
-
-    if (__DEV__) {
-      // $FlowFixMe: we know that __DEV__ is const and `Systrace` exists
-      Systrace.endEvent();
-
-      if (Refresh != null) {
-        registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);
-      }
-    }
-
-    return moduleObject.exports;
-  } catch (e) {
-    module.hasError = true;
-    module.error = e;
-    module.isInitialized = false;
-    module.publicModule.exports = undefined;
-    throw e;
-  } finally {
-    if (__DEV__) {
-      if (initializingModuleIds.pop() !== moduleId) {
-        throw new Error(
-          "initializingModuleIds is corrupt; something is terribly wrong"
-        );
-      }
-
-      global.$RefreshReg$ = prevRefreshReg;
-      global.$RefreshSig$ = prevRefreshSig;
-    }
-  }
-}
-
-function unknownModuleError(id) {
-  let message = 'Requiring unknown module "' + id + '".';
-
-  if (__DEV__) {
-    message +=
-      " If you are sure the module exists, try restarting Metro. " +
-      "You may also want to run `yarn` or `npm install`.";
-  }
-
-  return Error(message);
-}
-
-function moduleThrewError(id, error) {
-  const displayName = (__DEV__ && modules[id] && modules[id].verboseName) || id;
-  return Error(
-    'Requiring module "' + displayName + '", which threw an exception: ' + error
-  );
-}
-
-if (__DEV__) {
-  metroRequire.Systrace = {
-    beginEvent: () => {},
-    endEvent: () => {}
-  };
-
-  metroRequire.getModules = () => {
-    return modules;
-  }; // HOT MODULE RELOADING
-
-  var createHotReloadingObject = function() {
-    const hot = {
-      _acceptCallback: null,
-      _disposeCallback: null,
-      _didAccept: false,
-      accept: callback => {
-        hot._didAccept = true;
-        hot._acceptCallback = callback;
-      },
-      dispose: callback => {
-        hot._disposeCallback = callback;
-      }
-    };
-    return hot;
-  };
-
-  let reactRefreshTimeout = null;
-
-  const metroHotUpdateModule = function(
-    id,
-    factory,
-    dependencyMap,
-    inverseDependencies
-  ) {
-    const mod = modules[id];
-
-    if (!mod) {
-      if (factory) {
-        // New modules are going to be handled by the define() method.
-        return;
-      }
-
-      throw unknownModuleError(id);
-    }
-
-    if (!mod.hasError && !mod.isInitialized) {
-      // The module hasn't actually been executed yet,
-      // so we can always safely replace it.
-      mod.factory = factory;
-      mod.dependencyMap = dependencyMap;
-      return;
-    }
-
-    const Refresh = metroRequire.Refresh;
-    const pendingModuleIDs = [id];
-    const updatedModuleIDs = [];
-    const seenModuleIDs = new Set();
-    const refreshBoundaryIDs = new Set(); // In this loop, we will traverse the dependency tree upwards from the
-    // changed module. Updates "bubble" up to the closest accepted parent.
-    //
-    // If we reach the module root and nothing along the way accepted the update,
-    // we know hot reload is going to fail. In that case we return false.
-    //
-    // The main purpose of this loop is to figure out whether it's safe to apply
-    // a hot update. It is only safe when the update was accepted somewhere
-    // along the way upwards for each of its parent dependency module chains.
-    //
-    // If we didn't have this check, we'd risk re-evaluating modules that
-    // have side effects and lead to confusing and meaningless crashes.
-
-    while (pendingModuleIDs.length > 0) {
-      const pendingID = pendingModuleIDs.pop(); // Don't process twice if we have a cycle.
-
-      if (seenModuleIDs.has(pendingID)) {
-        continue;
-      }
-
-      seenModuleIDs.add(pendingID); // If the module accepts itself, no need to bubble.
-      // We can stop worrying about this module chain and pick the next one.
-
-      const pendingModule = modules[pendingID];
-
-      if (pendingModule != null) {
-        const pendingHot = pendingModule.hot;
-
-        if (pendingHot == null) {
-          throw new Error(
-            "[Refresh] Expected module.hot to always exist in DEV."
-          );
-        } // A module can be accepted manually from within itself.
-
-        let canAccept = pendingHot._didAccept;
-
-        if (!canAccept && Refresh != null) {
-          // Or React Refresh may mark it accepted based on exports.
-          const isBoundary = isReactRefreshBoundary(
-            Refresh,
-            pendingModule.publicModule.exports
-          );
-
-          if (isBoundary) {
-            canAccept = true;
-            refreshBoundaryIDs.add(pendingID);
-          }
-        }
-
-        if (canAccept) {
-          updatedModuleIDs.push(pendingID);
-          continue;
-        }
-      } // If we bubble through the roof, there is no way to do a hot update.
-      // Bail out altogether. This is the failure case.
-
-      const parentIDs = inverseDependencies[pendingID];
-
-      if (parentIDs.length === 0) {
-        // Reload the app because the hot reload can't succeed.
-        // This should work both on web and React Native.
-        performFullRefresh();
-        return;
-      } // This module didn't accept but maybe all its parents did?
-      // Put them all in the queue to run the same set of checks.
-
-      updatedModuleIDs.push(pendingID);
-      parentIDs.forEach(parentID => pendingModuleIDs.push(parentID));
-    } // If we reached here, it is likely that hot reload will be successful.
-    // Run the actual factories.
-
-    seenModuleIDs.clear();
-
-    for (let i = 0; i < updatedModuleIDs.length; i++) {
-      // Don't process twice if we have a cycle.
-      const updatedID = updatedModuleIDs[i];
-
-      if (seenModuleIDs.has(updatedID)) {
-        continue;
-      }
-
-      seenModuleIDs.add(updatedID);
-      const mod = modules[updatedID];
-
-      if (mod == null) {
-        throw new Error("[Refresh] Expected to find the updated module.");
-      }
-
-      const prevExports = mod.publicModule.exports;
-      const didError = runUpdatedModule(
-        updatedID,
-        updatedID === id ? factory : undefined,
-        updatedID === id ? dependencyMap : undefined
-      );
-      const nextExports = mod.publicModule.exports;
-
-      if (didError) {
-        // The user was shown a redbox about module initialization.
-        // There's nothing for us to do here until it's fixed.
-        return;
-      }
-
-      if (refreshBoundaryIDs.has(updatedID)) {
-        // Since we just executed the code for it, it's possible
-        // that the new exports make it ineligible for being a boundary.
-        const isNoLongerABoundary = !isReactRefreshBoundary(
-          Refresh,
-          nextExports
-        ); // It can also become ineligible if its exports are incompatible
-        // with the previous exports.
-        // For example, if you add/remove/change exports, we'll want
-        // to re-execute the importing modules, and force those components
-        // to re-render. Similarly, if you convert a class component
-        // to a function, we want to invalidate the boundary.
-
-        const didInvalidate = shouldInvalidateReactRefreshBoundary(
-          Refresh,
-          prevExports,
-          nextExports
-        );
-
-        if (isNoLongerABoundary || didInvalidate) {
-          // We'll be conservative. The only case in which we won't do a full
-          // reload is if all parent modules are also refresh boundaries.
-          // In that case we'll add them to the current queue.
-          const parentIDs = inverseDependencies[updatedID];
-
-          if (parentIDs.length === 0) {
-            // Looks like we bubbled to the root. Can't recover from that.
-            performFullRefresh();
-            return;
-          } // Schedule all parent refresh boundaries to re-run in this loop.
-
-          for (let j = 0; j < parentIDs.length; j++) {
-            const parentID = parentIDs[j];
-            const parentMod = modules[parentID];
-
-            if (parentMod == null) {
-              throw new Error("[Refresh] Expected to find parent module.");
-            }
-
-            const canAcceptParent = isReactRefreshBoundary(
-              Refresh,
-              parentMod.publicModule.exports
-            );
-
-            if (canAcceptParent) {
-              // All parents will have to re-run too.
-              refreshBoundaryIDs.add(parentID);
-              updatedModuleIDs.push(parentID);
-            } else {
-              performFullRefresh();
-              return;
-            }
-          }
-        }
-      }
-    }
-
-    if (Refresh != null) {
-      // Debounce a little in case there are multiple updates queued up.
-      // This is also useful because __accept may be called multiple times.
-      if (reactRefreshTimeout == null) {
-        reactRefreshTimeout = setTimeout(() => {
-          reactRefreshTimeout = null; // Update React components.
-
-          Refresh.performReactRefresh();
-        }, 30);
-      }
-    }
-  };
-
-  const runUpdatedModule = function(id, factory, dependencyMap) {
-    const mod = modules[id];
-
-    if (mod == null) {
-      throw new Error("[Refresh] Expected to find the module.");
-    }
-
-    const hot = mod.hot;
-
-    if (!hot) {
-      throw new Error("[Refresh] Expected module.hot to always exist in DEV.");
-    }
-
-    if (hot._disposeCallback) {
-      try {
-        hot._disposeCallback();
-      } catch (error) {
-        console.error(
-          `Error while calling dispose handler for module ${id}: `,
-          error
-        );
-      }
-    }
-
-    if (factory) {
-      mod.factory = factory;
-    }
-
-    if (dependencyMap) {
-      mod.dependencyMap = dependencyMap;
-    }
-
-    mod.hasError = false;
-    mod.error = undefined;
-    mod.importedAll = EMPTY;
-    mod.importedDefault = EMPTY;
-    mod.isInitialized = false;
-    const prevExports = mod.publicModule.exports;
-    mod.publicModule.exports = {};
-    hot._didAccept = false;
-    hot._acceptCallback = null;
-    hot._disposeCallback = null;
-    metroRequire(id);
-
-    if (mod.hasError) {
-      // This error has already been reported via a redbox.
-      // We know it's likely a typo or some mistake that was just introduced.
-      // Our goal now is to keep the rest of the application working so that by
-      // the time user fixes the error, the app isn't completely destroyed
-      // underneath the redbox. So we'll revert the module object to the last
-      // successful export and stop propagating this update.
-      mod.hasError = false;
-      mod.isInitialized = true;
-      mod.error = null;
-      mod.publicModule.exports = prevExports; // We errored. Stop the update.
-
-      return true;
-    }
-
-    if (hot._acceptCallback) {
-      try {
-        hot._acceptCallback();
-      } catch (error) {
-        console.error(
-          `Error while calling accept handler for module ${id}: `,
-          error
-        );
-      }
-    } // No error.
-
-    return false;
-  };
-
-  const performFullRefresh = () => {
-    /* global window */
-    if (
-      typeof window !== "undefined" &&
-      window.location != null &&
-      typeof window.location.reload === "function"
-    ) {
-      window.location.reload();
-    } else {
-      // This is attached in setUpDeveloperTools.
-      const Refresh = metroRequire.Refresh;
-
-      if (Refresh != null) {
-        Refresh.performFullRefresh();
-      } else {
-        console.warn("Could not reload the application after an edit.");
-      }
-    }
-  }; // Modules that only export components become React Refresh boundaries.
-
-  var isReactRefreshBoundary = function(Refresh, moduleExports) {
-    if (Refresh.isLikelyComponentType(moduleExports)) {
-      return true;
-    }
-
-    if (moduleExports == null || typeof moduleExports !== "object") {
-      // Exit if we can't iterate over exports.
-      return false;
-    }
-
-    let hasExports = false;
-    let areAllExportsComponents = true;
-
-    for (const key in moduleExports) {
-      hasExports = true;
-
-      if (key === "__esModule") {
-        continue;
-      }
-
-      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
-
-      if (desc && desc.get) {
-        // Don't invoke getters as they may have side effects.
-        return false;
-      }
-
-      const exportValue = moduleExports[key];
-
-      if (!Refresh.isLikelyComponentType(exportValue)) {
-        areAllExportsComponents = false;
-      }
-    }
-
-    return hasExports && areAllExportsComponents;
-  };
-
-  var shouldInvalidateReactRefreshBoundary = (
-    Refresh,
-    prevExports,
-    nextExports
-  ) => {
-    const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);
-    const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);
-
-    if (prevSignature.length !== nextSignature.length) {
-      return true;
-    }
-
-    for (let i = 0; i < nextSignature.length; i++) {
-      if (prevSignature[i] !== nextSignature[i]) {
-        return true;
-      }
-    }
-
-    return false;
-  }; // When this signature changes, it's unsafe to stop at this refresh boundary.
-
-  var getRefreshBoundarySignature = (Refresh, moduleExports) => {
-    const signature = [];
-    signature.push(Refresh.getFamilyByType(moduleExports));
-
-    if (moduleExports == null || typeof moduleExports !== "object") {
-      // Exit if we can't iterate over exports.
-      // (This is important for legacy environments.)
-      return signature;
-    }
-
-    for (const key in moduleExports) {
-      if (key === "__esModule") {
-        continue;
-      }
-
-      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
-
-      if (desc && desc.get) {
-        continue;
-      }
-
-      const exportValue = moduleExports[key];
-      signature.push(key);
-      signature.push(Refresh.getFamilyByType(exportValue));
-    }
-
-    return signature;
-  };
-
-  var registerExportsForReactRefresh = (Refresh, moduleExports, moduleID) => {
-    Refresh.register(moduleExports, moduleID + " %exports%");
-
-    if (moduleExports == null || typeof moduleExports !== "object") {
-      // Exit if we can't iterate over exports.
-      // (This is important for legacy environments.)
-      return;
-    }
-
-    for (const key in moduleExports) {
-      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
-
-      if (desc && desc.get) {
-        // Don't invoke getters as they may have side effects.
-        continue;
-      }
-
-      const exportValue = moduleExports[key];
-      const typeID = moduleID + " %exports% " + key;
-      Refresh.register(exportValue, typeID);
-    }
-  };
-
-  global.__accept = metroHotUpdateModule;
-}
diff --git a/node_modules/metro/src/lib/polyfills/require.js.flow b/node_modules/metro/src/lib/polyfills/require.js.flow
deleted file mode 100644
index b3852fa..0000000
--- a/node_modules/metro/src/lib/polyfills/require.js.flow
+++ /dev/null
@@ -1,838 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @polyfill
- * @flow
- * @format
- */
-
-'use strict';
-
-/* eslint-disable no-bitwise */
-
-declare var __DEV__: boolean;
-
-type DependencyMap = Array<ModuleID>;
-type Exports = any;
-type FactoryFn = (
-  global: Object,
-  require: RequireFn,
-  metroImportDefault: RequireFn,
-  metroImportAll: RequireFn,
-  moduleObject: {exports: {}},
-  exports: {},
-  dependencyMap: ?DependencyMap,
-) => void;
-type HotModuleReloadingCallback = () => void;
-type HotModuleReloadingData = {|
-  _acceptCallback: ?HotModuleReloadingCallback,
-  _disposeCallback: ?HotModuleReloadingCallback,
-  _didAccept: boolean,
-  accept: (callback?: HotModuleReloadingCallback) => void,
-  dispose: (callback?: HotModuleReloadingCallback) => void,
-|};
-type ModuleID = number;
-type Module = {
-  id?: ModuleID,
-  exports: Exports,
-  hot?: HotModuleReloadingData,
-};
-type ModuleDefinition = {|
-  dependencyMap: ?DependencyMap,
-  error?: any,
-  factory: FactoryFn,
-  hasError: boolean,
-  hot?: HotModuleReloadingData,
-  importedAll: any,
-  importedDefault: any,
-  isInitialized: boolean,
-  path?: string,
-  publicModule: Module,
-  verboseName?: string,
-|};
-type ModuleList = {[number]: ?ModuleDefinition, __proto__: null};
-type RequireFn = (id: ModuleID | VerboseModuleNameForDev) => Exports;
-type VerboseModuleNameForDev = string;
-
-global.__r = metroRequire;
-global.__d = define;
-global.__c = clear;
-global.__registerSegment = registerSegment;
-
-var modules = clear();
-
-// Don't use a Symbol here, it would pull in an extra polyfill with all sorts of
-// additional stuff (e.g. Array.from).
-const EMPTY = {};
-const {hasOwnProperty} = {};
-
-if (__DEV__) {
-  global.$RefreshReg$ = () => {};
-  global.$RefreshSig$ = () => type => type;
-}
-
-function clear(): ModuleList {
-  modules = (Object.create(null): ModuleList);
-
-  // We return modules here so that we can assign an initial value to modules
-  // when defining it. Otherwise, we would have to do "let modules = null",
-  // which will force us to add "nullthrows" everywhere.
-  return modules;
-}
-
-if (__DEV__) {
-  var verboseNamesToModuleIds: {
-    [key: string]: number,
-    __proto__: null,
-  } = Object.create(null);
-  var initializingModuleIds: Array<number> = [];
-}
-
-function define(
-  factory: FactoryFn,
-  moduleId: number,
-  dependencyMap?: DependencyMap,
-): void {
-  if (modules[moduleId] != null) {
-    if (__DEV__) {
-      // (We take `inverseDependencies` from `arguments` to avoid an unused
-      // named parameter in `define` in production.
-      const inverseDependencies = arguments[4];
-
-      // If the module has already been defined and the define method has been
-      // called with inverseDependencies, we can hot reload it.
-      if (inverseDependencies) {
-        global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
-      }
-    }
-
-    // prevent repeated calls to `global.nativeRequire` to overwrite modules
-    // that are already loaded
-    return;
-  }
-
-  const mod: ModuleDefinition = {
-    dependencyMap,
-    factory,
-    hasError: false,
-    importedAll: EMPTY,
-    importedDefault: EMPTY,
-    isInitialized: false,
-    publicModule: {exports: {}},
-  };
-
-  modules[moduleId] = mod;
-
-  if (__DEV__) {
-    // HMR
-    mod.hot = createHotReloadingObject();
-
-    // DEBUGGABLE MODULES NAMES
-    // we take `verboseName` from `arguments` to avoid an unused named parameter
-    // in `define` in production.
-    const verboseName: string | void = arguments[3];
-    if (verboseName) {
-      mod.verboseName = verboseName;
-      verboseNamesToModuleIds[verboseName] = moduleId;
-    }
-  }
-}
-
-function metroRequire(moduleId: ModuleID | VerboseModuleNameForDev): Exports {
-  if (__DEV__ && typeof moduleId === 'string') {
-    const verboseName = moduleId;
-    moduleId = verboseNamesToModuleIds[verboseName];
-    if (moduleId == null) {
-      throw new Error(`Unknown named module: "${verboseName}"`);
-    } else {
-      console.warn(
-        `Requiring module "${verboseName}" by name is only supported for ` +
-          'debugging purposes and will BREAK IN PRODUCTION!',
-      );
-    }
-  }
-
-  //$FlowFixMe: at this point we know that moduleId is a number
-  const moduleIdReallyIsNumber: number = moduleId;
-
-  if (__DEV__) {
-    const initializingIndex = initializingModuleIds.indexOf(
-      moduleIdReallyIsNumber,
-    );
-    if (initializingIndex !== -1) {
-      const cycle = initializingModuleIds
-        .slice(initializingIndex)
-        .map((id: number) =>
-          modules[id] ? modules[id].verboseName : '[unknown]',
-        );
-      // We want to show A -> B -> A:
-      cycle.push(cycle[0]);
-      console.warn(
-        `Require cycle: ${cycle.join(' -> ')}\n\n` +
-          'Require cycles are allowed, but can result in uninitialized values. ' +
-          'Consider refactoring to remove the need for a cycle.',
-      );
-    }
-  }
-
-  const module = modules[moduleIdReallyIsNumber];
-
-  return module && module.isInitialized
-    ? module.publicModule.exports
-    : guardedLoadModule(moduleIdReallyIsNumber, module);
-}
-
-function metroImportDefault(moduleId: ModuleID | VerboseModuleNameForDev) {
-  if (__DEV__ && typeof moduleId === 'string') {
-    const verboseName = moduleId;
-    moduleId = verboseNamesToModuleIds[verboseName];
-  }
-
-  //$FlowFixMe: at this point we know that moduleId is a number
-  const moduleIdReallyIsNumber: number = moduleId;
-
-  if (
-    modules[moduleIdReallyIsNumber] &&
-    modules[moduleIdReallyIsNumber].importedDefault !== EMPTY
-  ) {
-    return modules[moduleIdReallyIsNumber].importedDefault;
-  }
-
-  const exports = metroRequire(moduleIdReallyIsNumber);
-  const importedDefault =
-    exports && exports.__esModule ? exports.default : exports;
-
-  // $FlowFixMe The metroRequire call above will throw if modules[id] is null
-  return (modules[moduleIdReallyIsNumber].importedDefault = importedDefault);
-}
-metroRequire.importDefault = metroImportDefault;
-
-function metroImportAll(moduleId: ModuleID | VerboseModuleNameForDev | number) {
-  if (__DEV__ && typeof moduleId === 'string') {
-    const verboseName = moduleId;
-    moduleId = verboseNamesToModuleIds[verboseName];
-  }
-
-  //$FlowFixMe: at this point we know that moduleId is a number
-  const moduleIdReallyIsNumber: number = moduleId;
-
-  if (
-    modules[moduleIdReallyIsNumber] &&
-    modules[moduleIdReallyIsNumber].importedAll !== EMPTY
-  ) {
-    return modules[moduleIdReallyIsNumber].importedAll;
-  }
-
-  const exports = metroRequire(moduleIdReallyIsNumber);
-  let importedAll;
-
-  if (exports && exports.__esModule) {
-    importedAll = exports;
-  } else {
-    importedAll = {};
-
-    // Refrain from using Object.assign, it has to work in ES3 environments.
-    if (exports) {
-      for (const key in exports) {
-        if (hasOwnProperty.call(exports, key)) {
-          importedAll[key] = exports[key];
-        }
-      }
-    }
-
-    importedAll.default = exports;
-  }
-
-  // $FlowFixMe The metroRequire call above will throw if modules[id] is null
-  return (modules[moduleIdReallyIsNumber].importedAll = importedAll);
-}
-metroRequire.importAll = metroImportAll;
-
-let inGuard = false;
-function guardedLoadModule(
-  moduleId: ModuleID,
-  module: ?ModuleDefinition,
-): Exports {
-  if (!inGuard && global.ErrorUtils) {
-    inGuard = true;
-    let returnValue;
-    try {
-      returnValue = loadModuleImplementation(moduleId, module);
-    } catch (e) {
-      // TODO: (moti) T48204692 Type this use of ErrorUtils.
-      global.ErrorUtils.reportFatalError(e);
-    }
-    inGuard = false;
-    return returnValue;
-  } else {
-    return loadModuleImplementation(moduleId, module);
-  }
-}
-
-const ID_MASK_SHIFT = 16;
-const LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;
-
-function unpackModuleId(
-  moduleId: ModuleID,
-): {localId: number, segmentId: number} {
-  const segmentId = moduleId >>> ID_MASK_SHIFT;
-  const localId = moduleId & LOCAL_ID_MASK;
-  return {segmentId, localId};
-}
-metroRequire.unpackModuleId = unpackModuleId;
-
-function packModuleId(value: {localId: number, segmentId: number}): ModuleID {
-  return (value.segmentId << ID_MASK_SHIFT) + value.localId;
-}
-metroRequire.packModuleId = packModuleId;
-
-const moduleDefinersBySegmentID = [];
-
-function registerSegment(segmentID, moduleDefiner): void {
-  moduleDefinersBySegmentID[segmentID] = moduleDefiner;
-}
-
-function loadModuleImplementation(
-  moduleId: ModuleID,
-  module: ?ModuleDefinition,
-): Exports {
-  if (!module && moduleDefinersBySegmentID.length > 0) {
-    const {segmentId, localId} = unpackModuleId(moduleId);
-    const definer = moduleDefinersBySegmentID[segmentId];
-    if (definer != null) {
-      definer(localId);
-      module = modules[moduleId];
-    }
-  }
-
-  const nativeRequire = global.nativeRequire;
-  if (!module && nativeRequire) {
-    const {segmentId, localId} = unpackModuleId(moduleId);
-    nativeRequire(localId, segmentId);
-    module = modules[moduleId];
-  }
-
-  if (!module) {
-    throw unknownModuleError(moduleId);
-  }
-
-  if (module.hasError) {
-    throw moduleThrewError(moduleId, module.error);
-  }
-
-  // `metroRequire` calls into the require polyfill itself are not analyzed and
-  // replaced so that they use numeric module IDs.
-  // The systrace module will expose itself on the metroRequire function so that
-  // it can be used here.
-  // TODO(t9759686) Scan polyfills for dependencies, too
-  if (__DEV__) {
-    var {Systrace, Refresh} = metroRequire;
-  }
-
-  // We must optimistically mark module as initialized before running the
-  // factory to keep any require cycles inside the factory from causing an
-  // infinite require loop.
-  module.isInitialized = true;
-
-  const {factory, dependencyMap} = module;
-  if (__DEV__) {
-    initializingModuleIds.push(moduleId);
-  }
-  try {
-    if (__DEV__) {
-      // $FlowFixMe: we know that __DEV__ is const and `Systrace` exists
-      Systrace.beginEvent('JS_require_' + (module.verboseName || moduleId));
-    }
-
-    const moduleObject: Module = module.publicModule;
-
-    if (__DEV__) {
-      moduleObject.hot = module.hot;
-
-      var prevRefreshReg = global.$RefreshReg$;
-      var prevRefreshSig = global.$RefreshSig$;
-      if (Refresh != null) {
-        const RefreshRuntime = Refresh;
-        global.$RefreshReg$ = (type, id) => {
-          RefreshRuntime.register(type, moduleId + ' ' + id);
-        };
-        global.$RefreshSig$ =
-          RefreshRuntime.createSignatureFunctionForTransform;
-      }
-    }
-    moduleObject.id = moduleId;
-
-    // keep args in sync with with defineModuleCode in
-    // metro/src/Resolver/index.js
-    // and metro/src/ModuleGraph/worker.js
-    factory(
-      global,
-      metroRequire,
-      metroImportDefault,
-      metroImportAll,
-      moduleObject,
-      moduleObject.exports,
-      dependencyMap,
-    );
-
-    // avoid removing factory in DEV mode as it breaks HMR
-    if (!__DEV__) {
-      // $FlowFixMe: This is only sound because we never access `factory` again
-      module.factory = undefined;
-      module.dependencyMap = undefined;
-    }
-
-    if (__DEV__) {
-      // $FlowFixMe: we know that __DEV__ is const and `Systrace` exists
-      Systrace.endEvent();
-
-      if (Refresh != null) {
-        registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);
-      }
-    }
-
-    return moduleObject.exports;
-  } catch (e) {
-    module.hasError = true;
-    module.error = e;
-    module.isInitialized = false;
-    module.publicModule.exports = undefined;
-    throw e;
-  } finally {
-    if (__DEV__) {
-      if (initializingModuleIds.pop() !== moduleId) {
-        throw new Error(
-          'initializingModuleIds is corrupt; something is terribly wrong',
-        );
-      }
-      global.$RefreshReg$ = prevRefreshReg;
-      global.$RefreshSig$ = prevRefreshSig;
-    }
-  }
-}
-
-function unknownModuleError(id: ModuleID): Error {
-  let message = 'Requiring unknown module "' + id + '".';
-  if (__DEV__) {
-    message +=
-      ' If you are sure the module exists, try restarting Metro. ' +
-      'You may also want to run `yarn` or `npm install`.';
-  }
-  return Error(message);
-}
-
-function moduleThrewError(id: ModuleID, error: any): Error {
-  const displayName = (__DEV__ && modules[id] && modules[id].verboseName) || id;
-  return Error(
-    'Requiring module "' +
-      displayName +
-      '", which threw an exception: ' +
-      error,
-  );
-}
-
-if (__DEV__) {
-  metroRequire.Systrace = {
-    beginEvent: (): void => {},
-    endEvent: (): void => {},
-  };
-
-  metroRequire.getModules = (): ModuleList => {
-    return modules;
-  };
-
-  // HOT MODULE RELOADING
-  var createHotReloadingObject = function() {
-    const hot: HotModuleReloadingData = {
-      _acceptCallback: null,
-      _disposeCallback: null,
-      _didAccept: false,
-      accept: (callback?: HotModuleReloadingCallback): void => {
-        hot._didAccept = true;
-        hot._acceptCallback = callback;
-      },
-      dispose: (callback?: HotModuleReloadingCallback): void => {
-        hot._disposeCallback = callback;
-      },
-    };
-    return hot;
-  };
-
-  let reactRefreshTimeout = null;
-
-  const metroHotUpdateModule = function(
-    id: ModuleID,
-    factory: FactoryFn,
-    dependencyMap: DependencyMap,
-    inverseDependencies: {[key: ModuleID]: Array<ModuleID>},
-  ) {
-    const mod = modules[id];
-    if (!mod) {
-      if (factory) {
-        // New modules are going to be handled by the define() method.
-        return;
-      }
-      throw unknownModuleError(id);
-    }
-
-    if (!mod.hasError && !mod.isInitialized) {
-      // The module hasn't actually been executed yet,
-      // so we can always safely replace it.
-      mod.factory = factory;
-      mod.dependencyMap = dependencyMap;
-      return;
-    }
-
-    const {Refresh} = metroRequire;
-    const pendingModuleIDs = [id];
-    const updatedModuleIDs = [];
-    const seenModuleIDs = new Set();
-    const refreshBoundaryIDs = new Set();
-
-    // In this loop, we will traverse the dependency tree upwards from the
-    // changed module. Updates "bubble" up to the closest accepted parent.
-    //
-    // If we reach the module root and nothing along the way accepted the update,
-    // we know hot reload is going to fail. In that case we return false.
-    //
-    // The main purpose of this loop is to figure out whether it's safe to apply
-    // a hot update. It is only safe when the update was accepted somewhere
-    // along the way upwards for each of its parent dependency module chains.
-    //
-    // If we didn't have this check, we'd risk re-evaluating modules that
-    // have side effects and lead to confusing and meaningless crashes.
-
-    while (pendingModuleIDs.length > 0) {
-      const pendingID = pendingModuleIDs.pop();
-      // Don't process twice if we have a cycle.
-      if (seenModuleIDs.has(pendingID)) {
-        continue;
-      }
-      seenModuleIDs.add(pendingID);
-
-      // If the module accepts itself, no need to bubble.
-      // We can stop worrying about this module chain and pick the next one.
-      const pendingModule = modules[pendingID];
-      if (pendingModule != null) {
-        const pendingHot = pendingModule.hot;
-        if (pendingHot == null) {
-          throw new Error(
-            '[Refresh] Expected module.hot to always exist in DEV.',
-          );
-        }
-        // A module can be accepted manually from within itself.
-        let canAccept = pendingHot._didAccept;
-        if (!canAccept && Refresh != null) {
-          // Or React Refresh may mark it accepted based on exports.
-          const isBoundary = isReactRefreshBoundary(
-            Refresh,
-            pendingModule.publicModule.exports,
-          );
-          if (isBoundary) {
-            canAccept = true;
-            refreshBoundaryIDs.add(pendingID);
-          }
-        }
-        if (canAccept) {
-          updatedModuleIDs.push(pendingID);
-          continue;
-        }
-      }
-
-      // If we bubble through the roof, there is no way to do a hot update.
-      // Bail out altogether. This is the failure case.
-      const parentIDs = inverseDependencies[pendingID];
-      if (parentIDs.length === 0) {
-        // Reload the app because the hot reload can't succeed.
-        // This should work both on web and React Native.
-        performFullRefresh();
-        return;
-      }
-
-      // This module didn't accept but maybe all its parents did?
-      // Put them all in the queue to run the same set of checks.
-      updatedModuleIDs.push(pendingID);
-      parentIDs.forEach(parentID => pendingModuleIDs.push(parentID));
-    }
-
-    // If we reached here, it is likely that hot reload will be successful.
-    // Run the actual factories.
-    seenModuleIDs.clear();
-    for (let i = 0; i < updatedModuleIDs.length; i++) {
-      // Don't process twice if we have a cycle.
-      const updatedID = updatedModuleIDs[i];
-      if (seenModuleIDs.has(updatedID)) {
-        continue;
-      }
-      seenModuleIDs.add(updatedID);
-
-      const mod = modules[updatedID];
-      if (mod == null) {
-        throw new Error('[Refresh] Expected to find the updated module.');
-      }
-      const prevExports = mod.publicModule.exports;
-      const didError = runUpdatedModule(
-        updatedID,
-        updatedID === id ? factory : undefined,
-        updatedID === id ? dependencyMap : undefined,
-      );
-      const nextExports = mod.publicModule.exports;
-
-      if (didError) {
-        // The user was shown a redbox about module initialization.
-        // There's nothing for us to do here until it's fixed.
-        return;
-      }
-
-      if (refreshBoundaryIDs.has(updatedID)) {
-        // Since we just executed the code for it, it's possible
-        // that the new exports make it ineligible for being a boundary.
-        const isNoLongerABoundary = !isReactRefreshBoundary(
-          Refresh,
-          nextExports,
-        );
-        // It can also become ineligible if its exports are incompatible
-        // with the previous exports.
-        // For example, if you add/remove/change exports, we'll want
-        // to re-execute the importing modules, and force those components
-        // to re-render. Similarly, if you convert a class component
-        // to a function, we want to invalidate the boundary.
-        const didInvalidate = shouldInvalidateReactRefreshBoundary(
-          Refresh,
-          prevExports,
-          nextExports,
-        );
-        if (isNoLongerABoundary || didInvalidate) {
-          // We'll be conservative. The only case in which we won't do a full
-          // reload is if all parent modules are also refresh boundaries.
-          // In that case we'll add them to the current queue.
-          const parentIDs = inverseDependencies[updatedID];
-          if (parentIDs.length === 0) {
-            // Looks like we bubbled to the root. Can't recover from that.
-            performFullRefresh();
-            return;
-          }
-          // Schedule all parent refresh boundaries to re-run in this loop.
-          for (let j = 0; j < parentIDs.length; j++) {
-            const parentID = parentIDs[j];
-            const parentMod = modules[parentID];
-            if (parentMod == null) {
-              throw new Error('[Refresh] Expected to find parent module.');
-            }
-            const canAcceptParent = isReactRefreshBoundary(
-              Refresh,
-              parentMod.publicModule.exports,
-            );
-            if (canAcceptParent) {
-              // All parents will have to re-run too.
-              refreshBoundaryIDs.add(parentID);
-              updatedModuleIDs.push(parentID);
-            } else {
-              performFullRefresh();
-              return;
-            }
-          }
-        }
-      }
-    }
-
-    if (Refresh != null) {
-      // Debounce a little in case there are multiple updates queued up.
-      // This is also useful because __accept may be called multiple times.
-      if (reactRefreshTimeout == null) {
-        reactRefreshTimeout = setTimeout(() => {
-          reactRefreshTimeout = null;
-          // Update React components.
-          Refresh.performReactRefresh();
-        }, 30);
-      }
-    }
-  };
-
-  const runUpdatedModule = function(
-    id: ModuleID,
-    factory?: FactoryFn,
-    dependencyMap?: DependencyMap,
-  ): boolean {
-    const mod = modules[id];
-    if (mod == null) {
-      throw new Error('[Refresh] Expected to find the module.');
-    }
-
-    const {hot} = mod;
-    if (!hot) {
-      throw new Error('[Refresh] Expected module.hot to always exist in DEV.');
-    }
-
-    if (hot._disposeCallback) {
-      try {
-        hot._disposeCallback();
-      } catch (error) {
-        console.error(
-          `Error while calling dispose handler for module ${id}: `,
-          error,
-        );
-      }
-    }
-
-    if (factory) {
-      mod.factory = factory;
-    }
-    if (dependencyMap) {
-      mod.dependencyMap = dependencyMap;
-    }
-    mod.hasError = false;
-    mod.error = undefined;
-    mod.importedAll = EMPTY;
-    mod.importedDefault = EMPTY;
-    mod.isInitialized = false;
-    const prevExports = mod.publicModule.exports;
-    mod.publicModule.exports = {};
-    hot._didAccept = false;
-    hot._acceptCallback = null;
-    hot._disposeCallback = null;
-    metroRequire(id);
-
-    if (mod.hasError) {
-      // This error has already been reported via a redbox.
-      // We know it's likely a typo or some mistake that was just introduced.
-      // Our goal now is to keep the rest of the application working so that by
-      // the time user fixes the error, the app isn't completely destroyed
-      // underneath the redbox. So we'll revert the module object to the last
-      // successful export and stop propagating this update.
-      mod.hasError = false;
-      mod.isInitialized = true;
-      mod.error = null;
-      mod.publicModule.exports = prevExports;
-      // We errored. Stop the update.
-      return true;
-    }
-
-    if (hot._acceptCallback) {
-      try {
-        hot._acceptCallback();
-      } catch (error) {
-        console.error(
-          `Error while calling accept handler for module ${id}: `,
-          error,
-        );
-      }
-    }
-    // No error.
-    return false;
-  };
-
-  const performFullRefresh = () => {
-    /* global window */
-    if (
-      typeof window !== 'undefined' &&
-      window.location != null &&
-      typeof window.location.reload === 'function'
-    ) {
-      window.location.reload();
-    } else {
-      // This is attached in setUpDeveloperTools.
-      const {Refresh} = metroRequire;
-      if (Refresh != null) {
-        Refresh.performFullRefresh();
-      } else {
-        console.warn('Could not reload the application after an edit.');
-      }
-    }
-  };
-
-  // Modules that only export components become React Refresh boundaries.
-  var isReactRefreshBoundary = function(Refresh, moduleExports): boolean {
-    if (Refresh.isLikelyComponentType(moduleExports)) {
-      return true;
-    }
-    if (moduleExports == null || typeof moduleExports !== 'object') {
-      // Exit if we can't iterate over exports.
-      return false;
-    }
-    let hasExports = false;
-    let areAllExportsComponents = true;
-    for (const key in moduleExports) {
-      hasExports = true;
-      if (key === '__esModule') {
-        continue;
-      }
-      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
-      if (desc && desc.get) {
-        // Don't invoke getters as they may have side effects.
-        return false;
-      }
-      const exportValue = moduleExports[key];
-      if (!Refresh.isLikelyComponentType(exportValue)) {
-        areAllExportsComponents = false;
-      }
-    }
-    return hasExports && areAllExportsComponents;
-  };
-
-  var shouldInvalidateReactRefreshBoundary = (
-    Refresh,
-    prevExports,
-    nextExports,
-  ) => {
-    const prevSignature = getRefreshBoundarySignature(Refresh, prevExports);
-    const nextSignature = getRefreshBoundarySignature(Refresh, nextExports);
-    if (prevSignature.length !== nextSignature.length) {
-      return true;
-    }
-    for (let i = 0; i < nextSignature.length; i++) {
-      if (prevSignature[i] !== nextSignature[i]) {
-        return true;
-      }
-    }
-    return false;
-  };
-
-  // When this signature changes, it's unsafe to stop at this refresh boundary.
-  var getRefreshBoundarySignature = (Refresh, moduleExports): Array<mixed> => {
-    const signature = [];
-    signature.push(Refresh.getFamilyByType(moduleExports));
-    if (moduleExports == null || typeof moduleExports !== 'object') {
-      // Exit if we can't iterate over exports.
-      // (This is important for legacy environments.)
-      return signature;
-    }
-    for (const key in moduleExports) {
-      if (key === '__esModule') {
-        continue;
-      }
-      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
-      if (desc && desc.get) {
-        continue;
-      }
-      const exportValue = moduleExports[key];
-      signature.push(key);
-      signature.push(Refresh.getFamilyByType(exportValue));
-    }
-    return signature;
-  };
-
-  var registerExportsForReactRefresh = (Refresh, moduleExports, moduleID) => {
-    Refresh.register(moduleExports, moduleID + ' %exports%');
-    if (moduleExports == null || typeof moduleExports !== 'object') {
-      // Exit if we can't iterate over exports.
-      // (This is important for legacy environments.)
-      return;
-    }
-    for (const key in moduleExports) {
-      const desc = Object.getOwnPropertyDescriptor(moduleExports, key);
-      if (desc && desc.get) {
-        // Don't invoke getters as they may have side effects.
-        continue;
-      }
-      const exportValue = moduleExports[key];
-      const typeID = moduleID + ' %exports% ' + key;
-      Refresh.register(exportValue, typeID);
-    }
-  };
-
-  global.__accept = metroHotUpdateModule;
-}
diff --git a/node_modules/metro/src/lib/relativizeSourceMap.js b/node_modules/metro/src/lib/relativizeSourceMap.js
index c7279a4..0be6d18 100644
--- a/node_modules/metro/src/lib/relativizeSourceMap.js
+++ b/node_modules/metro/src/lib/relativizeSourceMap.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/lib/reporting.js b/node_modules/metro/src/lib/reporting.js
index 4c241a4..30d187c 100644
--- a/node_modules/metro/src/lib/reporting.js
+++ b/node_modules/metro/src/lib/reporting.js
@@ -11,17 +11,19 @@
 
 const chalk = require("chalk");
 
+const stripAnsi = require("strip-ansi");
+
 const util = require("util");
 
 const _require = require("metro-core"),
   Terminal = _require.Terminal;
-
 /**
  * A standard way to log a warning to the terminal. This should not be called
- * from some arbitrary Metro Bundler logic, only from the reporters. Instead of
+ * from some arbitrary Metro logic, only from the reporters. Instead of
  * calling this, add a new type of ReportableEvent instead, and implement a
  * proper handler in the reporter(s).
  */
+
 function logWarning(terminal, format) {
   for (
     var _len = arguments.length,
@@ -51,8 +53,17 @@ function logError(terminal, format) {
     args[_key2 - 2] = arguments[_key2];
   }
 
-  const str = util.format.apply(util, [format].concat(args));
-  terminal.log("%s: %s", chalk.red("error"), str);
+  terminal.log(
+    "%s: %s",
+    chalk.red("error"), // Syntax errors may have colors applied for displaying code frames
+    // in various places outside of where Metro is currently running.
+    // If the current terminal does not support color, we'll strip the colors
+    // here.
+    util.format.apply(
+      util,
+      [chalk.supportsColor ? format : stripAnsi(format)].concat(args)
+    )
+  );
 }
 /**
  * A reporter that does nothing. Errors and warnings will be swallowed, that
diff --git a/node_modules/metro/src/lib/reporting.js.flow b/node_modules/metro/src/lib/reporting.js.flow
index cdff614..5f89917 100644
--- a/node_modules/metro/src/lib/reporting.js.flow
+++ b/node_modules/metro/src/lib/reporting.js.flow
@@ -11,6 +11,7 @@
 'use strict';
 
 const chalk = require('chalk');
+const stripAnsi = require('strip-ansi');
 const util = require('util');
 
 const {Terminal} = require('metro-core');
@@ -18,11 +19,13 @@ const {Terminal} = require('metro-core');
 export type GlobalCacheDisabledReason = 'too_many_errors' | 'too_many_misses';
 
 export type BundleDetails = {
-  entryFile: string,
-  platform: ?string,
+  bundleType: string,
   dev: boolean,
+  entryFile: string,
   minify: boolean,
-  bundleType: string,
+  platform: ?string,
+  runtimeBytecodeVersion: ?number,
+  ...
 };
 
 /**
@@ -31,69 +34,90 @@ export type BundleDetails = {
  */
 export type ReportableEvent =
   | {
-      port: ?number,
-      projectRoots: $ReadOnlyArray<string>,
+      port: number,
+      hasReducedPerformance: boolean,
       type: 'initialize_started',
-    }
-  | {
-      type: 'initialize_done',
+      ...
     }
   | {
       type: 'initialize_failed',
       port: number,
       error: Error,
+      ...
     }
   | {
       buildID: string,
       type: 'bundle_build_done',
+      ...
     }
   | {
       buildID: string,
       type: 'bundle_build_failed',
+      ...
     }
   | {
       buildID: string,
       bundleDetails: BundleDetails,
       type: 'bundle_build_started',
+      ...
     }
   | {
       error: Error,
       type: 'bundling_error',
+      ...
     }
   | {
       type: 'dep_graph_loading',
+      hasReducedPerformance: boolean,
+      ...
     }
-  | {
-      type: 'dep_graph_loaded',
-    }
+  | {type: 'dep_graph_loaded', ...}
   | {
       buildID: string,
       type: 'bundle_transform_progressed',
       transformedFileCount: number,
       totalFileCount: number,
+      ...
     }
   | {
       type: 'global_cache_error',
       error: Error,
+      ...
     }
   | {
       type: 'global_cache_disabled',
       reason: GlobalCacheDisabledReason,
+      ...
     }
-  | {
-      type: 'transform_cache_reset',
-    }
+  | {type: 'transform_cache_reset', ...}
   | {
       type: 'worker_stdout_chunk',
       chunk: string,
+      ...
     }
   | {
       type: 'worker_stderr_chunk',
       chunk: string,
+      ...
     }
   | {
       type: 'hmr_client_error',
       error: Error,
+      ...
+    }
+  | {
+      type: 'client_log',
+      level:
+        | 'trace'
+        | 'info'
+        | 'warn'
+        | 'log'
+        | 'group'
+        | 'groupCollapsed'
+        | 'groupEnd'
+        | 'debug',
+      data: Array<mixed>,
+      ...
     };
 
 /**
@@ -114,13 +138,11 @@ export type ReportableEvent =
  * TerminalReporter, that should be the only place in the application should
  * access the `terminal` module (nor the `console`).
  */
-export type Reporter = {
-  update(event: ReportableEvent): void,
-};
+export type Reporter = {update(event: ReportableEvent): void, ...};
 
 /**
  * A standard way to log a warning to the terminal. This should not be called
- * from some arbitrary Metro Bundler logic, only from the reporters. Instead of
+ * from some arbitrary Metro logic, only from the reporters. Instead of
  * calling this, add a new type of ReportableEvent instead, and implement a
  * proper handler in the reporter(s).
  */
@@ -141,8 +163,15 @@ function logError(
   format: string,
   ...args: Array<mixed>
 ): void {
-  const str = util.format(format, ...args);
-  terminal.log('%s: %s', chalk.red('error'), str);
+  terminal.log(
+    '%s: %s',
+    chalk.red('error'),
+    // Syntax errors may have colors applied for displaying code frames
+    // in various places outside of where Metro is currently running.
+    // If the current terminal does not support color, we'll strip the colors
+    // here.
+    util.format(chalk.supportsColor ? format : stripAnsi(format), ...args),
+  );
 }
 
 /**
diff --git a/node_modules/metro/src/lib/splitBundleOptions.js b/node_modules/metro/src/lib/splitBundleOptions.js
index dc00715..ea0e232 100644
--- a/node_modules/metro/src/lib/splitBundleOptions.js
+++ b/node_modules/metro/src/lib/splitBundleOptions.js
@@ -4,14 +4,14 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
-
 /**
  * Splits a BundleOptions object into smaller, more manageable parts.
  */
+
 function splitBundleOptions(options) {
   return {
     entryFile: options.entryFile,
@@ -21,7 +21,9 @@ function splitBundleOptions(options) {
       hot: options.hot,
       minify: options.minify,
       platform: options.platform,
-      type: "module"
+      runtimeBytecodeVersion: options.runtimeBytecodeVersion,
+      type: "module",
+      unstable_transformProfile: options.unstable_transformProfile
     },
     serializerOptions: {
       excludeSource: options.excludeSource,
diff --git a/node_modules/metro/src/lib/splitBundleOptions.js.flow b/node_modules/metro/src/lib/splitBundleOptions.js.flow
index 524b197..6418407 100644
--- a/node_modules/metro/src/lib/splitBundleOptions.js.flow
+++ b/node_modules/metro/src/lib/splitBundleOptions.js.flow
@@ -24,7 +24,9 @@ function splitBundleOptions(options: BundleOptions): SplitBundleOptions {
       hot: options.hot,
       minify: options.minify,
       platform: options.platform,
+      runtimeBytecodeVersion: options.runtimeBytecodeVersion,
       type: 'module',
+      unstable_transformProfile: options.unstable_transformProfile,
     },
     serializerOptions: {
       excludeSource: options.excludeSource,
diff --git a/node_modules/metro/src/lib/transformHelpers.js b/node_modules/metro/src/lib/transformHelpers.js
index a63e20e..8a10001 100644
--- a/node_modules/metro/src/lib/transformHelpers.js
+++ b/node_modules/metro/src/lib/transformHelpers.js
@@ -4,17 +4,21 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
 function _objectWithoutProperties(source, excluded) {
   if (source == null) return {};
+
   var target = _objectWithoutPropertiesLoose(source, excluded);
+
   var key, i;
+
   if (Object.getOwnPropertySymbols) {
     var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
+
     for (i = 0; i < sourceSymbolKeys.length; i++) {
       key = sourceSymbolKeys[i];
       if (excluded.indexOf(key) >= 0) continue;
@@ -22,6 +26,7 @@ function _objectWithoutProperties(source, excluded) {
       target[key] = source[key];
     }
   }
+
   return target;
 }
 
@@ -30,29 +35,52 @@ function _objectWithoutPropertiesLoose(source, excluded) {
   var target = {};
   var sourceKeys = Object.keys(source);
   var key, i;
+
   for (i = 0; i < sourceKeys.length; i++) {
     key = sourceKeys[i];
     if (excluded.indexOf(key) >= 0) continue;
     target[key] = source[key];
   }
+
   return target;
 }
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -67,6 +95,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -78,6 +107,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -91,12 +121,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -104,6 +137,8 @@ function _asyncToGenerator(fn) {
 
 const path = require("path");
 
+const baseIgnoredInlineRequires = ["React", "react", "react-native"];
+
 function calcTransformerOptions(_x, _x2, _x3, _x4, _x5) {
   return _calcTransformerOptions.apply(this, arguments);
 }
@@ -123,48 +158,54 @@ function _calcTransformerOptions() {
       inlineRequires: false,
       inlinePlatform: true,
       minify: options.minify,
-      platform: options.platform
+      platform: options.platform,
+      runtimeBytecodeVersion: options.runtimeBytecodeVersion,
+      unstable_transformProfile: options.unstable_transformProfile
     }; // When we're processing scripts, we don't need to calculate any
     // inlineRequires information, since scripts by definition don't have
     // requires().
 
     if (options.type === "script") {
-      return _objectSpread({}, baseOptions, {
-        type: "script"
-      });
+      return _objectSpread(
+        _objectSpread({}, baseOptions),
+        {},
+        {
+          type: "script"
+        }
+      );
     }
 
-    const getDependencies =
-      /*#__PURE__*/
-      (function() {
-        var _ref = _asyncToGenerator(function*(path) {
-          const _ref2 = yield deltaBundler.buildGraph([path], {
-              resolve: yield getResolveDependencyFn(bundler, options.platform),
-              transform: yield getTransformFn(
-                [path],
-                bundler,
-                deltaBundler,
-                config,
-                _objectSpread({}, options, {
-                  minify: false
-                })
-              ),
-              onProgress: null,
-              experimentalImportBundleSupport:
-                config.transformer.experimentalImportBundleSupport,
-              shallow: false
-            }),
-            dependencies = _ref2.dependencies;
-
-          return Array.from(dependencies.keys());
+    const getDependencies = /*#__PURE__*/ (function() {
+      var _ref = _asyncToGenerator(function*(path) {
+        const dependencies = yield deltaBundler.getDependencies([path], {
+          resolve: yield getResolveDependencyFn(bundler, options.platform),
+          transform: yield getTransformFn(
+            [path],
+            bundler,
+            deltaBundler,
+            config,
+            _objectSpread(
+              _objectSpread({}, options),
+              {},
+              {
+                minify: false
+              }
+            )
+          ),
+          onProgress: null,
+          experimentalImportBundleSupport:
+            config.transformer.experimentalImportBundleSupport,
+          shallow: false
         });
+        return Array.from(dependencies.keys());
+      });
 
-        return function getDependencies(_x13) {
-          return _ref.apply(this, arguments);
-        };
-      })();
+      return function getDependencies(_x13) {
+        return _ref.apply(this, arguments);
+      };
+    })();
 
-    const _ref3 = yield config.transformer.getTransformOptions(
+    const _yield$config$transfo = yield config.transformer.getTransformOptions(
         entryFiles,
         {
           dev: options.dev,
@@ -173,22 +214,28 @@ function _calcTransformerOptions() {
         },
         getDependencies
       ),
-      transform = _ref3.transform;
-
-    return _objectSpread({}, baseOptions, {
-      inlineRequires: transform.inlineRequires || false,
-      experimentalImportSupport: transform.experimentalImportSupport || false,
-      unstable_disableES6Transforms:
-        transform.unstable_disableES6Transforms || false,
-      type: "module"
-    });
+      transform = _yield$config$transfo.transform;
+
+    return _objectSpread(
+      _objectSpread({}, baseOptions),
+      {},
+      {
+        inlineRequires: transform.inlineRequires || false,
+        experimentalImportSupport: transform.experimentalImportSupport || false,
+        unstable_disableES6Transforms:
+          transform.unstable_disableES6Transforms || false,
+        nonInlinedRequires:
+          transform.nonInlinedRequires || baseIgnoredInlineRequires,
+        type: "module"
+      }
+    );
   });
   return _calcTransformerOptions.apply(this, arguments);
 }
 
-function removeInlineRequiresBlacklistFromOptions(path, inlineRequires) {
+function removeInlineRequiresBlockListFromOptions(path, inlineRequires) {
   if (typeof inlineRequires === "object") {
-    return !(path in inlineRequires.blacklist);
+    return !(path in inlineRequires.blockList);
   }
 
   return inlineRequires;
@@ -206,41 +253,44 @@ function _getTransformFn() {
     config,
     options
   ) {
-    const _ref4 = yield calcTransformerOptions(
+    const _yield$calcTransforme = yield calcTransformerOptions(
         entryFiles,
         bundler,
         deltaBundler,
         config,
         options
       ),
-      inlineRequires = _ref4.inlineRequires,
-      transformOptions = _objectWithoutProperties(_ref4, ["inlineRequires"]);
-
-    return (
-      /*#__PURE__*/
-      (function() {
-        var _ref5 = _asyncToGenerator(function*(path) {
-          return yield bundler.transformFile(
-            path,
-            _objectSpread({}, transformOptions, {
+      inlineRequires = _yield$calcTransforme.inlineRequires,
+      transformOptions = _objectWithoutProperties(_yield$calcTransforme, [
+        "inlineRequires"
+      ]);
+
+    return /*#__PURE__*/ (function() {
+      var _ref2 = _asyncToGenerator(function*(path) {
+        return yield bundler.transformFile(
+          path,
+          _objectSpread(
+            _objectSpread({}, transformOptions),
+            {},
+            {
               type: getType(
                 transformOptions.type,
                 path,
                 config.resolver.assetExts
               ),
-              inlineRequires: removeInlineRequiresBlacklistFromOptions(
+              inlineRequires: removeInlineRequiresBlockListFromOptions(
                 path,
                 inlineRequires
               )
-            })
-          );
-        });
+            }
+          )
+        );
+      });
 
-        return function(_x14) {
-          return _ref5.apply(this, arguments);
-        };
-      })()
-    );
+      return function(_x14) {
+        return _ref2.apply(this, arguments);
+      };
+    })();
   });
   return _getTransformFn.apply(this, arguments);
 }
diff --git a/node_modules/metro/src/lib/transformHelpers.js.flow b/node_modules/metro/src/lib/transformHelpers.js.flow
index f8ea1cc..ecc4c00 100644
--- a/node_modules/metro/src/lib/transformHelpers.js.flow
+++ b/node_modules/metro/src/lib/transformHelpers.js.flow
@@ -15,16 +15,17 @@ const path = require('path');
 import type Bundler from '../Bundler';
 import type {TransformOptions} from '../DeltaBundler/Worker';
 import type DeltaBundler, {TransformFn} from '../DeltaBundler';
-import type {Type} from '../JSTransformer/worker';
 import type {ConfigT} from 'metro-config/src/configTypes.flow';
+import type {Type} from 'metro-transform-worker';
 
-type InlineRequiresRaw = {+blacklist: {[string]: true}} | boolean;
+type InlineRequiresRaw = {+blockList: {[string]: true, ...}, ...} | boolean;
 
 export type TransformInputOptions = $Diff<
   TransformOptions,
   {
     inlinePlatform: boolean,
     inlineRequires: boolean,
+    ...
   },
 >;
 
@@ -33,6 +34,8 @@ type TransformOptionsWithRawInlines = {|
   +inlineRequires: InlineRequiresRaw,
 |};
 
+const baseIgnoredInlineRequires = ['React', 'react', 'react-native'];
+
 async function calcTransformerOptions(
   entryFiles: $ReadOnlyArray<string>,
   bundler: Bundler,
@@ -48,6 +51,8 @@ async function calcTransformerOptions(
     inlinePlatform: true,
     minify: options.minify,
     platform: options.platform,
+    runtimeBytecodeVersion: options.runtimeBytecodeVersion,
+    unstable_transformProfile: options.unstable_transformProfile,
   };
 
   // When we're processing scripts, we don't need to calculate any
@@ -61,7 +66,7 @@ async function calcTransformerOptions(
   }
 
   const getDependencies = async (path: string) => {
-    const {dependencies} = await deltaBundler.buildGraph([path], {
+    const dependencies = await deltaBundler.getDependencies([path], {
       resolve: await getResolveDependencyFn(bundler, options.platform),
       transform: await getTransformFn([path], bundler, deltaBundler, config, {
         ...options,
@@ -88,16 +93,18 @@ async function calcTransformerOptions(
     experimentalImportSupport: transform.experimentalImportSupport || false,
     unstable_disableES6Transforms:
       transform.unstable_disableES6Transforms || false,
+    nonInlinedRequires:
+      transform.nonInlinedRequires || baseIgnoredInlineRequires,
     type: 'module',
   };
 }
 
-function removeInlineRequiresBlacklistFromOptions(
+function removeInlineRequiresBlockListFromOptions(
   path: string,
   inlineRequires: InlineRequiresRaw,
 ): boolean {
   if (typeof inlineRequires === 'object') {
-    return !(path in inlineRequires.blacklist);
+    return !(path in inlineRequires.blockList);
   }
 
   return inlineRequires;
@@ -122,7 +129,7 @@ async function getTransformFn(
     return await bundler.transformFile(path, {
       ...transformOptions,
       type: getType(transformOptions.type, path, config.resolver.assetExts),
-      inlineRequires: removeInlineRequiresBlacklistFromOptions(
+      inlineRequires: removeInlineRequiresBlockListFromOptions(
         path,
         inlineRequires,
       ),
@@ -150,7 +157,7 @@ async function getResolveDependencyFn(
   bundler: Bundler,
   platform: ?string,
 ): Promise<(from: string, to: string) => string> {
-  const dependencyGraph = await bundler.getDependencyGraph();
+  const dependencyGraph = await await bundler.getDependencyGraph();
 
   return (from: string, to: string) =>
     dependencyGraph.resolveDependency(from, to, platform);
diff --git a/node_modules/metro/src/node-haste/AssetResolutionCache.js b/node_modules/metro/src/node-haste/AssetResolutionCache.js
deleted file mode 100644
index 5e984b3..0000000
--- a/node_modules/metro/src/node-haste/AssetResolutionCache.js
+++ /dev/null
@@ -1,130 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-function _defineProperty(obj, key, value) {
-  if (key in obj) {
-    Object.defineProperty(obj, key, {
-      value: value,
-      enumerable: true,
-      configurable: true,
-      writable: true
-    });
-  } else {
-    obj[key] = value;
-  }
-  return obj;
-}
-
-const AssetPaths = require("./lib/AssetPaths");
-
-const MapWithDefaults = require("./lib/MapWithDefaults");
-
-/**
- * Lazily build an index of assets for the directories in which we're looking
- * for specific assets. For example if we're looking for `foo.png` in a `bar`
- * directory, we'll look at all the files there and identify all the assets
- * related to `foo.png`, for example `foo@2x.png` and `foo.ios.png`.
- */
-class AssetResolutionCache {
-  constructor(options) {
-    _defineProperty(this, "_findAssets", dirPath => {
-      const results = new Map();
-
-      const fileNames = this._opts.getDirFiles(dirPath);
-
-      for (let i = 0; i < fileNames.length; ++i) {
-        const fileName = fileNames[i];
-        const assetData = AssetPaths.tryParse(fileName, this._opts.platforms);
-
-        if (assetData == null || !this._isValidAsset(assetData)) {
-          continue;
-        }
-
-        getWithDefaultArray(results, assetData.assetName).push({
-          fileName,
-          platform: assetData.platform
-        });
-
-        if (assetData.platform) {
-          const assetNameWithPlatform = `${assetData.name}.${
-            assetData.platform
-          }.${assetData.type}`;
-          getWithDefaultArray(results, assetNameWithPlatform).push({
-            fileName,
-            platform: null
-          });
-        }
-      }
-
-      return results;
-    });
-
-    this._assetsByDirPath = new MapWithDefaults(this._findAssets);
-    this._opts = options;
-  }
-  /**
-   * The cache needs to be emptied if any file changes. This could be made more
-   * selective if performance demands it: for example, we could clear
-   * exclusively the directories in which files have changed. But that'd be
-   * more error-prone.
-   */
-
-  clear() {
-    this._assetsByDirPath.clear();
-  }
-  /**
-   * Get the file paths of all the variants (resolutions, platforms, etc.) of a
-   * particular asset name, only looking at a specific directory. If needed this
-   * function could be changed to return pre-parsed information about the assets
-   * such as the resolution.
-   */
-
-  resolve(dirPath, assetName, platform) {
-    const results = this._assetsByDirPath.get(dirPath);
-
-    const assets = results.get(assetName);
-
-    if (assets == null) {
-      return null;
-    }
-
-    return assets
-      .filter(asset => asset.platform == null || asset.platform === platform)
-      .map(asset => asset.fileName);
-  }
-  /**
-   * Build an index of assets for a particular directory. Several file can
-   * fulfill a single asset name, for example the different resolutions or
-   * platforms: ex. `foo.png` could contain `foo@2x.png`, `foo.ios.js`, etc.
-   */
-
-  _isValidAsset(assetData) {
-    return this._opts.assetExtensions.has(assetData.type);
-  }
-}
-/**
- * Used instead of `MapWithDefaults` so that we don't create empty arrays
- * anymore once the index is built.
- */
-
-function getWithDefaultArray(map, key) {
-  let el = map.get(key);
-
-  if (el != null) {
-    return el;
-  }
-
-  el = [];
-  map.set(key, el);
-  return el;
-}
-
-module.exports = AssetResolutionCache;
diff --git a/node_modules/metro/src/node-haste/AssetResolutionCache.js.flow b/node_modules/metro/src/node-haste/AssetResolutionCache.js.flow
deleted file mode 100644
index aad2862..0000000
--- a/node_modules/metro/src/node-haste/AssetResolutionCache.js.flow
+++ /dev/null
@@ -1,142 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-const AssetPaths = require('./lib/AssetPaths');
-const MapWithDefaults = require('./lib/MapWithDefaults');
-
-import type {AssetPath} from './lib/AssetPaths';
-
-type Options = {|
-  /**
-   * Files that don't match these extensions are discarded. Assets always need
-   * an extension.
-   */
-  +assetExtensions: Set<string>,
-  /**
-   * This should return all the files of the specified directory.
-   */
-  +getDirFiles: (dirPath: string) => $ReadOnlyArray<string>,
-  /**
-   * All the valid platforms so as to support platform extensions, ex.
-   * `foo.ios.png`. A platform that's no in this set will be considered part of
-   * the asset name. Ex. `foo.smth.png`, if `smth` is not a valid platform, will
-   * be resolved by its full name `foo.smth.png`.
-   */
-  +platforms: Set<string>,
-|};
-
-type AssetInfo = {|platform: ?string, fileName: string|};
-type InfoByAssetName = Map<string, Array<AssetInfo>>;
-
-/**
- * Lazily build an index of assets for the directories in which we're looking
- * for specific assets. For example if we're looking for `foo.png` in a `bar`
- * directory, we'll look at all the files there and identify all the assets
- * related to `foo.png`, for example `foo@2x.png` and `foo.ios.png`.
- */
-class AssetResolutionCache {
-  _assetsByDirPath: MapWithDefaults<string, InfoByAssetName>;
-  _opts: Options;
-
-  constructor(options: Options) {
-    this._assetsByDirPath = new MapWithDefaults(this._findAssets);
-    this._opts = options;
-  }
-
-  /**
-   * The cache needs to be emptied if any file changes. This could be made more
-   * selective if performance demands it: for example, we could clear
-   * exclusively the directories in which files have changed. But that'd be
-   * more error-prone.
-   */
-  clear() {
-    this._assetsByDirPath.clear();
-  }
-
-  /**
-   * Get the file paths of all the variants (resolutions, platforms, etc.) of a
-   * particular asset name, only looking at a specific directory. If needed this
-   * function could be changed to return pre-parsed information about the assets
-   * such as the resolution.
-   */
-  resolve(
-    dirPath: string,
-    assetName: string,
-    platform: string | null,
-  ): ?$ReadOnlyArray<string> {
-    const results = this._assetsByDirPath.get(dirPath);
-    const assets = results.get(assetName);
-    if (assets == null) {
-      return null;
-    }
-    return assets
-      .filter(
-        (asset: AssetInfo) =>
-          asset.platform == null || asset.platform === platform,
-      )
-      .map((asset: AssetInfo) => asset.fileName);
-  }
-
-  /**
-   * Build an index of assets for a particular directory. Several file can
-   * fulfill a single asset name, for example the different resolutions or
-   * platforms: ex. `foo.png` could contain `foo@2x.png`, `foo.ios.js`, etc.
-   */
-  _findAssets = (dirPath: string) => {
-    const results = new Map();
-    const fileNames = this._opts.getDirFiles(dirPath);
-    for (let i = 0; i < fileNames.length; ++i) {
-      const fileName = fileNames[i];
-      const assetData = AssetPaths.tryParse(fileName, this._opts.platforms);
-      if (assetData == null || !this._isValidAsset(assetData)) {
-        continue;
-      }
-      getWithDefaultArray(results, assetData.assetName).push({
-        fileName,
-        platform: assetData.platform,
-      });
-      if (assetData.platform) {
-        const assetNameWithPlatform = `${assetData.name}.${
-          assetData.platform
-        }.${assetData.type}`;
-        getWithDefaultArray(results, assetNameWithPlatform).push({
-          fileName,
-          platform: null,
-        });
-      }
-    }
-    return results;
-  };
-
-  _isValidAsset(assetData: AssetPath): boolean {
-    return this._opts.assetExtensions.has(assetData.type);
-  }
-}
-
-/**
- * Used instead of `MapWithDefaults` so that we don't create empty arrays
- * anymore once the index is built.
- */
-function getWithDefaultArray<TK, TV>(
-  map: Map<TK, Array<TV>>,
-  key: TK,
-): Array<TV> {
-  let el = map.get(key);
-  if (el != null) {
-    return el;
-  }
-  el = [];
-  map.set(key, el);
-  return el;
-}
-
-module.exports = AssetResolutionCache;
diff --git a/node_modules/metro/src/node-haste/DependencyGraph.js b/node_modules/metro/src/node-haste/DependencyGraph.js
index cdd1b81..643ae07 100644
--- a/node_modules/metro/src/node-haste/DependencyGraph.js
+++ b/node_modules/metro/src/node-haste/DependencyGraph.js
@@ -9,6 +9,48 @@
  */
 "use strict";
 
+function _toConsumableArray(arr) {
+  return (
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
+  );
+}
+
+function _nonIterableSpread() {
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
+}
+
+function _iterableToArray(iter) {
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
+    return Array.from(iter);
+}
+
+function _arrayWithoutHoles(arr) {
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
 function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
   try {
     var info = gen[key](arg);
@@ -17,6 +59,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,12 +73,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -52,12 +98,21 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
-const AssetResolutionCache = require("./AssetResolutionCache");
+const _require = require("metro-core"),
+  AmbiguousModuleResolutionError = _require.AmbiguousModuleResolutionError;
 
-const DependencyGraphHelpers = require("./DependencyGraph/DependencyGraphHelpers");
+const DuplicateHasteCandidatesError = require("jest-haste-map").ModuleMap
+  .DuplicateHasteCandidatesError;
+
+const _require2 = require("metro-resolver"),
+  InvalidPackageError = _require2.InvalidPackageError;
+
+const _require3 = require("metro-core"),
+  PackageResolutionError = _require3.PackageResolutionError;
 
 const JestHasteMap = require("jest-haste-map");
 
@@ -65,27 +120,39 @@ const Module = require("./Module");
 
 const ModuleCache = require("./ModuleCache");
 
-const ResolutionRequest = require("./DependencyGraph/ResolutionRequest");
+const ci = require("ci-info");
 
 const fs = require("fs");
 
 const path = require("path");
 
-const _require = require("./DependencyGraph/ModuleResolution"),
-  ModuleResolver = _require.ModuleResolver;
+const _require4 = require("./DependencyGraph/ModuleResolution"),
+  ModuleResolver = _require4.ModuleResolver;
 
-const _require2 = require("events"),
-  EventEmitter = _require2.EventEmitter;
+const _require5 = require("events"),
+  EventEmitter = _require5.EventEmitter;
 
-const _require3 = require("metro-core"),
-  _require3$Logger = _require3.Logger,
-  createActionStartEntry = _require3$Logger.createActionStartEntry,
-  createActionEndEntry = _require3$Logger.createActionEndEntry,
-  log = _require3$Logger.log;
+const _require6 = require("metro-core"),
+  _require6$Logger = _require6.Logger,
+  createActionStartEntry = _require6$Logger.createActionStartEntry,
+  createActionEndEntry = _require6$Logger.createActionEndEntry,
+  log = _require6$Logger.log;
+
+const JEST_HASTE_MAP_CACHE_BREAKER = 5;
 
-const JEST_HASTE_MAP_CACHE_BREAKER = 4;
+function getOrCreate(map, field) {
+  let subMap = map.get(field);
+
+  if (!subMap) {
+    subMap = new Map();
+    map.set(field, subMap);
+  }
+
+  return subMap;
+}
 
 class DependencyGraph extends EventEmitter {
+  // $FlowFixMe[value-as-type]
   constructor(_ref) {
     let config = _ref.config,
       haste = _ref.haste,
@@ -98,35 +165,59 @@ class DependencyGraph extends EventEmitter {
     });
 
     this._config = config;
-    this._assetResolutionCache = new AssetResolutionCache({
-      assetExtensions: new Set(config.resolver.assetExts),
-      getDirFiles: dirPath => fs.readdirSync(dirPath),
-      platforms: new Set(config.resolver.platforms)
-    });
     this._haste = haste;
     this._hasteFS = initialHasteFS;
     this._moduleMap = initialModuleMap;
-    this._helpers = new DependencyGraphHelpers({
-      assetExts: config.resolver.assetExts
-    });
+    this._assetExtensions = new Set(
+      config.resolver.assetExts.map(asset => "." + asset)
+    );
 
     this._haste.on("change", this._onHasteChange.bind(this));
 
+    this._resolutionCache = new Map();
     this._moduleCache = this._createModuleCache();
 
     this._createModuleResolver();
   }
 
-  static _createHaste(config) {
-    return new JestHasteMap({
+  static _getIgnorePattern(config) {
+    /*
+      For now we support both blockList and blacklistRE options
+    */
+    const _config$resolver = config.resolver,
+      blockList = _config$resolver.blockList,
+      blacklistRE = _config$resolver.blacklistRE;
+
+    const combine = regexes =>
+      new RegExp(
+        regexes
+          .map(regex => "(" + regex.source.replace(/\//g, path.sep) + ")")
+          .join("|")
+      ); // If `blacklistRE` is set - use it,
+    // if `blockList` is set - use it
+
+    const ignorePattern = blacklistRE || blockList; // If neither option has been set, use default pattern
+
+    if (!ignorePattern) {
+      return / ^/;
+    } // If ignorePattern is an array, merge it into one
+
+    if (Array.isArray(ignorePattern)) {
+      return combine(ignorePattern);
+    }
+
+    return ignorePattern;
+  } // $FlowFixMe[value-as-type]
+
+  static _createHaste(config, watch) {
+    const haste = new JestHasteMap({
       cacheDirectory: config.hasteMapCacheDirectory,
-      computeDependencies: false,
+      dependencyExtractor: config.resolver.dependencyExtractor,
       computeSha1: true,
       extensions: config.resolver.sourceExts.concat(config.resolver.assetExts),
       forceNodeFilesystemAPI: !config.resolver.useWatchman,
       hasteImplModulePath: config.resolver.hasteImplModulePath,
-      ignorePattern: config.resolver.blacklistRE || / ^/,
-      mapper: config.resolver.virtualMapper,
+      ignorePattern: this._getIgnorePattern(config),
       maxWorkers: config.maxWorkers,
       mocksPattern: "",
       name: "metro-" + JEST_HASTE_MAP_CACHE_BREAKER,
@@ -137,24 +228,34 @@ class DependencyGraph extends EventEmitter {
       roots: config.watchFolders,
       throwOnModuleCollision: true,
       useWatchman: config.resolver.useWatchman,
-      watch: true
-    });
+      watch: watch == null ? !ci.isCI : watch
+    }); // We can have a lot of graphs listening to Haste for changes.
+    // Bump this up to silence the max listeners EventEmitter warning.
+
+    haste.setMaxListeners(1000);
+    return haste;
   }
 
-  static load(config) {
+  static load(config, options) {
     return _asyncToGenerator(function*() {
       const initializingMetroLogEntry = log(
         createActionStartEntry("Initializing Metro")
       );
       config.reporter.update({
-        type: "dep_graph_loading"
+        type: "dep_graph_loading",
+        hasReducedPerformance: options
+          ? Boolean(options.hasReducedPerformance)
+          : false
       });
 
-      const haste = DependencyGraph._createHaste(config);
+      const haste = DependencyGraph._createHaste(
+        config,
+        options && options.watch
+      );
 
-      const _ref2 = yield haste.build(),
-        hasteFS = _ref2.hasteFS,
-        moduleMap = _ref2.moduleMap;
+      const _yield$haste$build = yield haste.build(),
+        hasteFS = _yield$haste$build.hasteFS,
+        moduleMap = _yield$haste$build.moduleMap;
 
       log(createActionEndEntry(initializingMetroLogEntry));
       config.reporter.update({
@@ -187,18 +288,16 @@ class DependencyGraph extends EventEmitter {
     return null;
   }
 
-  _onHasteChange(_ref3) {
-    let eventsQueue = _ref3.eventsQueue,
-      hasteFS = _ref3.hasteFS,
-      moduleMap = _ref3.moduleMap;
+  _onHasteChange(_ref2) {
+    let eventsQueue = _ref2.eventsQueue,
+      hasteFS = _ref2.hasteFS,
+      moduleMap = _ref2.moduleMap;
     this._hasteFS = hasteFS;
-
-    this._assetResolutionCache.clear();
-
+    this._resolutionCache = new Map();
     this._moduleMap = moduleMap;
-    eventsQueue.forEach(_ref4 => {
-      let type = _ref4.type,
-        filePath = _ref4.filePath;
+    eventsQueue.forEach(_ref3 => {
+      let type = _ref3.type,
+        filePath = _ref3.filePath;
       return this._moduleCache.processFileChange(type, filePath);
     });
 
@@ -218,14 +317,26 @@ class DependencyGraph extends EventEmitter {
       },
       doesFileExist: this._doesFileExist,
       extraNodeModules: this._config.resolver.extraNodeModules,
-      isAssetFile: filePath => this._helpers.isAssetFile(filePath),
+      isAssetFile: file => this._assetExtensions.has(path.extname(file)),
       mainFields: this._config.resolver.resolverMainFields,
       moduleCache: this._moduleCache,
       moduleMap: this._moduleMap,
+      nodeModulesPaths: this._config.resolver.nodeModulesPaths,
       preferNativePlatform: true,
       projectRoot: this._config.projectRoot,
-      resolveAsset: (dirPath, assetName, platform) =>
-        this._assetResolutionCache.resolve(dirPath, assetName, platform),
+      resolveAsset: (dirPath, assetName, extension) => {
+        const basePath = dirPath + path.sep + assetName;
+        const assets = [basePath + extension]
+          .concat(
+            _toConsumableArray(
+              this._config.resolver.assetResolutions.map(
+                resolution => basePath + "@" + resolution + "x" + extension
+              )
+            )
+          )
+          .filter(candidate => this._hasteFS.exists(candidate));
+        return assets.length ? assets : null;
+      },
       resolveRequest: this._config.resolver.resolveRequest,
       sourceExts: this._config.resolver.sourceExts
     });
@@ -255,13 +366,14 @@ class DependencyGraph extends EventEmitter {
     const sha1 = this._hasteFS.getSha1(resolvedPath);
 
     if (!sha1) {
-      throw new ReferenceError(
-        `SHA-1 for file ${filename} (${resolvedPath}) is not computed`
-      );
+      throw new ReferenceError(`SHA-1 for file ${filename} (${resolvedPath}) is not computed.
+         Potential causes:
+           1) You have symlinks in your project - watchman does not follow symlinks.
+           2) Check \`blockList\` in your metro.config.js and make sure it isn't excluding the file path.`);
     }
 
     return sha1;
-  }
+  } // $FlowFixMe[value-as-type]
 
   getWatcher() {
     return this._haste;
@@ -272,14 +384,68 @@ class DependencyGraph extends EventEmitter {
   }
 
   resolveDependency(from, to, platform) {
-    const req = new ResolutionRequest({
-      moduleResolver: this._moduleResolver,
-      entryPath: from,
-      helpers: this._helpers,
-      platform: platform || null,
-      moduleCache: this._moduleCache
-    });
-    return req.resolveDependency(this._moduleCache.getModule(from), to).path;
+    let _ref4 =
+        arguments.length > 3 && arguments[3] !== undefined
+          ? arguments[3]
+          : {
+              assumeFlatNodeModules: false
+            },
+      assumeFlatNodeModules = _ref4.assumeFlatNodeModules;
+
+    const isPath =
+      to.includes("/") ||
+      to === "." ||
+      to === ".." ||
+      from.includes(path.sep + "node_modules" + path.sep);
+    const mapByDirectory = getOrCreate(
+      this._resolutionCache,
+      isPath ? path.dirname(from) : ""
+    );
+    let mapByPlatform = getOrCreate(mapByDirectory, to);
+    let modulePath = mapByPlatform.get(platform);
+
+    if (!modulePath) {
+      modulePath = this._moduleMap.getModule(to, platform, true);
+    }
+
+    if (!modulePath) {
+      try {
+        modulePath = this._moduleResolver.resolveDependency(
+          this._moduleCache.getModule(from),
+          to,
+          true,
+          platform
+        ).path; // If we cannot assume that only one node_modules folder exists in the project,
+        // we need to cache packages by directory instead of globally.
+
+        if (
+          !assumeFlatNodeModules &&
+          modulePath.includes(path.sep + "node_modules" + path.sep)
+        ) {
+          mapByPlatform = getOrCreate(
+            getOrCreate(this._resolutionCache, path.dirname(from)),
+            to
+          );
+        }
+      } catch (error) {
+        if (error instanceof DuplicateHasteCandidatesError) {
+          throw new AmbiguousModuleResolutionError(from, error);
+        }
+
+        if (error instanceof InvalidPackageError) {
+          throw new PackageResolutionError({
+            packageError: error,
+            originModulePath: from,
+            targetModuleName: to
+          });
+        }
+
+        throw error;
+      }
+    }
+
+    mapByPlatform.set(platform, modulePath);
+    return modulePath;
   }
 
   getHasteName(filePath) {
@@ -291,6 +457,10 @@ class DependencyGraph extends EventEmitter {
 
     return path.relative(this._config.projectRoot, filePath);
   }
+
+  getDependencies(filePath) {
+    return this._hasteFS.getDependencies(filePath);
+  }
 }
 
 module.exports = DependencyGraph;
diff --git a/node_modules/metro/src/node-haste/DependencyGraph.js.flow b/node_modules/metro/src/node-haste/DependencyGraph.js.flow
index 15c2da8..87cdec6 100644
--- a/node_modules/metro/src/node-haste/DependencyGraph.js.flow
+++ b/node_modules/metro/src/node-haste/DependencyGraph.js.flow
@@ -10,13 +10,16 @@
 
 'use strict';
 
-const AssetResolutionCache = require('./AssetResolutionCache');
-const DependencyGraphHelpers = require('./DependencyGraph/DependencyGraphHelpers');
+const {AmbiguousModuleResolutionError} = require('metro-core');
+const {DuplicateHasteCandidatesError} = require('jest-haste-map').ModuleMap;
+const {InvalidPackageError} = require('metro-resolver');
+const {PackageResolutionError} = require('metro-core');
+
 const JestHasteMap = require('jest-haste-map');
 const Module = require('./Module');
 const ModuleCache = require('./ModuleCache');
-const ResolutionRequest = require('./DependencyGraph/ResolutionRequest');
 
+const ci = require('ci-info');
 const fs = require('fs');
 const path = require('path');
 
@@ -31,17 +34,30 @@ import type Package from './Package';
 import type {HasteFS} from './types';
 import type {ConfigT} from 'metro-config/src/configTypes.flow';
 
-const JEST_HASTE_MAP_CACHE_BREAKER = 4;
+const JEST_HASTE_MAP_CACHE_BREAKER = 5;
+
+function getOrCreate<T>(
+  map: Map<string, Map<string, T>>,
+  field,
+): Map<string, T> {
+  let subMap = map.get(field);
+  if (!subMap) {
+    subMap = new Map();
+    map.set(field, subMap);
+  }
+  return subMap;
+}
 
 class DependencyGraph extends EventEmitter {
-  _assetResolutionCache: AssetResolutionCache;
+  _assetExtensions: Set<string>;
   _config: ConfigT;
+  // $FlowFixMe[value-as-type]
   _haste: JestHasteMap;
   _hasteFS: HasteFS;
-  _helpers: DependencyGraphHelpers;
   _moduleCache: ModuleCache;
   _moduleMap: ModuleMap;
   _moduleResolver: ModuleResolver<Module, Package>;
+  _resolutionCache: Map<string, Map<string, Map<string, string>>>;
 
   constructor({
     config,
@@ -50,38 +66,65 @@ class DependencyGraph extends EventEmitter {
     initialModuleMap,
   }: {|
     +config: ConfigT,
+    // $FlowFixMe[value-as-type]
     +haste: JestHasteMap,
     +initialHasteFS: HasteFS,
     +initialModuleMap: ModuleMap,
   |}) {
     super();
     this._config = config;
-    this._assetResolutionCache = new AssetResolutionCache({
-      assetExtensions: new Set(config.resolver.assetExts),
-      getDirFiles: (dirPath: string) => fs.readdirSync(dirPath),
-      platforms: new Set(config.resolver.platforms),
-    });
     this._haste = haste;
     this._hasteFS = initialHasteFS;
     this._moduleMap = initialModuleMap;
-    this._helpers = new DependencyGraphHelpers({
-      assetExts: config.resolver.assetExts,
-    });
+    this._assetExtensions = new Set(
+      config.resolver.assetExts.map(asset => '.' + asset),
+    );
     this._haste.on('change', this._onHasteChange.bind(this));
+    this._resolutionCache = new Map();
     this._moduleCache = this._createModuleCache();
     this._createModuleResolver();
   }
 
-  static _createHaste(config: ConfigT): JestHasteMap {
-    return new JestHasteMap({
+  static _getIgnorePattern(config: ConfigT): RegExp {
+    /*
+      For now we support both blockList and blacklistRE options
+    */
+    const {blockList, blacklistRE} = config.resolver;
+
+    const combine = regexes =>
+      new RegExp(
+        regexes
+          .map(regex => '(' + regex.source.replace(/\//g, path.sep) + ')')
+          .join('|'),
+      );
+
+    // If `blacklistRE` is set - use it,
+    // if `blockList` is set - use it
+    const ignorePattern = blacklistRE || blockList;
+
+    // If neither option has been set, use default pattern
+    if (!ignorePattern) {
+      return / ^/;
+    }
+
+    // If ignorePattern is an array, merge it into one
+    if (Array.isArray(ignorePattern)) {
+      return combine(ignorePattern);
+    }
+
+    return ignorePattern;
+  }
+
+  // $FlowFixMe[value-as-type]
+  static _createHaste(config: ConfigT, watch?: boolean): JestHasteMap {
+    const haste = new JestHasteMap({
       cacheDirectory: config.hasteMapCacheDirectory,
-      computeDependencies: false,
+      dependencyExtractor: config.resolver.dependencyExtractor,
       computeSha1: true,
       extensions: config.resolver.sourceExts.concat(config.resolver.assetExts),
       forceNodeFilesystemAPI: !config.resolver.useWatchman,
       hasteImplModulePath: config.resolver.hasteImplModulePath,
-      ignorePattern: config.resolver.blacklistRE || / ^/,
-      mapper: config.resolver.virtualMapper,
+      ignorePattern: this._getIgnorePattern(config),
       maxWorkers: config.maxWorkers,
       mocksPattern: '',
       name: 'metro-' + JEST_HASTE_MAP_CACHE_BREAKER,
@@ -92,17 +135,34 @@ class DependencyGraph extends EventEmitter {
       roots: config.watchFolders,
       throwOnModuleCollision: true,
       useWatchman: config.resolver.useWatchman,
-      watch: true,
+      watch: watch == null ? !ci.isCI : watch,
     });
+
+    // We can have a lot of graphs listening to Haste for changes.
+    // Bump this up to silence the max listeners EventEmitter warning.
+    haste.setMaxListeners(1000);
+
+    return haste;
   }
 
-  static async load(config: ConfigT): Promise<DependencyGraph> {
+  static async load(
+    config: ConfigT,
+    options?: {|+hasReducedPerformance?: boolean, +watch?: boolean|},
+  ): Promise<DependencyGraph> {
     const initializingMetroLogEntry = log(
       createActionStartEntry('Initializing Metro'),
     );
 
-    config.reporter.update({type: 'dep_graph_loading'});
-    const haste = DependencyGraph._createHaste(config);
+    config.reporter.update({
+      type: 'dep_graph_loading',
+      hasReducedPerformance: options
+        ? Boolean(options.hasReducedPerformance)
+        : false,
+    });
+    const haste = DependencyGraph._createHaste(
+      config,
+      options && options.watch,
+    );
     const {hasteFS, moduleMap} = await haste.build();
 
     log(createActionEndEntry(initializingMetroLogEntry));
@@ -132,7 +192,7 @@ class DependencyGraph extends EventEmitter {
 
   _onHasteChange({eventsQueue, hasteFS, moduleMap}) {
     this._hasteFS = hasteFS;
-    this._assetResolutionCache.clear();
+    this._resolutionCache = new Map();
     this._moduleMap = moduleMap;
     eventsQueue.forEach(({type, filePath}) =>
       this._moduleCache.processFileChange(type, filePath),
@@ -151,17 +211,23 @@ class DependencyGraph extends EventEmitter {
       },
       doesFileExist: this._doesFileExist,
       extraNodeModules: this._config.resolver.extraNodeModules,
-      isAssetFile: (filePath: string) => this._helpers.isAssetFile(filePath),
+      isAssetFile: file => this._assetExtensions.has(path.extname(file)),
       mainFields: this._config.resolver.resolverMainFields,
       moduleCache: this._moduleCache,
       moduleMap: this._moduleMap,
+      nodeModulesPaths: this._config.resolver.nodeModulesPaths,
       preferNativePlatform: true,
       projectRoot: this._config.projectRoot,
-      resolveAsset: (
-        dirPath: string,
-        assetName: string,
-        platform: null | string,
-      ) => this._assetResolutionCache.resolve(dirPath, assetName, platform),
+      resolveAsset: (dirPath: string, assetName: string, extension: string) => {
+        const basePath = dirPath + path.sep + assetName;
+        const assets = [
+          basePath + extension,
+          ...this._config.resolver.assetResolutions.map(
+            resolution => basePath + '@' + resolution + 'x' + extension,
+          ),
+        ].filter(candidate => this._hasteFS.exists(candidate));
+        return assets.length ? assets : null;
+      },
       resolveRequest: this._config.resolver.resolveRequest,
       sourceExts: this._config.resolver.sourceExts,
     });
@@ -194,14 +260,18 @@ class DependencyGraph extends EventEmitter {
 
     if (!sha1) {
       throw new ReferenceError(
-        `SHA-1 for file ${filename} (${resolvedPath}) is not computed`,
+        `SHA-1 for file ${filename} (${resolvedPath}) is not computed.
+         Potential causes:
+           1) You have symlinks in your project - watchman does not follow symlinks.
+           2) Check \`blockList\` in your metro.config.js and make sure it isn't excluding the file path.`,
       );
     }
 
     return sha1;
   }
 
-  getWatcher() {
+  // $FlowFixMe[value-as-type]
+  getWatcher(): JestHasteMap {
     return this._haste;
   }
 
@@ -209,16 +279,66 @@ class DependencyGraph extends EventEmitter {
     this._haste.end();
   }
 
-  resolveDependency(from: string, to: string, platform: ?string): string {
-    const req = new ResolutionRequest({
-      moduleResolver: this._moduleResolver,
-      entryPath: from,
-      helpers: this._helpers,
-      platform: platform || null,
-      moduleCache: this._moduleCache,
-    });
+  resolveDependency(
+    from: string,
+    to: string,
+    platform: string,
+    {assumeFlatNodeModules}: {assumeFlatNodeModules: boolean} = {
+      assumeFlatNodeModules: false,
+    },
+  ): string {
+    const isPath =
+      to.includes('/') ||
+      to === '.' ||
+      to === '..' ||
+      from.includes(path.sep + 'node_modules' + path.sep);
+    const mapByDirectory = getOrCreate(
+      this._resolutionCache,
+      isPath ? path.dirname(from) : '',
+    );
+    let mapByPlatform = getOrCreate(mapByDirectory, to);
+    let modulePath = mapByPlatform.get(platform);
+    if (!modulePath) {
+      modulePath = this._moduleMap.getModule(to, platform, true);
+    }
 
-    return req.resolveDependency(this._moduleCache.getModule(from), to).path;
+    if (!modulePath) {
+      try {
+        modulePath = this._moduleResolver.resolveDependency(
+          this._moduleCache.getModule(from),
+          to,
+          true,
+          platform,
+        ).path;
+
+        // If we cannot assume that only one node_modules folder exists in the project,
+        // we need to cache packages by directory instead of globally.
+        if (
+          !assumeFlatNodeModules &&
+          modulePath.includes(path.sep + 'node_modules' + path.sep)
+        ) {
+          mapByPlatform = getOrCreate(
+            getOrCreate(this._resolutionCache, path.dirname(from)),
+            to,
+          );
+        }
+      } catch (error) {
+        if (error instanceof DuplicateHasteCandidatesError) {
+          throw new AmbiguousModuleResolutionError(from, error);
+        }
+        if (error instanceof InvalidPackageError) {
+          throw new PackageResolutionError({
+            packageError: error,
+            originModulePath: from,
+            targetModuleName: to,
+          });
+        }
+        throw error;
+      }
+    }
+
+    mapByPlatform.set(platform, modulePath);
+    return modulePath;
   }
 
   _doesFileExist = (filePath: string): boolean => {
@@ -234,6 +354,10 @@ class DependencyGraph extends EventEmitter {
 
     return path.relative(this._config.projectRoot, filePath);
   }
+
+  getDependencies(filePath: string): Array<string> {
+    return this._hasteFS.getDependencies(filePath);
+  }
 }
 
 module.exports = DependencyGraph;
diff --git a/node_modules/metro/src/node-haste/DependencyGraph/DependencyGraphHelpers.js b/node_modules/metro/src/node-haste/DependencyGraph/DependencyGraphHelpers.js
deleted file mode 100644
index 7ad8795..0000000
--- a/node_modules/metro/src/node-haste/DependencyGraph/DependencyGraphHelpers.js
+++ /dev/null
@@ -1,35 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict
- * @format
- */
-"use strict";
-
-const path = require("path");
-
-const NODE_MODULES = path.sep + "node_modules" + path.sep;
-
-class DependencyGraphHelpers {
-  constructor(_ref) {
-    let assetExts = _ref.assetExts;
-    this._assetExts = new Set(assetExts);
-  }
-
-  isNodeModulesDir(file) {
-    return file.lastIndexOf(NODE_MODULES) !== -1;
-  }
-
-  isAssetFile(file) {
-    return this._assetExts.has(this.extname(file));
-  }
-
-  extname(name) {
-    return path.extname(name).substr(1);
-  }
-}
-
-module.exports = DependencyGraphHelpers;
diff --git a/node_modules/metro/src/node-haste/DependencyGraph/DependencyGraphHelpers.js.flow b/node_modules/metro/src/node-haste/DependencyGraph/DependencyGraphHelpers.js.flow
deleted file mode 100644
index 819c2c7..0000000
--- a/node_modules/metro/src/node-haste/DependencyGraph/DependencyGraphHelpers.js.flow
+++ /dev/null
@@ -1,37 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict
- * @format
- */
-
-'use strict';
-
-const path = require('path');
-
-const NODE_MODULES = path.sep + 'node_modules' + path.sep;
-
-class DependencyGraphHelpers {
-  _assetExts: Set<string>;
-
-  constructor({assetExts}: {+assetExts: $ReadOnlyArray<string>}) {
-    this._assetExts = new Set(assetExts);
-  }
-
-  isNodeModulesDir(file: string) {
-    return file.lastIndexOf(NODE_MODULES) !== -1;
-  }
-
-  isAssetFile(file: string) {
-    return this._assetExts.has(this.extname(file));
-  }
-
-  extname(name: string) {
-    return path.extname(name).substr(1);
-  }
-}
-
-module.exports = DependencyGraphHelpers;
diff --git a/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js b/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js
index 9c08336..5f32fc5 100644
--- a/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js
+++ b/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js
@@ -11,45 +11,82 @@
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
+}
+
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
   }
+
+  return keys;
 }
 
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -64,17 +101,23 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
 const Resolver = require("metro-resolver");
 
+const fs = require("fs");
+
 const invariant = require("invariant");
 
 const path = require("path");
 
 const util = require("util");
 
+const _require = require("@babel/code-frame"),
+  codeFrameColumns = _require.codeFrameColumns;
+
 class ModuleResolver {
   constructor(options) {
     _defineProperty(this, "_getPackageMainPath", packageJsonPath => {
@@ -109,6 +152,7 @@ class ModuleResolver {
           ); // Since the redirected path is still relative to the package root,
           // we have to transform it back to be module-relative (as it
           // originally was)
+          // $FlowFixMe[incompatible-type]
 
           if (redirectedPath !== false) {
             redirectedPath =
@@ -141,18 +185,22 @@ class ModuleResolver {
   resolveDependency(fromModule, moduleName, allowHaste, platform) {
     try {
       const result = Resolver.resolve(
-        _objectSpread({}, this._options, {
-          originModulePath: fromModule.path,
-          redirectModulePath: modulePath =>
-            this._redirectRequire(fromModule, modulePath),
-          allowHaste,
-          platform,
-          resolveHasteModule: name =>
-            this._options.moduleMap.getModule(name, platform, true),
-          resolveHastePackage: name =>
-            this._options.moduleMap.getPackage(name, platform, true),
-          getPackageMainPath: this._getPackageMainPath
-        }),
+        _objectSpread(
+          _objectSpread({}, this._options),
+          {},
+          {
+            originModulePath: fromModule.path,
+            redirectModulePath: modulePath =>
+              this._redirectRequire(fromModule, modulePath),
+            allowHaste,
+            platform,
+            resolveHasteModule: name =>
+              this._options.moduleMap.getModule(name, platform, true),
+            resolveHastePackage: name =>
+              this._options.moduleMap.getPackage(name, platform, true),
+            getPackageMainPath: this._getPackageMainPath
+          }
+        ),
         moduleName,
         platform
       );
@@ -161,7 +209,7 @@ class ModuleResolver {
       if (error instanceof Resolver.FailedToResolvePathError) {
         const candidates = error.candidates;
         throw new UnableToResolveError(
-          path.relative(this._options.projectRoot, fromModule.path),
+          fromModule.path,
           moduleName,
           [
             "\n\nNone of these files exist:",
@@ -184,17 +232,17 @@ class ModuleResolver {
           .concat(extraPaths);
         const hint = displayDirPaths.length ? " or in these directories:" : "";
         throw new UnableToResolveError(
-          path.relative(this._options.projectRoot, fromModule.path),
+          fromModule.path,
           moduleName,
           [`${moduleName} could not be found within the project${hint || "."}`]
             .concat(
               _toConsumableArray(
-                displayDirPaths.map(dirPath => `  ${path.dirname(dirPath)}`)
+                displayDirPaths.map(dirPath => `  ${dirPath}`)
               ),
               [
                 "\nIf you are sure the module exists, try these steps:",
                 " 1. Clear watchman watches: watchman watch-del-all",
-                " 2. Delete node_modules: rm -rf node_modules and run yarn install",
+                " 2. Delete node_modules and run yarn install",
                 " 3. Reset Metro's cache: yarn start --reset-cache",
                 " 4. Remove the cache: rm -rf /tmp/metro-*"
               ]
@@ -206,11 +254,11 @@ class ModuleResolver {
       throw error;
     }
   }
-
   /**
    * FIXME: get rid of this function and of the reliance on `TModule`
    * altogether, return strongly typed resolutions at the top-level instead.
    */
+
   _getFileResolvedModule(resolution) {
     switch (resolution.type) {
       case "sourceFile":
@@ -225,9 +273,9 @@ class ModuleResolver {
 
       case "empty":
         const moduleCache = this._options.moduleCache;
-        const module = moduleCache.getModule(ModuleResolver.EMPTY_MODULE);
-        invariant(module != null, "empty module is not available");
-        return module;
+        const module_ = moduleCache.getModule(ModuleResolver.EMPTY_MODULE);
+        invariant(module_ != null, "empty module is not available");
+        return module_;
 
       default:
         resolution.type;
@@ -282,11 +330,58 @@ class UnableToResolveError extends Error {
     super();
     this.originModulePath = originModulePath;
     this.targetModuleName = targetModuleName;
-    this.message = util.format(
-      "Unable to resolve module `%s` from `%s`: %s",
-      targetModuleName,
-      originModulePath,
-      message
+    const codeFrameMessage = this.buildCodeFrameMessage();
+    this.message =
+      util.format(
+        "Unable to resolve module %s from %s: %s",
+        targetModuleName,
+        originModulePath,
+        message
+      ) + (codeFrameMessage ? "\n" + codeFrameMessage : "");
+  }
+
+  buildCodeFrameMessage() {
+    let file;
+
+    try {
+      file = fs.readFileSync(this.originModulePath, "utf8");
+    } catch (error) {
+      if (error.code === "ENOENT") {
+        // We're probably dealing with a virtualised file system where
+        // `this.originModulePath` doesn't actually exist on disk.
+        // We can't show a code frame, but there's no need to let this I/O
+        // error shadow the original module resolution error.
+        return null;
+      }
+
+      throw error;
+    }
+
+    const lines = file.split("\n");
+    let lineNumber = 0;
+    let column = -1;
+
+    for (let line = 0; line < lines.length; line++) {
+      const columnLocation = lines[line].lastIndexOf(this.targetModuleName);
+
+      if (columnLocation >= 0) {
+        lineNumber = line;
+        column = columnLocation;
+        break;
+      }
+    }
+
+    return codeFrameColumns(
+      fs.readFileSync(this.originModulePath, "utf8"),
+      {
+        start: {
+          column: column + 1,
+          line: lineNumber + 1
+        }
+      },
+      {
+        forceColor: process.env.NODE_ENV !== "test"
+      }
     );
   }
 }
diff --git a/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js.flow b/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js.flow
index 1cbc5dd..5c5c633 100644
--- a/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js.flow
+++ b/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js.flow
@@ -12,11 +12,13 @@
 
 const Resolver = require('metro-resolver');
 
+const fs = require('fs');
 const invariant = require('invariant');
 const path = require('path');
 const util = require('util');
 
-import type {Moduleish, Packageish} from './ResolutionRequest';
+const {codeFrameColumns} = require('@babel/code-frame');
+
 import type {
   CustomResolver,
   DoesFileExist,
@@ -28,6 +30,22 @@ import type {
 
 export type DirExistsFn = (filePath: string) => boolean;
 
+export type Packageish = {
+  path: string,
+  redirectRequire(
+    toModuleName: string,
+    mainFields: $ReadOnlyArray<string>,
+  ): string | false,
+  getMain(mainFields: $ReadOnlyArray<string>): string,
+  ...
+};
+
+export type Moduleish = {
+  +path: string,
+  getPackage(): ?Packageish,
+  ...
+};
+
 /**
  * `jest-haste-map`'s interface for ModuleMap.
  */
@@ -42,6 +60,7 @@ export type ModuleMap = {
     platform: string | null,
     supportsNativePlatform: ?boolean,
   ): ?string,
+  ...
 };
 
 export type ModuleishCache<TModule, TPackage> = {
@@ -51,6 +70,7 @@ export type ModuleishCache<TModule, TPackage> = {
     supportsNativePlatform?: boolean,
   ): TPackage,
   getModule(path: string): TModule,
+  ...
 };
 
 type Options<TModule, TPackage> = {|
@@ -60,9 +80,10 @@ type Options<TModule, TPackage> = {|
   +isAssetFile: IsAssetFile,
   +mainFields: $ReadOnlyArray<string>,
   +moduleCache: ModuleishCache<TModule, TPackage>,
-  +projectRoot: string,
-  +preferNativePlatform: boolean,
   +moduleMap: ModuleMap,
+  +nodeModulesPaths: $ReadOnlyArray<string>,
+  +preferNativePlatform: boolean,
+  +projectRoot: string,
   +resolveAsset: ResolveAsset,
   +resolveRequest: ?CustomResolver,
   +sourceExts: $ReadOnlyArray<string>,
@@ -102,6 +123,7 @@ class ModuleResolver<TModule: Moduleish, TPackage: Packageish> {
           // Since the redirected path is still relative to the package root,
           // we have to transform it back to be module-relative (as it
           // originally was)
+          // $FlowFixMe[incompatible-type]
           if (redirectedPath !== false) {
             redirectedPath =
               './' +
@@ -159,7 +181,7 @@ class ModuleResolver<TModule: Moduleish, TPackage: Packageish> {
       if (error instanceof Resolver.FailedToResolvePathError) {
         const {candidates} = error;
         throw new UnableToResolveError(
-          path.relative(this._options.projectRoot, fromModule.path),
+          fromModule.path,
           moduleName,
           [
             '\n\nNone of these files exist:',
@@ -180,6 +202,7 @@ class ModuleResolver<TModule: Moduleish, TPackage: Packageish> {
           // $flowfixme these types are defined explicitly in FailedToResolveNameError but Flow refuses to recognize them here
           dirPaths: $ReadOnlyArray<string>,
           extraPaths: $ReadOnlyArray<string>,
+          ...
         } = error;
         const displayDirPaths = dirPaths
           .filter((dirPath: string) => this._options.dirExists(dirPath))
@@ -187,17 +210,16 @@ class ModuleResolver<TModule: Moduleish, TPackage: Packageish> {
           .concat(extraPaths);
 
         const hint = displayDirPaths.length ? ' or in these directories:' : '';
+
         throw new UnableToResolveError(
-          path.relative(this._options.projectRoot, fromModule.path),
+          fromModule.path,
           moduleName,
           [
             `${moduleName} could not be found within the project${hint || '.'}`,
-            ...displayDirPaths.map(
-              (dirPath: string) => `  ${path.dirname(dirPath)}`,
-            ),
+            ...displayDirPaths.map((dirPath: string) => `  ${dirPath}`),
             '\nIf you are sure the module exists, try these steps:',
             ' 1. Clear watchman watches: watchman watch-del-all',
-            ' 2. Delete node_modules: rm -rf node_modules and run yarn install',
+            ' 2. Delete node_modules and run yarn install',
             " 3. Reset Metro's cache: yarn start --reset-cache",
             ' 4. Remove the cache: rm -rf /tmp/metro-*',
           ].join('\n'),
@@ -228,9 +250,9 @@ class ModuleResolver<TModule: Moduleish, TPackage: Packageish> {
         return this._options.moduleCache.getModule(arbitrary);
       case 'empty':
         const {moduleCache} = this._options;
-        const module = moduleCache.getModule(ModuleResolver.EMPTY_MODULE);
-        invariant(module != null, 'empty module is not available');
-        return module;
+        const module_ = moduleCache.getModule(ModuleResolver.EMPTY_MODULE);
+        invariant(module_ != null, 'empty module is not available');
+        return module_;
       default:
         (resolution.type: empty);
         throw new Error('invalid type');
@@ -280,11 +302,49 @@ class UnableToResolveError extends Error {
     super();
     this.originModulePath = originModulePath;
     this.targetModuleName = targetModuleName;
-    this.message = util.format(
-      'Unable to resolve module `%s` from `%s`: %s',
-      targetModuleName,
-      originModulePath,
-      message,
+    const codeFrameMessage = this.buildCodeFrameMessage();
+    this.message =
+      util.format(
+        'Unable to resolve module %s from %s: %s',
+        targetModuleName,
+        originModulePath,
+        message,
+      ) + (codeFrameMessage ? '\n' + codeFrameMessage : '');
+  }
+
+  buildCodeFrameMessage(): ?string {
+    let file;
+    try {
+      file = fs.readFileSync(this.originModulePath, 'utf8');
+    } catch (error) {
+      if (error.code === 'ENOENT') {
+        // We're probably dealing with a virtualised file system where
+        // `this.originModulePath` doesn't actually exist on disk.
+        // We can't show a code frame, but there's no need to let this I/O
+        // error shadow the original module resolution error.
+        return null;
+      }
+      throw error;
+    }
+
+    const lines = file.split('\n');
+    let lineNumber = 0;
+    let column = -1;
+    for (let line = 0; line < lines.length; line++) {
+      const columnLocation = lines[line].lastIndexOf(this.targetModuleName);
+      if (columnLocation >= 0) {
+        lineNumber = line;
+        column = columnLocation;
+        break;
+      }
+    }
+
+    return codeFrameColumns(
+      fs.readFileSync(this.originModulePath, 'utf8'),
+      {
+        start: {column: column + 1, line: lineNumber + 1},
+      },
+      {forceColor: process.env.NODE_ENV !== 'test'},
     );
   }
 }
diff --git a/node_modules/metro/src/node-haste/DependencyGraph/ResolutionRequest.js b/node_modules/metro/src/node-haste/DependencyGraph/ResolutionRequest.js
deleted file mode 100644
index 8ade662..0000000
--- a/node_modules/metro/src/node-haste/DependencyGraph/ResolutionRequest.js
+++ /dev/null
@@ -1,89 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *
- * @format
- */
-"use strict";
-
-const path = require("path");
-
-const _require = require("metro-core"),
-  AmbiguousModuleResolutionError = _require.AmbiguousModuleResolutionError;
-
-const DuplicateHasteCandidatesError = require("jest-haste-map").ModuleMap
-  .DuplicateHasteCandidatesError;
-
-const _require2 = require("metro-resolver"),
-  InvalidPackageError = _require2.InvalidPackageError;
-
-const _require3 = require("metro-core"),
-  PackageResolutionError = _require3.PackageResolutionError;
-
-class ResolutionRequest {
-  constructor(options) {
-    this._options = options;
-
-    this._resetResolutionCache();
-  }
-
-  resolveDependency(fromModule, toModuleName) {
-    const resHash = getResolutionCacheKey(fromModule.path, toModuleName);
-    const immediateResolution = this._immediateResolutionCache[resHash];
-
-    if (immediateResolution) {
-      return immediateResolution;
-    }
-
-    const cacheResult = result => {
-      this._immediateResolutionCache[resHash] = result;
-      return result;
-    };
-
-    const resolver = this._options.moduleResolver;
-    const platform = this._options.platform;
-    const allowHaste = !this._options.helpers.isNodeModulesDir(fromModule.path);
-
-    try {
-      return cacheResult(
-        resolver.resolveDependency(
-          fromModule,
-          toModuleName,
-          allowHaste,
-          platform
-        )
-      );
-    } catch (error) {
-      if (error instanceof DuplicateHasteCandidatesError) {
-        throw new AmbiguousModuleResolutionError(fromModule.path, error);
-      }
-
-      if (error instanceof InvalidPackageError) {
-        throw new PackageResolutionError({
-          packageError: error,
-          originModulePath: fromModule.path,
-          targetModuleName: toModuleName
-        });
-      }
-
-      throw error;
-    }
-  }
-
-  _resetResolutionCache() {
-    this._immediateResolutionCache = Object.create(null);
-  }
-
-  getResolutionCache() {
-    return this._immediateResolutionCache;
-  }
-}
-
-function getResolutionCacheKey(modulePath, depName) {
-  return `${path.resolve(modulePath)}:${depName}`;
-}
-
-module.exports = ResolutionRequest;
diff --git a/node_modules/metro/src/node-haste/DependencyGraph/ResolutionRequest.js.flow b/node_modules/metro/src/node-haste/DependencyGraph/ResolutionRequest.js.flow
deleted file mode 100644
index 9de793f..0000000
--- a/node_modules/metro/src/node-haste/DependencyGraph/ResolutionRequest.js.flow
+++ /dev/null
@@ -1,118 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- * @format
- */
-
-'use strict';
-
-const path = require('path');
-
-const {AmbiguousModuleResolutionError} = require('metro-core');
-const {DuplicateHasteCandidatesError} = require('jest-haste-map').ModuleMap;
-const {InvalidPackageError} = require('metro-resolver');
-const {PackageResolutionError} = require('metro-core');
-
-import type DependencyGraphHelpers from './DependencyGraphHelpers';
-import type {ModuleResolver} from './ModuleResolution';
-
-export type Packageish = {
-  path: string,
-  redirectRequire(
-    toModuleName: string,
-    mainFields: $ReadOnlyArray<string>,
-  ): string | false,
-  getMain(mainFields: $ReadOnlyArray<string>): string,
-};
-
-export type Moduleish = {
-  +path: string,
-  getPackage(): ?Packageish,
-};
-
-export type ModuleishCache<TModule, TPackage> = {
-  getPackage(
-    name: string,
-    platform?: string,
-    supportsNativePlatform?: boolean,
-  ): TPackage,
-  getModule(path: string): TModule,
-};
-
-type Options<TModule, TPackage> = {|
-  +entryPath: string,
-  +helpers: DependencyGraphHelpers,
-  +moduleCache: ModuleishCache<TModule, TPackage>,
-  +moduleResolver: ModuleResolver<TModule, TPackage>,
-  +platform: string | null,
-|};
-
-class ResolutionRequest<TModule: Moduleish, TPackage: Packageish> {
-  _immediateResolutionCache: {[key: string]: TModule, __proto__: null};
-  _options: Options<TModule, TPackage>;
-
-  constructor(options: Options<TModule, TPackage>) {
-    this._options = options;
-    this._resetResolutionCache();
-  }
-
-  resolveDependency(fromModule: TModule, toModuleName: string): TModule {
-    const resHash = getResolutionCacheKey(fromModule.path, toModuleName);
-
-    const immediateResolution = this._immediateResolutionCache[resHash];
-    if (immediateResolution) {
-      return immediateResolution;
-    }
-
-    const cacheResult = (result: TModule) => {
-      this._immediateResolutionCache[resHash] = result;
-      return result;
-    };
-
-    const resolver = this._options.moduleResolver;
-    const platform = this._options.platform;
-
-    const allowHaste = !this._options.helpers.isNodeModulesDir(fromModule.path);
-
-    try {
-      return cacheResult(
-        resolver.resolveDependency(
-          fromModule,
-          toModuleName,
-          allowHaste,
-          platform,
-        ),
-      );
-    } catch (error) {
-      if (error instanceof DuplicateHasteCandidatesError) {
-        throw new AmbiguousModuleResolutionError(fromModule.path, error);
-      }
-      if (error instanceof InvalidPackageError) {
-        throw new PackageResolutionError({
-          packageError: error,
-          originModulePath: fromModule.path,
-          targetModuleName: toModuleName,
-        });
-      }
-      throw error;
-    }
-  }
-
-  _resetResolutionCache() {
-    this._immediateResolutionCache = Object.create(null);
-  }
-
-  getResolutionCache(): {[key: string]: TModule, __proto__: null} {
-    return this._immediateResolutionCache;
-  }
-}
-
-function getResolutionCacheKey(modulePath: string, depName: string): string {
-  return `${path.resolve(modulePath)}:${depName}`;
-}
-
-module.exports = ResolutionRequest;
diff --git a/node_modules/metro/src/node-haste/DependencyGraph/assets/empty-module.js b/node_modules/metro/src/node-haste/DependencyGraph/assets/empty-module.js
index a04c5af..8f256ed 100644
--- a/node_modules/metro/src/node-haste/DependencyGraph/assets/empty-module.js
+++ b/node_modules/metro/src/node-haste/DependencyGraph/assets/empty-module.js
@@ -5,6 +5,6 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @format
- *  strict
+ *
  */
 "use strict";
diff --git a/node_modules/metro/src/node-haste/FilesByDirNameIndex.js b/node_modules/metro/src/node-haste/FilesByDirNameIndex.js
deleted file mode 100644
index d0ae198..0000000
--- a/node_modules/metro/src/node-haste/FilesByDirNameIndex.js
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict
- * @format
- */
-"use strict";
-
-const path = require("path");
-/**
- * This is a way to find files quickly given a RegExp, in a specific directory.
- * This is must faster than iterating over all the files and matching both
- * directory and RegExp at the same time.
- *
- * This was first implemented to support finding assets fast, for which we know
- * the directory, but we want to identify all variants (ex. @2x, @1x, for
- * a picture's different definition levels).
- */
-
-class FilesByDirNameIndex {
-  constructor(allFilePaths) {
-    this._filesByDirName = new Map();
-
-    for (const filePath of allFilePaths) {
-      const dirName = path.dirname(filePath);
-
-      let dir = this._filesByDirName.get(dirName);
-
-      if (dir == null) {
-        dir = [];
-
-        this._filesByDirName.set(dirName, dir);
-      }
-
-      dir.push(path.basename(filePath));
-    }
-  }
-
-  getAllFiles(dirPath) {
-    return this._filesByDirName.get(dirPath) || [];
-  }
-}
-
-module.exports = FilesByDirNameIndex;
diff --git a/node_modules/metro/src/node-haste/FilesByDirNameIndex.js.flow b/node_modules/metro/src/node-haste/FilesByDirNameIndex.js.flow
deleted file mode 100644
index 47078d6..0000000
--- a/node_modules/metro/src/node-haste/FilesByDirNameIndex.js.flow
+++ /dev/null
@@ -1,46 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict
- * @format
- */
-
-'use strict';
-
-const path = require('path');
-
-/**
- * This is a way to find files quickly given a RegExp, in a specific directory.
- * This is must faster than iterating over all the files and matching both
- * directory and RegExp at the same time.
- *
- * This was first implemented to support finding assets fast, for which we know
- * the directory, but we want to identify all variants (ex. @2x, @1x, for
- * a picture's different definition levels).
- */
-class FilesByDirNameIndex {
-  _filesByDirName: Map<string, Array<string>>;
-
-  constructor(allFilePaths: Iterable<string>) {
-    this._filesByDirName = new Map();
-
-    for (const filePath of allFilePaths) {
-      const dirName = path.dirname(filePath);
-      let dir = this._filesByDirName.get(dirName);
-      if (dir == null) {
-        dir = [];
-        this._filesByDirName.set(dirName, dir);
-      }
-      dir.push(path.basename(filePath));
-    }
-  }
-
-  getAllFiles(dirPath: string): $ReadOnlyArray<string> {
-    return this._filesByDirName.get(dirPath) || [];
-  }
-}
-
-module.exports = FilesByDirNameIndex;
diff --git a/node_modules/metro/src/node-haste/Module.js.flow b/node_modules/metro/src/node-haste/Module.js.flow
index bcb0ae2..1ac1a3f 100644
--- a/node_modules/metro/src/node-haste/Module.js.flow
+++ b/node_modules/metro/src/node-haste/Module.js.flow
@@ -13,6 +13,7 @@
 const isAbsolutePath = require('absolute-path');
 
 import type ModuleCache from './ModuleCache';
+import type Package from './Package';
 
 class Module {
   path: string;
@@ -29,7 +30,7 @@ class Module {
     this._moduleCache = moduleCache;
   }
 
-  getPackage() {
+  getPackage(): ?Package {
     return this._moduleCache.getPackageForModule(this);
   }
 
diff --git a/node_modules/metro/src/node-haste/ModuleCache.js.flow b/node_modules/metro/src/node-haste/ModuleCache.js.flow
index bd17f12..19c8180 100644
--- a/node_modules/metro/src/node-haste/ModuleCache.js.flow
+++ b/node_modules/metro/src/node-haste/ModuleCache.js.flow
@@ -17,18 +17,26 @@ type GetClosestPackageFn = (filePath: string) => ?string;
 
 class ModuleCache {
   _getClosestPackage: GetClosestPackageFn;
-  _moduleCache: {[filePath: string]: Module, __proto__: null};
-  _packageCache: {[filePath: string]: Package, __proto__: null};
+  _moduleCache: {
+    [filePath: string]: Module,
+    __proto__: null,
+    ...
+  };
+  _packageCache: {
+    [filePath: string]: Package,
+    __proto__: null,
+    ...
+  };
   _packageModuleMap: WeakMap<Module, string>;
 
-  constructor(options: {getClosestPackage: GetClosestPackageFn}) {
+  constructor(options: {getClosestPackage: GetClosestPackageFn, ...}) {
     this._getClosestPackage = options.getClosestPackage;
     this._moduleCache = Object.create(null);
     this._packageCache = Object.create(null);
     this._packageModuleMap = new WeakMap();
   }
 
-  getModule(filePath: string) {
+  getModule(filePath: string): Module {
     if (!this._moduleCache[filePath]) {
       this._moduleCache[filePath] = new Module(filePath, this);
     }
diff --git a/node_modules/metro/src/node-haste/Package.js b/node_modules/metro/src/node-haste/Package.js
index fe94d6b..27f6529 100644
--- a/node_modules/metro/src/node-haste/Package.js
+++ b/node_modules/metro/src/node-haste/Package.js
@@ -4,35 +4,51 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 const fs = require("fs");
@@ -60,7 +76,7 @@ class Package {
         main = json[name];
         break;
       }
-    }
+    } // flowlint-next-line sketchy-null-string:off
 
     if (!main) {
       main = "index";
diff --git a/node_modules/metro/src/node-haste/Package.js.flow b/node_modules/metro/src/node-haste/Package.js.flow
index e1c2cfe..682f649 100644
--- a/node_modules/metro/src/node-haste/Package.js.flow
+++ b/node_modules/metro/src/node-haste/Package.js.flow
@@ -18,6 +18,7 @@ type PackageContent = {
   'react-native': mixed,
   browser: mixed,
   main: ?string,
+  ...
 };
 
 class Package {
@@ -26,7 +27,7 @@ class Package {
   _root: string;
   _content: ?PackageContent;
 
-  constructor({file}: {file: string}) {
+  constructor({file}: {file: string, ...}) {
     this.path = path.resolve(file);
     this._root = path.dirname(this.path);
     this._content = null;
@@ -48,6 +49,7 @@ class Package {
       }
     }
 
+    // flowlint-next-line sketchy-null-string:off
     if (!main) {
       main = 'index';
     }
@@ -140,7 +142,7 @@ class Package {
 function getReplacements(
   pkg: PackageContent,
   mainFields: $ReadOnlyArray<string>,
-): ?{[string]: string | false} {
+): ?{[string]: string | false, ...} {
   const replacements = mainFields
     .map((name: string) => {
       // If the field is a string, that doesn't mean we want to redirect the
diff --git a/node_modules/metro/src/node-haste/lib/AssetPaths.js b/node_modules/metro/src/node-haste/lib/AssetPaths.js
index 639461b..3048aa0 100644
--- a/node_modules/metro/src/node-haste/lib/AssetPaths.js
+++ b/node_modules/metro/src/node-haste/lib/AssetPaths.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/node-haste/lib/AssetPaths.js.flow b/node_modules/metro/src/node-haste/lib/AssetPaths.js.flow
index 3b6eaef..c437a90 100644
--- a/node_modules/metro/src/node-haste/lib/AssetPaths.js.flow
+++ b/node_modules/metro/src/node-haste/lib/AssetPaths.js.flow
@@ -25,7 +25,11 @@ const ASSET_BASE_NAME_RE = /(.+?)(@([\d.]+)x)?$/;
 
 function parseBaseName(
   baseName: string,
-): {resolution: number, rootName: string} {
+): {
+  resolution: number,
+  rootName: string,
+  ...
+} {
   const match = baseName.match(ASSET_BASE_NAME_RE);
   if (!match) {
     throw new Error(`invalid asset name: \`${baseName}'`);
diff --git a/node_modules/metro/src/node-haste/lib/MapWithDefaults.js b/node_modules/metro/src/node-haste/lib/MapWithDefaults.js
deleted file mode 100644
index f3eb576..0000000
--- a/node_modules/metro/src/node-haste/lib/MapWithDefaults.js
+++ /dev/null
@@ -1,30 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- *  strict
- * @format
- */
-"use strict";
-
-class MapWithDefaults extends Map {
-  constructor(factory, iterable) {
-    super(iterable);
-    this._factory = factory;
-  }
-
-  get(key) {
-    if (this.has(key)) {
-      return Map.prototype.get.call(this, key);
-    }
-
-    const value = this._factory(key);
-
-    this.set(key, value);
-    return value;
-  }
-}
-
-module.exports = MapWithDefaults;
diff --git a/node_modules/metro/src/node-haste/lib/MapWithDefaults.js.flow b/node_modules/metro/src/node-haste/lib/MapWithDefaults.js.flow
deleted file mode 100644
index 0f06c6f..0000000
--- a/node_modules/metro/src/node-haste/lib/MapWithDefaults.js.flow
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow strict
- * @format
- */
-
-'use strict';
-
-class MapWithDefaults<TK, TV> extends Map<TK, TV> {
-  _factory: TK => TV;
-
-  constructor(factory: TK => TV, iterable?: Iterable<[TK, TV]>) {
-    super(iterable);
-    this._factory = factory;
-  }
-
-  get(key: TK): TV {
-    if (this.has(key)) {
-      return Map.prototype.get.call(this, key);
-    }
-    const value = this._factory(key);
-    this.set(key, value);
-    return value;
-  }
-}
-
-module.exports = MapWithDefaults;
diff --git a/node_modules/metro/src/node-haste/lib/parsePlatformFilePath.js b/node_modules/metro/src/node-haste/lib/parsePlatformFilePath.js
index e2a9ea8..88a6768 100644
--- a/node_modules/metro/src/node-haste/lib/parsePlatformFilePath.js
+++ b/node_modules/metro/src/node-haste/lib/parsePlatformFilePath.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/node-haste/types.js b/node_modules/metro/src/node-haste/types.js
index 0221e3d..a48390f 100644
--- a/node_modules/metro/src/node-haste/types.js
+++ b/node_modules/metro/src/node-haste/types.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict"; // TODO(cpojer): Create a jest-types repo.
diff --git a/node_modules/metro/src/node-haste/types.js.flow b/node_modules/metro/src/node-haste/types.js.flow
index dd31464..ee215ee 100644
--- a/node_modules/metro/src/node-haste/types.js.flow
+++ b/node_modules/metro/src/node-haste/types.js.flow
@@ -14,8 +14,10 @@
 export type HasteFS = {
   exists(filePath: string): boolean,
   getAllFiles(): Array<string>,
+  getDependencies(filePath: string): Array<string>,
   getFileIterator(): Iterator<string>,
   getModuleName(filePath: string): ?string,
   getSha1(string): ?string,
   matchFiles(pattern: RegExp | string): Array<string>,
+  ...
 };
diff --git a/node_modules/metro/src/shared/output/RamBundle.js b/node_modules/metro/src/shared/output/RamBundle.js
index 55863f6..7f11600 100644
--- a/node_modules/metro/src/shared/output/RamBundle.js
+++ b/node_modules/metro/src/shared/output/RamBundle.js
@@ -4,26 +4,47 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -38,6 +59,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -49,6 +71,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -62,12 +85,15 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
@@ -86,9 +112,11 @@ function build(_x, _x2) {
 function _build() {
   _build = _asyncToGenerator(function*(packagerClient, requestOptions) {
     const options = _objectSpread(
+      _objectSpread(
+        _objectSpread({}, Server.DEFAULT_BUNDLE_OPTIONS),
+        requestOptions
+      ),
       {},
-      Server.DEFAULT_BUNDLE_OPTIONS,
-      requestOptions,
       {
         bundleType: "ram"
       }
diff --git a/node_modules/metro/src/shared/output/RamBundle/as-assets.js b/node_modules/metro/src/shared/output/RamBundle/as-assets.js
index 3908867..ffebd32 100644
--- a/node_modules/metro/src/shared/output/RamBundle/as-assets.js
+++ b/node_modules/metro/src/shared/output/RamBundle/as-assets.js
@@ -24,9 +24,8 @@ const writeFile = require("../writeFile");
 const writeSourceMap = require("./write-sourcemap");
 
 const _require = require("./util"),
-  joinModules = _require.joinModules;
+  joinModules = _require.joinModules; // must not start with a dot, as that won't go into the apk
 
-// must not start with a dot, as that won't go into the apk
 const MAGIC_RAM_BUNDLE_FILENAME = "UNBUNDLE";
 const MODULES_DIR = "js-modules";
 /**
diff --git a/node_modules/metro/src/shared/output/RamBundle/as-assets.js.flow b/node_modules/metro/src/shared/output/RamBundle/as-assets.js.flow
index 520760b..616c9f2 100644
--- a/node_modules/metro/src/shared/output/RamBundle/as-assets.js.flow
+++ b/node_modules/metro/src/shared/output/RamBundle/as-assets.js.flow
@@ -7,6 +7,7 @@
  * @flow
  * @format
  */
+
 'use strict';
 
 const MAGIC_RAM_BUNDLE_NUMBER = require('./magic-number');
diff --git a/node_modules/metro/src/shared/output/RamBundle/as-indexed-file.js b/node_modules/metro/src/shared/output/RamBundle/as-indexed-file.js
index b349134..cb58afa 100644
--- a/node_modules/metro/src/shared/output/RamBundle/as-indexed-file.js
+++ b/node_modules/metro/src/shared/output/RamBundle/as-indexed-file.js
@@ -11,28 +11,44 @@
 
 function _toConsumableArray(arr) {
   return (
-    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
+    _arrayWithoutHoles(arr) ||
+    _iterableToArray(arr) ||
+    _unsupportedIterableToArray(arr) ||
+    _nonIterableSpread()
   );
 }
 
 function _nonIterableSpread() {
-  throw new TypeError("Invalid attempt to spread non-iterable instance");
+  throw new TypeError(
+    "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
+  );
+}
+
+function _unsupportedIterableToArray(o, minLen) {
+  if (!o) return;
+  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
+  var n = Object.prototype.toString.call(o).slice(8, -1);
+  if (n === "Object" && o.constructor) n = o.constructor.name;
+  if (n === "Map" || n === "Set") return Array.from(o);
+  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
+    return _arrayLikeToArray(o, minLen);
 }
 
 function _iterableToArray(iter) {
-  if (
-    Symbol.iterator in Object(iter) ||
-    Object.prototype.toString.call(iter) === "[object Arguments]"
-  )
+  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
     return Array.from(iter);
 }
 
 function _arrayWithoutHoles(arr) {
-  if (Array.isArray(arr)) {
-    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
-      arr2[i] = arr[i];
-    return arr2;
-  }
+  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
+}
+
+function _arrayLikeToArray(arr, len) {
+  if (len == null || len > arr.length) len = arr.length;
+
+  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
+
+  return arr2;
 }
 
 const MAGIC_UNBUNDLE_FILE_HEADER = require("./magic-number");
diff --git a/node_modules/metro/src/shared/output/RamBundle/as-indexed-file.js.flow b/node_modules/metro/src/shared/output/RamBundle/as-indexed-file.js.flow
index c669dc6..836ed9d 100644
--- a/node_modules/metro/src/shared/output/RamBundle/as-indexed-file.js.flow
+++ b/node_modules/metro/src/shared/output/RamBundle/as-indexed-file.js.flow
@@ -7,6 +7,7 @@
  * @flow
  * @format
  */
+
 'use strict';
 
 const MAGIC_UNBUNDLE_FILE_HEADER = require('./magic-number');
@@ -127,7 +128,11 @@ function entryOffset(n: number): number {
 
 function buildModuleTable(
   startupCode: Buffer,
-  moduleBuffers: Array<{buffer: Buffer, id: number}>,
+  moduleBuffers: Array<{
+    buffer: Buffer,
+    id: number,
+    ...
+  }>,
   moduleGroups: ModuleGroups,
 ): Buffer {
   // table format:
@@ -193,7 +198,11 @@ function buildModuleBuffers(
   modules: $ReadOnlyArray<ModuleTransportLike>,
   moduleGroups: ModuleGroups,
   encoding: void | 'ascii' | 'utf16le' | 'utf8',
-): Array<{buffer: Buffer, id: number}> {
+): Array<{
+  buffer: Buffer,
+  id: number,
+  ...
+}> {
   return modules
     .filter((m: ModuleTransportLike) => !moduleGroups.modulesInGroups.has(m.id))
     .map(({id, code}) =>
diff --git a/node_modules/metro/src/shared/output/RamBundle/buildSourcemapWithMetadata.js b/node_modules/metro/src/shared/output/RamBundle/buildSourcemapWithMetadata.js
index 9a49694..3159940 100644
--- a/node_modules/metro/src/shared/output/RamBundle/buildSourcemapWithMetadata.js
+++ b/node_modules/metro/src/shared/output/RamBundle/buildSourcemapWithMetadata.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/shared/output/RamBundle/buildSourcemapWithMetadata.js.flow b/node_modules/metro/src/shared/output/RamBundle/buildSourcemapWithMetadata.js.flow
index f782553..0356631 100644
--- a/node_modules/metro/src/shared/output/RamBundle/buildSourcemapWithMetadata.js.flow
+++ b/node_modules/metro/src/shared/output/RamBundle/buildSourcemapWithMetadata.js.flow
@@ -7,6 +7,7 @@
  * @flow strict-local
  * @format
  */
+
 'use strict';
 
 const {
@@ -16,6 +17,7 @@ const {
 } = require('./util');
 
 import type {ModuleGroups, ModuleTransportLike} from '../../types.flow';
+import type {IndexMap} from 'metro-source-map';
 
 type Params = {|
   fixWrapperOffset: boolean,
@@ -24,7 +26,7 @@ type Params = {|
   startupModules: $ReadOnlyArray<ModuleTransportLike>,
 |};
 
-module.exports = ({
+module.exports = (({
   fixWrapperOffset,
   lazyModules,
   moduleGroups,
@@ -58,4 +60,4 @@ module.exports = ({
   }
 
   return map;
-};
+}: Params => IndexMap);
diff --git a/node_modules/metro/src/shared/output/RamBundle/magic-number.js b/node_modules/metro/src/shared/output/RamBundle/magic-number.js
index 92941fb..eb7d944 100644
--- a/node_modules/metro/src/shared/output/RamBundle/magic-number.js
+++ b/node_modules/metro/src/shared/output/RamBundle/magic-number.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/shared/output/RamBundle/magic-number.js.flow b/node_modules/metro/src/shared/output/RamBundle/magic-number.js.flow
index e0759de..50ad0f3 100644
--- a/node_modules/metro/src/shared/output/RamBundle/magic-number.js.flow
+++ b/node_modules/metro/src/shared/output/RamBundle/magic-number.js.flow
@@ -7,6 +7,7 @@
  * @flow strict
  * @format
  */
+
 'use strict';
 
 module.exports = 0xfb0bd1e5;
diff --git a/node_modules/metro/src/shared/output/RamBundle/util.js b/node_modules/metro/src/shared/output/RamBundle/util.js
index 77e72d6..520e222 100644
--- a/node_modules/metro/src/shared/output/RamBundle/util.js
+++ b/node_modules/metro/src/shared/output/RamBundle/util.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
@@ -17,8 +17,8 @@ const countLines = string => (string.match(newline) || []).length + 1;
 
 function lineToLineSourceMap(source) {
   let filename =
-    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
-  // The first line mapping in our package is the base64vlq code for zeros (A).
+    arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ""; // The first line mapping in our package is the base64vlq code for zeros (A).
+
   const firstLine = "AAAA;"; // Most other lines in our mappings are all zeros (for module, column etc)
   // except for the lineno mapping: curLineno - prevLineno = 1; Which is C.
 
diff --git a/node_modules/metro/src/shared/output/RamBundle/util.js.flow b/node_modules/metro/src/shared/output/RamBundle/util.js.flow
index 276d6ea..5e3cc48 100644
--- a/node_modules/metro/src/shared/output/RamBundle/util.js.flow
+++ b/node_modules/metro/src/shared/output/RamBundle/util.js.flow
@@ -7,6 +7,7 @@
  * @flow strict-local
  * @format
  */
+
 'use strict';
 
 const invariant = require('invariant');
@@ -21,7 +22,8 @@ import type {
 
 const newline = /\r\n?|\n|\u2028|\u2029/g;
 // fastest implementation
-const countLines = (string: string) => (string.match(newline) || []).length + 1;
+const countLines = (string: string): number =>
+  (string.match(newline) || []).length + 1;
 
 function lineToLineSourceMap(
   source: string,
@@ -50,7 +52,7 @@ const Section = (line: number, column: number, map: MixedSourceMap) => ({
   offset: {line, column},
 });
 
-type CombineOptions = {fixWrapperOffset: boolean};
+type CombineOptions = {fixWrapperOffset: boolean, ...};
 
 function combineSourceMaps(
   modules: $ReadOnlyArray<ModuleTransportLike>,
@@ -135,8 +137,8 @@ function combineMaps(
   return sections;
 }
 
-const joinModules = (modules: $ReadOnlyArray<{+code: string}>): string =>
-  modules.map((m: {+code: string}) => m.code).join('\n');
+const joinModules = (modules: $ReadOnlyArray<{+code: string, ...}>): string =>
+  modules.map((m: {+code: string, ...}) => m.code).join('\n');
 
 module.exports = {
   combineSourceMaps,
diff --git a/node_modules/metro/src/shared/output/RamBundle/write-sourcemap.js b/node_modules/metro/src/shared/output/RamBundle/write-sourcemap.js
index c90aa76..3fdffa1 100644
--- a/node_modules/metro/src/shared/output/RamBundle/write-sourcemap.js
+++ b/node_modules/metro/src/shared/output/RamBundle/write-sourcemap.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/shared/output/RamBundle/write-sourcemap.js.flow b/node_modules/metro/src/shared/output/RamBundle/write-sourcemap.js.flow
index d763f63..09cefbf 100644
--- a/node_modules/metro/src/shared/output/RamBundle/write-sourcemap.js.flow
+++ b/node_modules/metro/src/shared/output/RamBundle/write-sourcemap.js.flow
@@ -7,6 +7,7 @@
  * @flow strict-local
  * @format
  */
+
 'use strict';
 
 const writeFile = require('../writeFile');
diff --git a/node_modules/metro/src/shared/output/bundle.js b/node_modules/metro/src/shared/output/bundle.js
index 458a4c2..444c394 100644
--- a/node_modules/metro/src/shared/output/bundle.js
+++ b/node_modules/metro/src/shared/output/bundle.js
@@ -17,6 +17,7 @@ function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
     reject(error);
     return;
   }
+
   if (info.done) {
     resolve(value);
   } else {
@@ -30,32 +31,56 @@ function _asyncToGenerator(fn) {
       args = arguments;
     return new Promise(function(resolve, reject) {
       var gen = fn.apply(self, args);
+
       function _next(value) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
+
       function _throw(err) {
         asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
+
       _next(undefined);
     });
   };
 }
 
+function ownKeys(object, enumerableOnly) {
+  var keys = Object.keys(object);
+
+  if (Object.getOwnPropertySymbols) {
+    var symbols = Object.getOwnPropertySymbols(object);
+    if (enumerableOnly)
+      symbols = symbols.filter(function(sym) {
+        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
+      });
+    keys.push.apply(keys, symbols);
+  }
+
+  return keys;
+}
+
 function _objectSpread(target) {
   for (var i = 1; i < arguments.length; i++) {
     var source = arguments[i] != null ? arguments[i] : {};
-    var ownKeys = Object.keys(source);
-    if (typeof Object.getOwnPropertySymbols === "function") {
-      ownKeys = ownKeys.concat(
-        Object.getOwnPropertySymbols(source).filter(function(sym) {
-          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
-        })
-      );
+
+    if (i % 2) {
+      ownKeys(Object(source), true).forEach(function(key) {
+        _defineProperty(target, key, source[key]);
+      });
+    } else if (Object.getOwnPropertyDescriptors) {
+      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
+    } else {
+      ownKeys(Object(source)).forEach(function(key) {
+        Object.defineProperty(
+          target,
+          key,
+          Object.getOwnPropertyDescriptor(source, key)
+        );
+      });
     }
-    ownKeys.forEach(function(key) {
-      _defineProperty(target, key, source[key]);
-    });
   }
+
   return target;
 }
 
@@ -70,6 +95,7 @@ function _defineProperty(obj, key, value) {
   } else {
     obj[key] = value;
   }
+
   return obj;
 }
 
@@ -81,9 +107,16 @@ const writeFile = require("./writeFile");
 
 function buildBundle(packagerClient, requestOptions) {
   return packagerClient.build(
-    _objectSpread({}, Server.DEFAULT_BUNDLE_OPTIONS, requestOptions, {
-      bundleType: "bundle"
-    })
+    _objectSpread(
+      _objectSpread(
+        _objectSpread({}, Server.DEFAULT_BUNDLE_OPTIONS),
+        requestOptions
+      ),
+      {},
+      {
+        bundleType: "bundle"
+      }
+    )
   );
 }
 
@@ -105,8 +138,7 @@ function _saveBundleAndMap() {
       sourcemapSourcesRoot = options.sourcemapSourcesRoot;
     const writeFns = [];
     writeFns.push(
-      /*#__PURE__*/
-      _asyncToGenerator(function*() {
+      /*#__PURE__*/ _asyncToGenerator(function*() {
         log("Writing bundle output to:", bundleOutput);
         yield writeFile(bundleOutput, bundle.code, encoding);
         log("Done writing bundle output");
@@ -123,8 +155,7 @@ function _saveBundleAndMap() {
       }
 
       writeFns.push(
-        /*#__PURE__*/
-        _asyncToGenerator(function*() {
+        /*#__PURE__*/ _asyncToGenerator(function*() {
           log("Writing sourcemap output to:", sourcemapOutput);
           yield writeFile(sourcemapOutput, map, null);
           log("Done writing sourcemap output");
diff --git a/node_modules/metro/src/shared/output/bundle.js.flow b/node_modules/metro/src/shared/output/bundle.js.flow
index 3ed1c4f..4fcdfab 100644
--- a/node_modules/metro/src/shared/output/bundle.js.flow
+++ b/node_modules/metro/src/shared/output/bundle.js.flow
@@ -21,7 +21,11 @@ import type {MixedSourceMap} from 'metro-source-map';
 function buildBundle(
   packagerClient: Server,
   requestOptions: RequestOptions,
-): Promise<{code: string, map: string}> {
+): Promise<{
+  code: string,
+  map: string,
+  ...
+}> {
   return packagerClient.build({
     ...Server.DEFAULT_BUNDLE_OPTIONS,
     ...requestOptions,
@@ -39,7 +43,11 @@ function relativateSerializedMap(
 }
 
 async function saveBundleAndMap(
-  bundle: {code: string, map: string},
+  bundle: {
+    code: string,
+    map: string,
+    ...
+  },
   options: OutputOptions,
   log: (...args: Array<string>) => void,
 ): Promise<mixed> {
diff --git a/node_modules/metro/src/shared/output/meta.js b/node_modules/metro/src/shared/output/meta.js
index 32599af..7c08739 100644
--- a/node_modules/metro/src/shared/output/meta.js
+++ b/node_modules/metro/src/shared/output/meta.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/shared/output/meta.js.flow b/node_modules/metro/src/shared/output/meta.js.flow
index 3ee5005..3054067 100644
--- a/node_modules/metro/src/shared/output/meta.js.flow
+++ b/node_modules/metro/src/shared/output/meta.js.flow
@@ -7,6 +7,7 @@
  * @flow strict
  * @format
  */
+
 'use strict';
 
 /* global Buffer: true */
diff --git a/node_modules/metro/src/shared/output/unbundle.js b/node_modules/metro/src/shared/output/unbundle.js
index ed7917b..c4fec2f 100644
--- a/node_modules/metro/src/shared/output/unbundle.js
+++ b/node_modules/metro/src/shared/output/unbundle.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/shared/output/writeFile.js.flow b/node_modules/metro/src/shared/output/writeFile.js.flow
index 9806584..13b4dba 100644
--- a/node_modules/metro/src/shared/output/writeFile.js.flow
+++ b/node_modules/metro/src/shared/output/writeFile.js.flow
@@ -7,6 +7,7 @@
  * @flow
  * @format
  */
+
 'use strict';
 
 const denodeify = require('denodeify');
diff --git a/node_modules/metro/src/shared/types.flow.js b/node_modules/metro/src/shared/types.flow.js
index 7c6bffd..7e72086 100644
--- a/node_modules/metro/src/shared/types.flow.js
+++ b/node_modules/metro/src/shared/types.flow.js
@@ -4,7 +4,7 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- *  strict-local
+ *
  * @format
  */
 "use strict";
diff --git a/node_modules/metro/src/shared/types.flow.js.flow b/node_modules/metro/src/shared/types.flow.js.flow
index 55585f9..8ab4578 100644
--- a/node_modules/metro/src/shared/types.flow.js.flow
+++ b/node_modules/metro/src/shared/types.flow.js.flow
@@ -7,19 +7,20 @@
  * @flow strict-local
  * @format
  */
+
 'use strict';
 
 import type {Options as DeltaBundlerOptions} from '../DeltaBundler/types.flow';
-import type {
-  CustomTransformOptions,
-  MinifierOptions,
-} from '../JSTransformer/worker';
 import type {TransformInputOptions} from '../lib/transformHelpers';
+import type {TransformProfile} from 'metro-babel-transformer';
 import type {
-  BasicSourceMap,
   MixedSourceMap,
   MetroSourceMapSegmentTuple,
 } from 'metro-source-map';
+import type {
+  CustomTransformOptions,
+  MinifierOptions,
+} from 'metro-transform-worker';
 
 type BundleType =
   | 'bundle'
@@ -49,10 +50,13 @@ export type BundleOptions = {
   onProgress: ?(doneCont: number, totalCount: number) => mixed,
   +platform: ?string,
   +runModule: boolean,
+  runtimeBytecodeVersion: ?number,
   +shallow: boolean,
   sourceMapUrl: ?string,
   sourceUrl: ?string,
   createModuleIdFactory?: () => (path: string) => number,
+  +unstable_transformProfile: TransformProfile,
+  ...
 };
 
 export type SerializerOptions = {|
@@ -89,6 +93,7 @@ export type ModuleTransportLike = {
   +map: ?MetroSourceMapOrMappings,
   +name?: string,
   +sourcePath: string,
+  ...
 };
 export type ModuleTransportLikeStrict = {|
   +code: string,
@@ -112,6 +117,7 @@ export type OutputOptions = {
   sourcemapOutput?: string,
   sourcemapSourcesRoot?: string,
   sourcemapUseAbsolutePath?: boolean,
+  ...
 };
 
 export type RequestOptions = {|
@@ -126,10 +132,3 @@ export type RequestOptions = {|
 |};
 
 export type {MinifierOptions};
-
-export type MinifierResult = {
-  code: string,
-  map?: BasicSourceMap,
-};
-
-export type MetroMinifier = MinifierOptions => MinifierResult;
